<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 没有理想的人不伤心</title>
    <link>https://typesafe.cn/categories/java/</link>
    <description>Recent content in Java on 没有理想的人不伤心</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 16 Oct 2021 22:55:00 +0800</lastBuildDate><atom:link href="https://typesafe.cn/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 反序列化漏洞原理（二）新版本JDK利用方式和Shiro举例</title>
      <link>https://typesafe.cn/posts/java-serialization-vulnerability-2/</link>
      <pubDate>Sat, 16 Oct 2021 22:55:00 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/java-serialization-vulnerability-2/</guid>
      <description>声明    本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
新的希望    0x00    在上一节中我们介绍了 Java 反序列化漏洞的成因和利用 commons-collections 3.1 搭配 sun.reflect.annotation.AnnotationInvocationHandler 实现远程命令执行的方式。但sun.reflect.annotation.AnnotationInvocationHandler 的问题已经在最新版 jdk 中修复，可利用范围仅能够局限于旧版本的jdk。经过安全人员的审计，另一个类 javax.management.BadAttributeValueExpException 出现在了安全人员的视野。
javax.management.BadAttributeValueExpException 继承自 java.lang.Exception，java.lang.Exception 继承自 java.lang.Throwable，而 java.lang.Throwable 实现了 java.io.Serializable。因此 javax.management.BadAttributeValueExpException 符合了 可序列化 这个要求，同样的它也增加了 readObject 方法，这个类的完整代码如下：
package javax.management; import java.io.IOException; import java.io.ObjectInputStream; /** * Thrown when an invalid MBean attribute is passed to a query * constructing method. This exception is used internally by JMX * during the evaluation of a query.</description>
    </item>
    
    <item>
      <title>Java 反序列化漏洞原理（一）Serializable</title>
      <link>https://typesafe.cn/posts/java-serialization-vulnerability-1/</link>
      <pubDate>Thu, 14 Oct 2021 23:00:00 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/java-serialization-vulnerability-1/</guid>
      <description>声明    本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
序列化的定义    序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。
Java 中的序列化    Java 自身提供了序列化的功能，需要实现 java.io.Serializable 接口，标明该对象是可序列化的。 java.io.Serializable 是一个空接口，不需要对象实现方法。
以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。
import java.io.*; import java.nio.charset.StandardCharsets; import java.util.Base64; public class Eval0 { public static class Command implements Serializable { private String cmd; public String getCmd() { return cmd; } public void setCmd(String cmd) { this.cmd = cmd; } } public static void main(String[] args) throws Exception { // 定义一个对象  Command command = new Command(); command.</description>
    </item>
    
    <item>
      <title>Java的奇技淫巧</title>
      <link>https://typesafe.cn/posts/java-unexpected-features/</link>
      <pubDate>Sat, 13 Mar 2021 13:49:38 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/java-unexpected-features/</guid>
      <description>Java是一种广泛使用的计算机编程语言、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。
1995年3月23日Sun公司发布了Java，至今已有近26年，可以说是一门十分成熟的开发语言了，但在某些不为人知的地方存在着一些意料之外的特性。
Java的保留关键字 goto和const    在Java里面没有goto这个功能，但它作为保留字是无法当做变量来使用的，const也是同样。
int goto = 0; int const = 0; 上面这两行代码的写法存在问题，无法正常编译通过。
Java标签Label    上面说了在Java里面没有goto这个功能，但为了处理多重循环引入了Label，目的是为了在多重循环中方便的使用 break 和coutinue ，但好像在其他地方也可以用。
outerLoop: while (true) { System.out.println(&amp;#34;I&amp;#39;m the outer loop&amp;#34;); int i = 0; while (true) { System.out.println(&amp;#34;I am the inner loop&amp;#34;); i++; if (i &amp;gt;= 3) { break outerLoop; } } } System.out.println(&amp;#34;Complete the loop&amp;#34;); // 输出 I&amp;#39;m the outer loop I am the inner loop I am the inner loop I am the inner loop Complete the loop test: { System.</description>
    </item>
    
  </channel>
</rss>
