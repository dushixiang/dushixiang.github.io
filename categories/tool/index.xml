<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tool on 整点Bug</title><link>https://www.typesafe.cn/categories/tool/</link><description>Recent content in Tool on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 19 Nov 2020 22:33:00 +0000</lastBuildDate><atom:link href="https://www.typesafe.cn/categories/tool/index.xml" rel="self" type="application/rss+xml"/><item><title>服务器不允许上网并且需要跳板机才能访问？学会使用这个工具，轻松让服务器使用yum。</title><link>https://www.typesafe.cn/posts/4dnat/</link><pubDate>Thu, 19 Nov 2020 22:33:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/4dnat/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>你是否遇到过这样的场景，服务器不能上网，但是又需要安装某个软件，面对如蛛网般杂乱的rpm包依赖关系，放弃或许是最好的选择，这样你就不必再为无法完成工作而痛苦又懊恼。&lt;/p>
&lt;p>但是今天，你有了一个更好的选择。&lt;/p>
&lt;h1 id="4dnat">&lt;a href="https://github.com/dushixiang/4dnat">4DNAT&lt;/a>&lt;/h1>
&lt;p>4DNAT取名源自4和DNAT。这个工具工作在OSI模型的第四层传输层，同时4和for谐音，意为专门为目标地址转换而服务的工具。4DNAT使用go语言开发，具有天然的跨平台性，并且完全使用go标准库开发，没有任何的第三方依赖，编译之后只有一个二进制可执行文件。它有4种工作模式：&lt;/p>
&lt;h3 id="转发模式">转发模式&lt;/h3>
&lt;p>接受两个参数，监听端口和目标地址，在监听端口接收到请求后会主动连接目标地址，示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -forward &lt;span style="color:#ae81ff">2222&lt;/span> 192.168.1.100:22
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="监听模式">监听模式&lt;/h3>
&lt;p>接受两个参数，监听端口1和监听端口2，并交换两个端口接收到的数据，示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -listen &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代理人模式">代理人模式&lt;/h3>
&lt;p>接受两个参数，目标地址1和目标地址2，启动后会主动连接这两个目标地址，并交换两个端口接收到的数据，示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -agent 127.0.0.1:10000 127.0.0.1:22
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="httphttps代理模式">http/https代理模式&lt;/h3>
&lt;p>接受两个参数或四个参数，代理类型、监听端口、证书路径和私钥路径，示例：&lt;/p>
&lt;h4 id="http代理">http代理&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./4dnat -proxy http &lt;span style="color:#ae81ff">1080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="https代理">https代理&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./4dnat -proxy https &lt;span style="color:#ae81ff">1080&lt;/span> server.crt server.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用场景">使用场景&lt;/h1>
&lt;h3 id="场景一">场景一&lt;/h3>
&lt;p>期望可以在&lt;strong>用户电脑&lt;/strong>上直接访问目标服务器上的3306端口，跳板机器是一台Windows机器，没办法做ssh端口转发。
&lt;img src="https://oss.typesafe.cn/break-through-the-network.png" alt="请输入图片描述">&lt;/p>
&lt;blockquote>
&lt;p>单向虚线箭头表示可以单向访问，反之不行。&lt;/p>&lt;/blockquote>
&lt;p>使用4DNAT在&lt;strong>跳板机器&lt;/strong>上执行如下命令做端口转发&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本地监听3307端口，接收到请求后主动连接10.1.0.40的3306端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./4dnat -forward &lt;span style="color:#ae81ff">3307&lt;/span> 10.1.0.40:3306
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;strong>用户电脑&lt;/strong>上访问&lt;strong>172.16.0.30:3307&lt;/strong>即等同于访问&lt;strong>10.1.0.40:3306&lt;/strong>，于是就可以在&lt;strong>用户电脑&lt;/strong>愉快的访问&lt;strong>目标机器&lt;/strong>上的服务啦。&lt;/p>
&lt;h3 id="场景二">场景二&lt;/h3>
&lt;p>期望目标&lt;strong>目标机器&lt;/strong>可以上网，如使用yum安装软件。
&lt;img src="https://oss.typesafe.cn/break-through-the-network2.png" alt="请输入图片描述">&lt;/p>
&lt;ol>
&lt;li>在&lt;strong>用户电脑&lt;/strong>上开启一个http代理&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -proxy http &lt;span style="color:#ae81ff">1080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>在&lt;strong>跳板机器&lt;/strong>上使用监听模式监听两个端口，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -listen &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>在&lt;strong>目标机器&lt;/strong>上使用监听模式监听两个端口，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -listen &lt;span style="color:#ae81ff">20000&lt;/span> &lt;span style="color:#ae81ff">20001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>在&lt;strong>用户电脑&lt;/strong>上使用代理人模式主动连接两个目标地址，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -agent 127.0.0.1:1080 172.16.0.30:10000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>在&lt;strong>跳板机器&lt;/strong>上使用代理人模式主动连接两个目标地址，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -agent 127.0.0.1:10001 10.1.0.40:20000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>在&lt;strong>目标机器&lt;/strong>上修改代理&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; /etc/profile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">http_proxy=http://127.0.0.1:20001
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">https_proxy=http://127.0.0.1:20001
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">export http_proxy https_proxy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>在&lt;strong>目标机器&lt;/strong>上测试访问互联网&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl https://typesafe.cn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后奉上项目地址 &lt;a href="https://github.com/dushixiang/4dnat">https://github.com/dushixiang/4dnat&lt;/a>&lt;/p></description></item><item><title>Docker？Vmware？小孩子才做选择，打工人我全都要。</title><link>https://www.typesafe.cn/posts/docker-on-vmware/</link><pubDate>Tue, 17 Nov 2020 15:39:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/docker-on-vmware/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>作为一个称职的打工人，电脑上常备一个Vmware不是什么新鲜事了，但是它和Docker for Windows不兼容往往很让人头大。通过查找资料，发现提供的解决方案大致有三种&lt;/p>
&lt;ol>
&lt;li>先使用Vmware创建一台Linux虚拟机，在这台Linux虚拟机上再安装docker。&lt;/li>
&lt;li>配置Vmware作为Docker for Windows的运行平台。&lt;/li>
&lt;li>使用微软的Hyper-v来创建虚拟机。&lt;/li>
&lt;/ol>
&lt;p>对我而言，第一种不太优雅，第二种配置繁琐，第三种不会用。&lt;/p>
&lt;p>直到我发现了vctl这个好东西。&lt;/p>
&lt;h1 id="vctl-是什么">vctl 是什么？&lt;/h1>
&lt;blockquote>
&lt;p>vctl 是一款捆绑在Vmware Workstation Pro 应用程序中的命令行实用程序，仅在 Windows 10 1809 或更高版本上受支持。如果 Workstation Pro 所在主机上的 Windows 操作系统低于 Windows 10 1809，则它不支持 vctl CLI。&lt;/p>&lt;/blockquote>
&lt;p>简单来说它就是Vmware上的一个工具，可以用它来管理容器，使用命令基本上和docker一致，只需要把&lt;code>docker &amp;lt;cmd&amp;gt;&lt;/code>换成&lt;code>vctl &amp;lt;cmd&amp;gt;&lt;/code>就足够了。Docker for Windows？不需要。现在容器都交给vctl来管理了。&lt;/p>
&lt;p>在使用vctl命令前，和启动docker一样，需要先启动vctl的守护进程。&lt;/p>
&lt;pre tabindex="0">&lt;code>vctl system start
&lt;/code>&lt;/pre>&lt;p>当需要关闭守护进程时执行&lt;/p>
&lt;pre tabindex="0">&lt;code>vctl system stop
&lt;/code>&lt;/pre>&lt;p>接下来就是和普通的docker命令一样了。&lt;/p>
&lt;pre tabindex="0">&lt;code># 拉取镜像
vctl pull nginx

# 查看镜像
vctl images

# 启动容器
vctl --name some-nginx -d -p 8080:80 nginx

# 查看容器
vctl ps

# 进入容器
vctl exec -it &amp;lt;cid&amp;gt; bash 
&lt;/code>&lt;/pre>&lt;p>更多使用信息可参考Vmware的官方文档 &lt;a href="https://docs.vmware.com/cn/VMware-Fusion/11/com.vmware.fusion.using.doc/GUID-78E7339F-7294-4F3E-9AD0-1E14C201FA40.html">使用vctl命令管理容器&lt;/a>&lt;/p></description></item><item><title>tcpkill在go语言下的实现和增强</title><link>https://www.typesafe.cn/posts/tcpwall/</link><pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/tcpwall/</guid><description>&lt;h2 id="tcpwall">tcpwall&lt;/h2>
&lt;p>当我们想要阻止某些TCP连接的建立，在Linux平台上有一个很好的解决方案&lt;strong>iptables&lt;/strong>，但是对那些已经建立的tcp连接，iptables就不能做到随心所欲的阻断了。&lt;/p>
&lt;p>我在互联网上检索的时候发现了&lt;strong>tcpkill&lt;/strong>这个工具，tcpkill是一个网络分析工具集&lt;strong>dsniff&lt;/strong>中的一个小工具。在Linux上可以直接通过dsniff包安装，使用方式也非常简单。&lt;/p>
&lt;p>通过测试我发现tcpkill在执行命令之后并不会立刻阻断tcp连接，而是等待有数据传输时，才会阻断，因此在执行完命令之后程序并不会主动退出，而是需要通过&lt;em>&lt;strong>Ctrl+C&lt;/strong>&lt;/em>来退出，这对于某些想要通过程序来调用的脚本小子（例如我）来说简直是个灾难。&lt;/p>
&lt;h2 id="如何阻断一个已经建立的tcp连接">如何阻断一个已经建立的tcp连接？&lt;/h2>
&lt;p>阻断一个已经建立的tcp连接通常有这几种方案：&lt;/p>
&lt;ol>
&lt;li>服务端主动断开&lt;/li>
&lt;li>客户端主动断开&lt;/li>
&lt;li>拔掉网线（时间要超过tcp超时时间）&lt;/li>
&lt;li>伪造RST数据包发送给服务端和客户端让它们主动断开（tcpkill就是这么做的）&lt;/li>
&lt;/ol>
&lt;p>前三种局限性太大，只能用第4种了。&lt;/p>
&lt;h2 id="如何实现伪造rst数据报文包">如何实现伪造RST数据报文包？&lt;/h2>
&lt;p>&lt;a href="https://github.com/google/gopacket">GoPacket&lt;/a> 是go基于&lt;strong>libpcap&lt;/strong>构建的一个库，可以通过旁路的方式接收一份数据包的拷贝。因此我们可以很方便捕获到正在通信的tcp数据报文。通过数据报文，我们可以获取到通信双方的MAC地址，IP和端口号，以及ACK号等，这些都是伪造数据包必不可少的。&lt;/p>
&lt;p>在学习了&lt;strong>tcpkill&lt;/strong>的源码之后，我使用go开发了一个增强版的&lt;strong>tcpwall&lt;/strong>，&lt;strong>tcpwall&lt;/strong>不仅可以实现和&lt;strong>tcpkill&lt;/strong>同样的基于ip或端口监听到指定数据报文之后伪造RST数据报文来阻断tcp连接，也可以通过源ip源端口，目的ip目的端口来主动发送SYN数据报文包来诱导那些没有数据的tcp连接发送ACK数据报文包以获取源MAC、目的MAC和ACK号，并且可以通过指定参数让程序等待一段时间后主动退出。&lt;/p>
&lt;h2 id="如何使用">如何使用&lt;/h2>
&lt;p>阻断指定IP和端口的TCP连接（不关心是源或者目的）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -host &lt;span style="color:#f92672">{&lt;/span>host&lt;span style="color:#f92672">}&lt;/span> -port &lt;span style="color:#f92672">{&lt;/span>port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定源IP和源端口的TCP连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -shost &lt;span style="color:#f92672">{&lt;/span>src_host&lt;span style="color:#f92672">}&lt;/span> -sport &lt;span style="color:#f92672">{&lt;/span>src_port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定目的IP和目的端口的TCP连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -dhost &lt;span style="color:#f92672">{&lt;/span>dst_host&lt;span style="color:#f92672">}&lt;/span> -dport &lt;span style="color:#f92672">{&lt;/span>dst_port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定源IP、源端口、目的IP、目的端口的TCP连接（会主动向双方发送SYN数据报文包）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -shost &lt;span style="color:#f92672">{&lt;/span>src_host&lt;span style="color:#f92672">}&lt;/span> -sport &lt;span style="color:#f92672">{&lt;/span>src_port&lt;span style="color:#f92672">}&lt;/span> -dhost &lt;span style="color:#f92672">{&lt;/span>dst_host&lt;span style="color:#f92672">}&lt;/span> -dport &lt;span style="color:#f92672">{&lt;/span>dst_port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>-timeout 时间（秒）指定等待多久之后退出程序&lt;/li>
&lt;/ul>
&lt;p>项目地址 &lt;a href="https://github.com/dushixiang/tcpwall">https://github.com/dushixiang/tcpwall&lt;/a>&lt;/p></description></item></channel></rss>