<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux网络 on 整点Bug</title><link>https://www.typesafe.cn/categories/linux%E7%BD%91%E7%BB%9C/</link><description>Recent content in Linux网络 on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 28 Jan 2021 22:59:00 +0000</lastBuildDate><atom:link href="https://www.typesafe.cn/categories/linux%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 环回网络接口</title><link>https://www.typesafe.cn/posts/linux-loopback/</link><pubDate>Thu, 28 Jan 2021 22:59:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-loopback/</guid><description>&lt;p>在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动&lt;code>nginx&lt;/code>之后，在浏览器输入&lt;code>lcoalhost&lt;/code>或者&lt;code>127.0.0.1&lt;/code>就可以访问到本机上面的&lt;code>http&lt;/code>服务。&lt;/p>
&lt;h2 id="linux是如何访问本机ip的">Linux是如何访问本机IP的？&lt;/h2>
&lt;p>大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过&lt;code>TCP/IP&lt;/code>与同一台主机上的其他服务进行通信，以&lt;code>127&lt;/code>开头的&lt;code>IPv4&lt;/code>地址就是为它保留的，主流&lt;code>Linux&lt;/code>操作系统为环回网卡分配的地址都是&lt;code>127.0.0.1&lt;/code>，主机名是&lt;code>localhost&lt;/code>。&lt;/p>
&lt;p>环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。&lt;/p>
&lt;p>那环回网络接口是如何判断目的IP是否为本机地址的呢？&lt;/p>
&lt;p>答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ip route show table &lt;span style="color:#8be9fd;font-style:italic">local&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">local&lt;/span> 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">local&lt;/span> 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">local&lt;/span> 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>local&lt;/code>开头的便是本地IP，&lt;code>dev&lt;/code>后面是网卡名称。&lt;/p></description></item><item><title>Linux Bridge 详解</title><link>https://www.typesafe.cn/posts/linux-bridge/</link><pubDate>Fri, 13 Nov 2020 21:47:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-bridge/</guid><description>&lt;h1 id="linux-bridge-详解">Linux Bridge 详解&lt;/h1>
&lt;p>Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。&lt;/p>
&lt;p>Linux Bridge通常是搭配KVM、docker等虚拟化技术一起使用的，用于构建虚拟网络，因为此教程不涉及虚拟化技术，我们就使用前面学习过的netns来模拟虚拟设备。&lt;/p>
&lt;h2 id="如何使用linux-bridge">如何使用Linux Bridge？&lt;/h2>
&lt;p>操作网桥有多种方式，在这里我们介绍一下通过&lt;strong>bridge-utils&lt;/strong>来操作，由于它不是Linux系统自带的工具，因此需要我们手动来安装它。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y bridge-utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install -y bridge-utils
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>brctl help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>never heard of &lt;span style="color:#8be9fd;font-style:italic">command&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>help&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Usage: brctl &lt;span style="color:#ff79c6">[&lt;/span>commands&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addbr 	&amp;lt;bridge&amp;gt;		add bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delbr 	&amp;lt;bridge&amp;gt;		delete bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	add interface to bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	delete interface from bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	hairpin 	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &lt;span style="color:#ff79c6">{&lt;/span>on|off&lt;span style="color:#ff79c6">}&lt;/span>	turn hairpin on/off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setageing 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> ageing &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setbridgeprio	&amp;lt;bridge&amp;gt; &amp;lt;prio&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> bridge priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setfd 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> bridge forward delay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	sethello 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> hello &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setmaxage 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> max message age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setpathcost	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;cost&amp;gt;	&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> path cost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setportprio	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;prio&amp;gt;	&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> port priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	show 	&lt;span style="color:#ff79c6">[&lt;/span> &amp;lt;bridge&amp;gt; &lt;span style="color:#ff79c6">]&lt;/span>		show a list of bridges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showmacs 	&amp;lt;bridge&amp;gt;		show a list of mac addrs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showstp 	&amp;lt;bridge&amp;gt;		show bridge stp info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	stp 	&amp;lt;bridge&amp;gt; &lt;span style="color:#ff79c6">{&lt;/span>on|off&lt;span style="color:#ff79c6">}&lt;/span>	turn stp on/off
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用命令如&lt;/p></description></item><item><title>Linux veth pair 详解</title><link>https://www.typesafe.cn/posts/linux-veth-pair/</link><pubDate>Mon, 09 Nov 2020 22:45:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-veth-pair/</guid><description>&lt;h1 id="linux-veth-pair-详解">Linux veth pair 详解&lt;/h1>
&lt;p>veth pair是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/virtual-device-veth-1.png" alt="virtual-device-veth-1">&lt;/p>
&lt;p>由于它的这个特性，常常被用于构建虚拟网络拓扑。例如连接两个不同的网络命名空间(netns)，连接docker容器，连接网桥(Bridge)等，其中一个很常见的案例就是OpenStack Neutron底层用它来构建非常复杂的网络拓扑。&lt;/p>
&lt;h2 id="如何使用">如何使用？&lt;/h2>
&lt;p>创建一对veth&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add &amp;lt;veth name&amp;gt; type veth peer name &amp;lt;peer name&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="实验">实验&lt;/h2>
&lt;p>我们改造上一节完成的netns实验，使用veth pair将两个的隔离netns连接起来。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vethpair.png" alt="https://oss.typesafe.cn/vethpair.png">&lt;/p>
&lt;p>我们首先创建一对veth设备，将veth设备分别移动到两个netns中并启动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 创建一对veth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link add veth0 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> veth peer name veth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将veth移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth1 up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来我们测试一下。&lt;/p>
&lt;p>使用&lt;code>ip netns exec ns0 ping 10.0.0.2&lt;/code>在命名空间ns0中测试与tap1的网络连通性。&lt;/p></description></item><item><title>Linux Network Namespace (netns) 详解</title><link>https://www.typesafe.cn/posts/linux-netns/</link><pubDate>Sun, 08 Nov 2020 23:12:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-netns/</guid><description>&lt;p>Network Namespace （以下简称netns）是Linux内核提供的一项实现网络隔离的功能，它能隔离多个不同的网络空间，并且各自拥有独立的网络协议栈，这其中便包括了网络接口（网卡），路由表，iptables规则等。例如大名鼎鼎的docker便是基于netns实现的网络隔离，今天我们就来手动实验一下netns的隔离特性。&lt;/p>
&lt;h3 id="使用方式">使用方式&lt;/h3>
&lt;p>使用&lt;code>ip netns help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Usage: ip netns list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns add NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> NAME NETNSID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#ff79c6">[&lt;/span>-all&lt;span style="color:#ff79c6">]&lt;/span> netns delete &lt;span style="color:#ff79c6">[&lt;/span>NAME&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns identify &lt;span style="color:#ff79c6">[&lt;/span>PID&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns pids NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#ff79c6">[&lt;/span>-all&lt;span style="color:#ff79c6">]&lt;/span> netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>NAME&lt;span style="color:#ff79c6">]&lt;/span> cmd ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns monitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns list-id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开始实验">开始实验&lt;/h3>
&lt;p>我们将要构建如下图的网络&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/netns.png?t=2" alt="https://oss.typesafe.cn/netns.png">&lt;/p>
&lt;p>首先我们添加两个tap设备并配置上IP信息，然后添加两个netns，最后将tap设备移动到netns中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加并启动虚拟网卡tap设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap0 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap1 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.1/24 dev tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.2/24 dev tap1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将虚拟网卡tap0，tap1分别移动到ns0和ns1中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap1 netns ns1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在宿主机器上使用&lt;code>ping 10.0.0.1&lt;/code>测试与tap0的网络连通性&lt;/p></description></item><item><title>深入理解 Linux 虚拟网络设备 tun/tap</title><link>https://www.typesafe.cn/posts/linux-tun-tap/</link><pubDate>Sun, 08 Nov 2020 22:11:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-tun-tap/</guid><description>&lt;p>在探索Linux网络虚拟化的世界时，你一定会遇到tun和tap这两个关键概念。它们是理解VPN、虚拟机网络、容器网络等技术的基础。本文将带你深入了解tun/tap是什么，它们是如何工作的，以及如何在实践中使用它们。&lt;/p>
&lt;blockquote>
&lt;p>在计算机网络中，&lt;strong>tun&lt;/strong>与&lt;strong>tap&lt;/strong>是操作系统内核中的虚拟网络设备。不同于普通靠硬件网络适配器实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap是什么">tun/tap是什么？&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>tun&lt;/strong> (tunnel的缩写) 是一个虚拟的点对点网络设备，工作在网络层（OSI模型的第三层）。它处理的是IP数据包，所以你可以把它看作是一个虚拟的网卡，但它没有物理的MAC地址。tun设备常用于实现各种IP隧道，例如OpenVPN和IPSec。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>tap&lt;/strong> (network tap的缩写) 是一个虚拟的以太网设备，工作在数据链路层（OSI模型的第二层）。它处理的是以太网帧，因此它拥有一个MAC地址，行为上更像一个真实的以太网卡。tap设备最常见的用途是作为虚拟机的网卡（如QEMU/KVM），或者用于创建网络桥接，将虚拟机接入物理局域网。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tuntap-的工作原理">tun/tap 的工作原理&lt;/h3>
&lt;p>Linux中的tun/tap设备提供了一种能力，让用户空间的应用程序能够像读写文件一样，直接向内核网络协议栈注入数据包，或者从协议栈中接收数据包。&lt;/p>
&lt;p>操作tun/tap设备主要通过一个特殊的字符设备文件 &lt;code>/dev/net/tun&lt;/code>。当一个应用程序打开这个文件时，内核会创建一个与该文件描述符关联的虚拟网络接口（如 &lt;code>tun0&lt;/code> 或 &lt;code>tap0&lt;/code>）。&lt;/p>
&lt;p>数据流动的过程可以用下图来概括：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph TD
 subgraph &amp;#34;用户空间 (User Space)&amp;#34;
 App(&amp;#34;应用程序 (e.g., VPN, QEMU)&amp;#34;)
 end

 subgraph &amp;#34;内核空间 (Kernel Space)&amp;#34;
 DevFile(&amp;#34;/dev/net/tun&amp;#34;)
 Driver(&amp;#34;TUN/TAP 驱动&amp;#34;)
 NetStack(&amp;#34;网络协议栈&amp;#34;)
 PhyDriver(&amp;#34;物理网卡驱动&amp;#34;)
 end
 
 PHY(&amp;#34;物理网卡&amp;#34;)

 App &amp;lt;--&amp;gt;|经由文件描述符&amp;lt;br/&amp;gt;read()/write()| DevFile
 DevFile &amp;lt;--&amp;gt; Driver
 Driver &amp;lt;--&amp;gt; NetStack
 NetStack &amp;lt;--&amp;gt; PhyDriver
 PhyDriver &amp;lt;--&amp;gt; PHY
&lt;/code>&lt;/pre>&lt;p>&lt;strong>数据发送流程 (Outbound):&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>用户空间的应用程序（例如VPN客户端）通过文件描述符向 &lt;code>/dev/net/tun&lt;/code> 写入一个IP包（对于tun设备）或以太网帧（对于tap设备）。&lt;/li>
&lt;li>tun/tap驱动接收到数据，并将其作为一个数据包注入到内核网络协议栈中，就像数据是从一个真实的物理网卡传来一样。&lt;/li>
&lt;li>网络协议栈根据其路由表等信息对数据包进行处理（例如，路由选择、NAT转换）。&lt;/li>
&lt;li>最终，协议栈将数据包通过真实的物理网卡发送出去。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>数据接收流程 (Inbound):&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>物理网卡接收到一个数据包。&lt;/li>
&lt;li>内核网络协议栈处理这个数据包。&lt;/li>
&lt;li>如果路由规则指示这个数据包应该被发送到tun/tap虚拟接口，协议栈就会将它交给tun/tap驱动。&lt;/li>
&lt;li>驱动程序将该数据包放入一个队列，等待用户空间的应用程序通过文件描述符从 &lt;code>/dev/net/tun&lt;/code> 中读取。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>注意&lt;/strong>：当应用程序关闭该文件描述符时，对应的虚拟网络接口以及相关的路由等信息也会被内核自动删除。&lt;/p></description></item></channel></rss>