<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 没有理想的人不伤心</title>
    <link>https://typesafe.cn/tags/java/</link>
    <description>Recent content in Java on 没有理想的人不伤心</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 16 Oct 2021 22:55:00 +0800</lastBuildDate><atom:link href="https://typesafe.cn/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 反序列化漏洞原理（二）新版本JDK利用方式和Shiro举例</title>
      <link>https://typesafe.cn/posts/java-serialization-vulnerability-2/</link>
      <pubDate>Sat, 16 Oct 2021 22:55:00 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/java-serialization-vulnerability-2/</guid>
      <description>声明    本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
新的希望    0x00    在上一节中我们介绍了 Java 反序列化漏洞的成因和利用 commons-collections 3.1 搭配 sun.reflect.annotation.AnnotationInvocationHandler 实现远程命令执行的方式。但sun.reflect.annotation.AnnotationInvocationHandler 的问题已经在最新版 jdk 中修复，可利用范围仅能够局限于旧版本的jdk。经过安全人员的审计，另一个类 javax.management.BadAttributeValueExpException 出现在了安全人员的视野。
javax.management.BadAttributeValueExpException 继承自 java.lang.Exception，java.lang.Exception 继承自 java.lang.Throwable，而 java.lang.Throwable 实现了 java.io.Serializable。因此 javax.management.BadAttributeValueExpException 符合了 可序列化 这个要求，同样的它也增加了 readObject 方法，这个类的完整代码如下：
package javax.management; import java.io.IOException; import java.io.ObjectInputStream; /** * Thrown when an invalid MBean attribute is passed to a query * constructing method. This exception is used internally by JMX * during the evaluation of a query.</description>
    </item>
    
    <item>
      <title>Java 反序列化漏洞原理（一）Serializable</title>
      <link>https://typesafe.cn/posts/java-serialization-vulnerability-1/</link>
      <pubDate>Thu, 14 Oct 2021 23:00:00 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/java-serialization-vulnerability-1/</guid>
      <description>声明    本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
序列化的定义    序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。
Java 中的序列化    Java 自身提供了序列化的功能，需要实现 java.io.Serializable 接口，标明该对象是可序列化的。 java.io.Serializable 是一个空接口，不需要对象实现方法。
以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。
import java.io.*; import java.nio.charset.StandardCharsets; import java.util.Base64; public class Eval0 { public static class Command implements Serializable { private String cmd; public String getCmd() { return cmd; } public void setCmd(String cmd) { this.cmd = cmd; } } public static void main(String[] args) throws Exception { // 定义一个对象  Command command = new Command(); command.</description>
    </item>
    
    <item>
      <title>使用libvirt-java采集KVM虚拟机状态信息</title>
      <link>https://typesafe.cn/posts/collect-vm-stats-by-libvirt-java/</link>
      <pubDate>Wed, 19 May 2021 20:18:20 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/collect-vm-stats-by-libvirt-java/</guid>
      <description>虚拟化开发相较于普通开发是一个冷门的方向，大多数是使用Python开发，其中使用Java来做虚拟化的少之又少，资料更是少的可怜，为了实现需求我也是踩了不少坑，今天就为大家分享一下如何使用 libvirt-java 来采集KVM虚拟机的资源使用信息。
CPU使用率    libvirt并没有直接提供获取虚拟机CPU使用率的接口，需要我们自己来计算，网上分享的代码或者公式五花八门，大部分都是错误的，经过我的测试，找到了一个相对准确的计算公式。
cpu_usage = (cpu_time_now - cpu_time_t_second_ago) * 100 / (t * vCpus * 10^9) Java代码如下
// t秒前的CPU时间 long c1 = domain.getInfo().cpuTime; Thread.sleep(1000); // 当前CPU时间 long c2 = domain.getInfo().cpuTime; // 虚拟CPU数量 int vCpus = domain.getMaxVcpus(); // t 为1秒 Double cpuUsage = 100 * (c2 - c1) / (1 * vCpus * Math.pow(10, 9)); log.debug(&amp;#34;虚拟机[{}]CPU使用率为: {}&amp;#34;, uuid, cpuUsage); 内存使用率    不要使用domain.getInfo()返回的 memory字段，虽然它注释写的是the memory in KBytes used by the domain，但它的意思真的不是虚拟机内部进程已使用的内存大小，而是从宿主机器的角度来看分配给这个虚拟机的内存它使用了多少，如果没有特殊配置，它会和maxMem字段的值是相同的。</description>
    </item>
    
    <item>
      <title>Java的奇技淫巧</title>
      <link>https://typesafe.cn/posts/java-unexpected-features/</link>
      <pubDate>Sat, 13 Mar 2021 13:49:38 +0800</pubDate>
      
      <guid>https://typesafe.cn/posts/java-unexpected-features/</guid>
      <description>Java是一种广泛使用的计算机编程语言、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。
1995年3月23日Sun公司发布了Java，至今已有近26年，可以说是一门十分成熟的开发语言了，但在某些不为人知的地方存在着一些意料之外的特性。
Java的保留关键字 goto和const    在Java里面没有goto这个功能，但它作为保留字是无法当做变量来使用的，const也是同样。
int goto = 0; int const = 0; 上面这两行代码的写法存在问题，无法正常编译通过。
Java标签Label    上面说了在Java里面没有goto这个功能，但为了处理多重循环引入了Label，目的是为了在多重循环中方便的使用 break 和coutinue ，但好像在其他地方也可以用。
outerLoop: while (true) { System.out.println(&amp;#34;I&amp;#39;m the outer loop&amp;#34;); int i = 0; while (true) { System.out.println(&amp;#34;I am the inner loop&amp;#34;); i++; if (i &amp;gt;= 3) { break outerLoop; } } } System.out.println(&amp;#34;Complete the loop&amp;#34;); // 输出 I&amp;#39;m the outer loop I am the inner loop I am the inner loop I am the inner loop Complete the loop test: { System.</description>
    </item>
    
  </channel>
</rss>
