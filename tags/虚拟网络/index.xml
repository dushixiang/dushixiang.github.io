<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>虚拟网络 on 整点Bug</title><link>https://www.typesafe.cn/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/</link><description>Recent content in 虚拟网络 on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 08 Nov 2020 22:11:00 +0000</lastBuildDate><atom:link href="https://www.typesafe.cn/tags/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml"/><item><title>深入理解 Linux 虚拟网络设备 tun/tap</title><link>https://www.typesafe.cn/posts/linux-tun-tap/</link><pubDate>Sun, 08 Nov 2020 22:11:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-tun-tap/</guid><description>&lt;p>在探索Linux网络虚拟化的世界时，你一定会遇到tun和tap这两个关键概念。它们是理解VPN、虚拟机网络、容器网络等技术的基础。本文将带你深入了解tun/tap是什么，它们是如何工作的，以及如何在实践中使用它们。&lt;/p>
&lt;blockquote>
&lt;p>在计算机网络中，&lt;strong>tun&lt;/strong>与&lt;strong>tap&lt;/strong>是操作系统内核中的虚拟网络设备。不同于普通靠硬件网络适配器实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap是什么">tun/tap是什么？&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>tun&lt;/strong> (tunnel的缩写) 是一个虚拟的点对点网络设备，工作在网络层（OSI模型的第三层）。它处理的是IP数据包，所以你可以把它看作是一个虚拟的网卡，但它没有物理的MAC地址。tun设备常用于实现各种IP隧道，例如OpenVPN和IPSec。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>tap&lt;/strong> (network tap的缩写) 是一个虚拟的以太网设备，工作在数据链路层（OSI模型的第二层）。它处理的是以太网帧，因此它拥有一个MAC地址，行为上更像一个真实的以太网卡。tap设备最常见的用途是作为虚拟机的网卡（如QEMU/KVM），或者用于创建网络桥接，将虚拟机接入物理局域网。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tuntap-的工作原理">tun/tap 的工作原理&lt;/h3>
&lt;p>Linux中的tun/tap设备提供了一种能力，让用户空间的应用程序能够像读写文件一样，直接向内核网络协议栈注入数据包，或者从协议栈中接收数据包。&lt;/p>
&lt;p>操作tun/tap设备主要通过一个特殊的字符设备文件 &lt;code>/dev/net/tun&lt;/code>。当一个应用程序打开这个文件时，内核会创建一个与该文件描述符关联的虚拟网络接口（如 &lt;code>tun0&lt;/code> 或 &lt;code>tap0&lt;/code>）。&lt;/p>
&lt;p>数据流动的过程可以用下图来概括：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph TD
 subgraph &amp;#34;用户空间 (User Space)&amp;#34;
 App(&amp;#34;应用程序 (e.g., VPN, QEMU)&amp;#34;)
 end

 subgraph &amp;#34;内核空间 (Kernel Space)&amp;#34;
 DevFile(&amp;#34;/dev/net/tun&amp;#34;)
 Driver(&amp;#34;TUN/TAP 驱动&amp;#34;)
 NetStack(&amp;#34;网络协议栈&amp;#34;)
 PhyDriver(&amp;#34;物理网卡驱动&amp;#34;)
 end
 
 PHY(&amp;#34;物理网卡&amp;#34;)

 App &amp;lt;--&amp;gt;|经由文件描述符&amp;lt;br/&amp;gt;read()/write()| DevFile
 DevFile &amp;lt;--&amp;gt; Driver
 Driver &amp;lt;--&amp;gt; NetStack
 NetStack &amp;lt;--&amp;gt; PhyDriver
 PhyDriver &amp;lt;--&amp;gt; PHY
&lt;/code>&lt;/pre>&lt;p>&lt;strong>数据发送流程 (Outbound):&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>用户空间的应用程序（例如VPN客户端）通过文件描述符向 &lt;code>/dev/net/tun&lt;/code> 写入一个IP包（对于tun设备）或以太网帧（对于tap设备）。&lt;/li>
&lt;li>tun/tap驱动接收到数据，并将其作为一个数据包注入到内核网络协议栈中，就像数据是从一个真实的物理网卡传来一样。&lt;/li>
&lt;li>网络协议栈根据其路由表等信息对数据包进行处理（例如，路由选择、NAT转换）。&lt;/li>
&lt;li>最终，协议栈将数据包通过真实的物理网卡发送出去。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>数据接收流程 (Inbound):&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>物理网卡接收到一个数据包。&lt;/li>
&lt;li>内核网络协议栈处理这个数据包。&lt;/li>
&lt;li>如果路由规则指示这个数据包应该被发送到tun/tap虚拟接口，协议栈就会将它交给tun/tap驱动。&lt;/li>
&lt;li>驱动程序将该数据包放入一个队列，等待用户空间的应用程序通过文件描述符从 &lt;code>/dev/net/tun&lt;/code> 中读取。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>注意&lt;/strong>：当应用程序关闭该文件描述符时，对应的虚拟网络接口以及相关的路由等信息也会被内核自动删除。&lt;/p></description></item></channel></rss>