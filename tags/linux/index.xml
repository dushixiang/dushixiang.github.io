<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 整点Bug</title><link>https://www.typesafe.cn/tags/linux/</link><description>Recent content in Linux on 整点Bug</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 31 May 2021 19:20:00 +0800</lastBuildDate><atom:link href="https://www.typesafe.cn/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>KVM 虚拟机磁盘扩容</title><link>https://www.typesafe.cn/posts/kvm-disk-resize/</link><pubDate>Mon, 31 May 2021 19:20:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/kvm-disk-resize/</guid><description>&lt;h3 id="一镜像扩容">一、镜像扩容&lt;/h3>
&lt;p>注意：需要先关闭虚拟机才能操作，&lt;code>+&lt;/code>号前面有空格，后面没有空格。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-img resize test.qcow2 +80G
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原镜像磁盘大小20GB，扩容完成后可使用以下命令查看&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qemu-img info test.qcow2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>image: test.qcow2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>file format: qcow2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>virtual size: 100G &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">107374182400&lt;/span> bytes&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>disk size: 885M
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cluster_size: &lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Format specific information:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compat: 1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lazy refcounts: false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> refcount bits: &lt;span style="color:#ae81ff">16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corrupt: false
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="二windows磁盘扩容">二、Windows磁盘扩容&lt;/h3>
&lt;p>Windows磁盘扩容比较方便，进入 &lt;strong>计算机管理&amp;gt;磁盘管理&lt;/strong> 找到新增的分区把它添加到需要的分区即可。&lt;/p>
&lt;h3 id="三linux磁盘扩容">三、Linux磁盘扩容&lt;/h3>
&lt;p>启动虚拟机后，进入虚拟机控制台，使用&lt;code>fdisk -l&lt;/code>命令查看磁盘信息。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Disk /dev/vda: &lt;span style="color:#ae81ff">100&lt;/span> GiB, &lt;span style="color:#ae81ff">107374182400&lt;/span> bytes, &lt;span style="color:#ae81ff">209715200&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#ae81ff">1&lt;/span> * 512 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#f92672">(&lt;/span>minimum/optimal&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disklabel type: dos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk identifier: 0xe11f7f01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Device Boot Start End Sectors Size Id Type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda1 * &lt;span style="color:#ae81ff">2048&lt;/span> &lt;span style="color:#ae81ff">2099199&lt;/span> &lt;span style="color:#ae81ff">2097152&lt;/span> 1G &lt;span style="color:#ae81ff">83&lt;/span> Linux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/dev/vda2 &lt;span style="color:#ae81ff">2099200&lt;/span> &lt;span style="color:#ae81ff">41943039&lt;/span> &lt;span style="color:#ae81ff">39843840&lt;/span> 19G 8e Linux LVM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/mapper/cl-root: &lt;span style="color:#ae81ff">17&lt;/span> GiB, &lt;span style="color:#ae81ff">18249416704&lt;/span> bytes, &lt;span style="color:#ae81ff">35643392&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#ae81ff">1&lt;/span> * 512 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#f92672">(&lt;/span>minimum/optimal&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Disk /dev/mapper/cl-swap: &lt;span style="color:#ae81ff">2&lt;/span> GiB, &lt;span style="color:#ae81ff">2147483648&lt;/span> bytes, &lt;span style="color:#ae81ff">4194304&lt;/span> sectors
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Units: sectors of &lt;span style="color:#ae81ff">1&lt;/span> * 512 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sector size &lt;span style="color:#f92672">(&lt;/span>logical/physical&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I/O size &lt;span style="color:#f92672">(&lt;/span>minimum/optimal&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#ae81ff">512&lt;/span> bytes / &lt;span style="color:#ae81ff">512&lt;/span> bytes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到这台虚拟机的磁盘大小已经有100GB了，但分区大小还是没有变化，只有初始大小20GB。&lt;/p></description></item><item><title>Linux虚拟化技术KVM</title><link>https://www.typesafe.cn/posts/linux-kvm/</link><pubDate>Sat, 29 May 2021 17:07:00 +0800</pubDate><guid>https://www.typesafe.cn/posts/linux-kvm/</guid><description>&lt;p>在Windows平台上我们习惯于使用VmWare或者virtual box来实现虚拟化，虽然它们拥有Linux版本，但大多数企业都选择了使用KVM来做Linux平台的虚拟化，因此学习掌握KVM是一项必不可少的技能。&lt;/p>
&lt;h3 id="安装kvm">安装KVM&lt;/h3>
&lt;p>以centos为例，下面是安装KVM虚拟化的命令。&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install -y qemu-kvm libvirt virt-install bridge-utils
&lt;/code>&lt;/pre>&lt;p>&lt;strong>这么多软件都是什么作用？&lt;/strong>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>软件&lt;/th>
 &lt;th>作用&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>qemu-kvm&lt;/td>
 &lt;td>整合了QEMU 和 KVM 的一个软件。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>libvirt&lt;/td>
 &lt;td>封装了QEMU的接口，可以更加方便的操作虚拟机，并且提供了很多种编程语言的SDK。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>virt-install&lt;/td>
 &lt;td>用来创建虚拟机的命令行工具。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>bridge-utils&lt;/td>
 &lt;td>Linux网桥，用来配置虚拟机的桥接网络。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>kvm、qemu、qemu-kvm和libvirt到底有什么关系？&lt;/strong>&lt;/p>
&lt;p>KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它需要CPU的支持，采用硬件辅助虚拟化技术Intel-VT、AMD-V；内存相关如Intel的EPT和AMD的RVI技术，使得它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。&lt;/p>
&lt;p>QEMU是一个纯软件实现的虚拟机，它可以模拟CPU、内存、磁盘等其他硬件，让虚拟机认为自己底层就是硬件，其实这些都是QEMU模拟的，虚拟机的所有操作都要经过QEMU转译一层，也就导致了QEMU本身的性能较差。&lt;/p>
&lt;p>qemu-kvm是QEMU整合了KVM，把CPU虚拟化和内存虚拟化交给了KVM来做，自己来模拟IO设备，例如网卡和磁盘。这一套组合拳打下来，性能损失大大降低，相较于直接使用硬件，带来的损耗大概在1%-2%之间。&lt;/p>
&lt;p>libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和API。Libvirtd是一个daemon进程，可以被本地的virsh调用，也可以被远程的virsh调用，Libvirtd调用qemu-kvm操作虚拟机。&lt;/p>
&lt;p>&lt;strong>启动libvirt&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>systemctl start libvirtd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl enable libvirtd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你不想使用命令行工具来管理虚拟机，可以安装 virt-manager 。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install -y virt-manager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在支持x11转发的ssh客户端（例如：&lt;a href="https://mobaxterm.mobatek.net/">MobaXterm&lt;/a>）上可以直接输入 virt-manager 来启动。&lt;/p>
&lt;h3 id="虚拟网络类型">虚拟网络类型&lt;/h3>
&lt;p>和vmware类型，kvm也支持多种类型的网络，主要分为三种。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>NAT模式&lt;/strong> 虚拟机需要把流量发送到宿主机，宿主机器转换网络信息后再发出，外部机器无法感知到虚拟机的存在。此种方式宿主机器相当于一个路由器，因此宿主机上会有一个和虚拟机同网段的IP，并且虚拟机的网关地址是宿主机的这个IP。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主机模式&lt;/strong> 虚拟机只能互相访问，不能访问宿主机。此种方式与NAT模式类似，但它没有与虚拟机同网段的IP，因此虚拟机也不能借助于宿主机来访问外部网络。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>桥接模式&lt;/strong> 虚拟机和宿主机都关联在一个网桥上，因此虚拟机可以与宿主机在同一个网段，并且外部机器可以直接访问到虚拟机，虚拟机也可以借助网桥来访问外部网络。&lt;/p>
&lt;blockquote>
&lt;p>还有一种模式在openstack等云平台上使用较为广泛，网桥上绑定的物理网卡没有IP，对应交换机配置端口为trunk模式，虚拟机 端口连接到网桥上，并配置端口不同的VLAN tag以达到隔离和互联的目的。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>NAT模式和主机模式都无需单独配置，接下来我们看下如何配置桥接网络。&lt;/p>
&lt;h3 id="配置桥接网络">配置桥接网络&lt;/h3>
&lt;p>物理网卡绑定到网桥上之后就会导致网络断开，因此我们需要把原IP配置到网桥上。&lt;/p>
&lt;pre tabindex="0">&lt;code># 进入网卡配置文件夹
cd /etc/sysconfig/network-scripts/
# 拷贝原网卡配置文件作为桥接网卡
cp ifcfg-enp134s0f0 ifcfg-br0
&lt;/code>&lt;/pre>&lt;p>修改 &lt;code>ifcfg-br0&lt;/code> 中的 &lt;code>TYPE=Ethernet&lt;/code> 为 &lt;code> TYPE=Bridge&lt;/code>，最终效果如下：&lt;/p></description></item><item><title>Linux 环回网络接口</title><link>https://www.typesafe.cn/posts/linux-loopback/</link><pubDate>Thu, 28 Jan 2021 22:59:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-loopback/</guid><description>&lt;p>在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动&lt;code>nginx&lt;/code>之后，在浏览器输入&lt;code>lcoalhost&lt;/code>或者&lt;code>127.0.0.1&lt;/code>就可以访问到本机上面的&lt;code>http&lt;/code>服务。&lt;/p>
&lt;h2 id="linux是如何访问本机ip的">Linux是如何访问本机IP的？&lt;/h2>
&lt;p>大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过&lt;code>TCP/IP&lt;/code>与同一台主机上的其他服务进行通信，以&lt;code>127&lt;/code>开头的&lt;code>IPv4&lt;/code>地址就是为它保留的，主流&lt;code>Linux&lt;/code>操作系统为环回网卡分配的地址都是&lt;code>127.0.0.1&lt;/code>，主机名是&lt;code>localhost&lt;/code>。&lt;/p>
&lt;p>环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。&lt;/p>
&lt;p>那环回网络接口是如何判断目的IP是否为本机地址的呢？&lt;/p>
&lt;p>答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ip route show table local
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出内容如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>local 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>local&lt;/code>开头的便是本地IP，&lt;code>dev&lt;/code>后面是网卡名称。&lt;/p></description></item><item><title>Linux 修改最大文件描述符</title><link>https://www.typesafe.cn/posts/linux-limit/</link><pubDate>Mon, 11 Jan 2021 15:40:41 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-limit/</guid><description>&lt;pre tabindex="0">&lt;code>echo &amp;#34;fs.file-max=655350&amp;#34; &amp;gt;&amp;gt;/etc/sysctl.conf
echo &amp;#34;* soft nofile 655350&amp;#34; &amp;gt;&amp;gt; /etc/security/limits.conf
echo &amp;#34;* hard nofile 655350&amp;#34; &amp;gt;&amp;gt; /etc/security/limits.conf
ulimit -n 655350
&lt;/code>&lt;/pre></description></item><item><title>Linux Bridge 详解</title><link>https://www.typesafe.cn/posts/linux-bridge/</link><pubDate>Fri, 13 Nov 2020 21:47:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-bridge/</guid><description>&lt;h1 id="linux-bridge-详解">Linux Bridge 详解&lt;/h1>
&lt;p>Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。&lt;/p>
&lt;p>Linux Bridge通常是搭配KVM、docker等虚拟化技术一起使用的，用于构建虚拟网络，因为此教程不涉及虚拟化技术，我们就使用前面学习过的netns来模拟虚拟设备。&lt;/p>
&lt;h2 id="如何使用linux-bridge">如何使用Linux Bridge？&lt;/h2>
&lt;p>操作网桥有多种方式，在这里我们介绍一下通过&lt;strong>bridge-utils&lt;/strong>来操作，由于它不是Linux系统自带的工具，因此需要我们手动来安装它。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># centos&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y bridge-utils
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ubuntu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install -y bridge-utils
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>brctl help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>never heard of command &lt;span style="color:#f92672">[&lt;/span>help&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Usage: brctl &lt;span style="color:#f92672">[&lt;/span>commands&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addbr 	&amp;lt;bridge&amp;gt;		add bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delbr 	&amp;lt;bridge&amp;gt;		delete bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	addif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	add interface to bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	delif 	&amp;lt;bridge&amp;gt; &amp;lt;device&amp;gt;	delete interface from bridge
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	hairpin 	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &lt;span style="color:#f92672">{&lt;/span>on|off&lt;span style="color:#f92672">}&lt;/span>	turn hairpin on/off
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setageing 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set ageing time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setbridgeprio	&amp;lt;bridge&amp;gt; &amp;lt;prio&amp;gt;		set bridge priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setfd 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set bridge forward delay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	sethello 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set hello time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setmaxage 	&amp;lt;bridge&amp;gt; &amp;lt;time&amp;gt;		set max message age
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setpathcost	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;cost&amp;gt;	set path cost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	setportprio	&amp;lt;bridge&amp;gt; &amp;lt;port&amp;gt; &amp;lt;prio&amp;gt;	set port priority
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	show 	&lt;span style="color:#f92672">[&lt;/span> &amp;lt;bridge&amp;gt; &lt;span style="color:#f92672">]&lt;/span>		show a list of bridges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showmacs 	&amp;lt;bridge&amp;gt;		show a list of mac addrs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	showstp 	&amp;lt;bridge&amp;gt;		show bridge stp info
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	stp 	&amp;lt;bridge&amp;gt; &lt;span style="color:#f92672">{&lt;/span>on|off&lt;span style="color:#f92672">}&lt;/span>	turn stp on/off
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>常用命令如&lt;/p></description></item><item><title>Linux veth pair 详解</title><link>https://www.typesafe.cn/posts/linux-veth-pair/</link><pubDate>Mon, 09 Nov 2020 22:45:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-veth-pair/</guid><description>&lt;h1 id="linux-veth-pair-详解">Linux veth pair 详解&lt;/h1>
&lt;p>veth pair是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/virtual-device-veth-1.png" alt="virtual-device-veth-1">&lt;/p>
&lt;p>由于它的这个特性，常常被用于构建虚拟网络拓扑。例如连接两个不同的网络命名空间(netns)，连接docker容器，连接网桥(Bridge)等，其中一个很常见的案例就是OpenStack Neutron底层用它来构建非常复杂的网络拓扑。&lt;/p>
&lt;h2 id="如何使用">如何使用？&lt;/h2>
&lt;p>创建一对veth&lt;/p>
&lt;pre tabindex="0">&lt;code>ip link add &amp;lt;veth name&amp;gt; type veth peer name &amp;lt;peer name&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="实验">实验&lt;/h2>
&lt;p>我们改造上一节完成的netns实验，使用veth pair将两个的隔离netns连接起来。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/vethpair.png" alt="https://oss.typesafe.cn/vethpair.png">&lt;/p>
&lt;p>我们首先创建一对veth设备，将veth设备分别移动到两个netns中并启动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建一对veth&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link add veth0 type veth peer name veth1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将veth移动到netns中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set veth0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set veth1 netns ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns0 ip link set veth0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns exec ns1 ip link set veth1 up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来我们测试一下。&lt;/p></description></item><item><title>Linux Network Namespace (netns) 详解</title><link>https://www.typesafe.cn/posts/linux-netns/</link><pubDate>Sun, 08 Nov 2020 23:12:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-netns/</guid><description>&lt;p>Network Namespace （以下简称netns）是Linux内核提供的一项实现网络隔离的功能，它能隔离多个不同的网络空间，并且各自拥有独立的网络协议栈，这其中便包括了网络接口（网卡），路由表，iptables规则等。例如大名鼎鼎的docker便是基于netns实现的网络隔离，今天我们就来手动实验一下netns的隔离特性。&lt;/p>
&lt;h3 id="使用方式">使用方式&lt;/h3>
&lt;p>使用&lt;code>ip netns help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Usage: ip netns list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns add NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns set NAME NETNSID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#f92672">[&lt;/span>-all&lt;span style="color:#f92672">]&lt;/span> netns delete &lt;span style="color:#f92672">[&lt;/span>NAME&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns identify &lt;span style="color:#f92672">[&lt;/span>PID&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns pids NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip &lt;span style="color:#f92672">[&lt;/span>-all&lt;span style="color:#f92672">]&lt;/span> netns exec &lt;span style="color:#f92672">[&lt;/span>NAME&lt;span style="color:#f92672">]&lt;/span> cmd ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns monitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ip netns list-id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="开始实验">开始实验&lt;/h3>
&lt;p>我们将要构建如下图的网络&lt;/p>
&lt;p>&lt;img src="https://oss.typesafe.cn/netns.png?t=2" alt="https://oss.typesafe.cn/netns.png">&lt;/p>
&lt;p>首先我们添加两个tap设备并配置上IP信息，然后添加两个netns，最后将tap设备移动到netns中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加并启动虚拟网卡tap设备&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap0 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap1 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap0 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap1 up
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 配置IP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.1/24 dev tap0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip addr add 10.0.0.2/24 dev tap1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 添加netns&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip netns add ns1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将虚拟网卡tap0，tap1分别移动到ns0和ns1中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap0 netns ns0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip link set tap1 netns ns1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在宿主机器上使用&lt;code>ping 10.0.0.1&lt;/code>测试与tap0的网络连通性&lt;/p></description></item><item><title>Linux tun/tap 详解</title><link>https://www.typesafe.cn/posts/linux-tun-tap/</link><pubDate>Sun, 08 Nov 2020 22:11:00 +0000</pubDate><guid>https://www.typesafe.cn/posts/linux-tun-tap/</guid><description>&lt;blockquote>
&lt;p>在计算机网络中，&lt;strong>tun&lt;/strong>与&lt;strong>tap&lt;/strong>是操作系统内核中的虚拟网络设备。不同于普通靠硬件网络适配器实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap是什么">tun/tap是什么？&lt;/h3>
&lt;p>tun是网络层的虚拟网络设备，可以收发第三层数据报文包，如IP封包，因此常用于一些点对点IP隧道，例如OpenVPN，IPSec等。&lt;/p>
&lt;p>tap是链路层的虚拟网络设备，等同于一个以太网设备，它可以收发第二层数据报文包，如以太网数据帧。Tap最常见的用途就是做为虚拟机的网卡，因为它和普通的物理网卡更加相近，也经常用作普通机器的虚拟网卡。&lt;/p>
&lt;h3 id="如何操作tuntap">如何操作tun/tap？&lt;/h3>
&lt;p>Linux tun/tap可以通过网络接口和字符设备两种方式进行操作。&lt;/p>
&lt;p>当应用程序使用标准网络接口socket API操作tun/tap设备时，和操作一个真实网卡无异。&lt;/p>
&lt;p>当应用程序使用字符设备操作tun/tap设备时，字符设备即充当了用户空间和内核空间的桥梁直接读写二层或三层的数据报文。在 Linux 内核 2.6.x 之后的版本中，tun/tap 对应的字符设备文件分别为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tun：/dev/net/tun
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tap：/dev/tap0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当应用程序打开字符设备时，系统会自动创建对应的虚拟设备接口，一般以tunX和tapX方式命名，虚拟设备接口创建成功后，可以为其配置IP、MAC地址、路由等。当一切配置完毕，应用程序通过此字符文件设备写入IP封包或以太网数据帧，tun/tap的驱动程序会将数据报文直接发送到内核空间，内核空间收到数据后再交给系统的网络协议栈进行处理，最后网络协议栈选择合适的物理网卡将其发出，到此发送流程完成。而物理网卡收到数据报文时会交给网络协议栈进行处理，网络协议栈匹配判断之后通过tun/tap的驱动程序将数据报文原封不动的写入到字符设备上，应用程序从字符设备上读取到IP封包或以太网数据帧，最后进行相应的处理，收取流程完成。&lt;/p>
&lt;blockquote>
&lt;p>注意：当应用程序关闭字符设备时，系统也会自动删除对应的虚拟设备接口，并且会删除掉创建的路由等信息。&lt;/p>&lt;/blockquote>
&lt;h3 id="tuntap的区别">tun/tap的区别&lt;/h3>
&lt;p>tun/tap 虽然工作原理一致，但是工作的层次不一样。&lt;/p>
&lt;p>tun是三层网络设备，收发的是IP层数据包，无法处理以太网数据帧，例如OpenVPN的路由模式就是使用了tun网络设备，OpenVPN Server重新规划了一个网段，所有的客户端都会获取到该网段下的一个IP，并且会添加对应的路由规则，而客户端与目标机器产生的数据报文都要经过OpenVPN网关才能转发。&lt;/p>
&lt;p>tap是二层网络设备，收发以太网数据帧，拥有MAC层的功能，可以和物理网卡通过网桥相连，组成一个二层网络。例如OpenVPN的桥接模式可以从外部打一条隧道到本地网络。进来的机器就像本地的机器一样参与通讯，丝毫看不出这些机器是在远程。如果你有使用过虚拟机的经验，桥接模式也是一种十分常见的网络方案，虚拟机会分配到和宿主机器同网段的IP，其他同网段的机器也可以通过网络访问到这台虚拟机。&lt;/p>
&lt;h3 id="使用方式">使用方式&lt;/h3>
&lt;p>Linux 提供了一些命令行程序方便我们来创建持久化的tun/tap设备，但是如果没有应用程序打开对应的文件描述符，tun/tap的状态一直会是DOWN，还好的是这并不会影响我们把它当作普通网卡去使用。&lt;/p>
&lt;p>使用&lt;code>ip tuntap help&lt;/code>查看使用帮助&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Usage: ip tuntap &lt;span style="color:#f92672">{&lt;/span> add | del | show | list | lst | help &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">[&lt;/span> dev PHYS_DEV &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f92672">[&lt;/span> mode &lt;span style="color:#f92672">{&lt;/span> tun | tap &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> user USER &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> group GROUP &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#f92672">[&lt;/span> one_queue &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> pi &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> vnet_hdr &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> multi_queue &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span> name NAME &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Where:	USER :&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">{&lt;/span> STRING | NUMBER &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	GROUP :&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">{&lt;/span> STRING | NUMBER &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="示例">示例&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 tap &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tap0 mode tap 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建 tun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap add dev tun0 mode tun 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除 tap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap del dev tap0 mode tap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 删除 tun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip tuntap del dev tun0 mode tun 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tun/tap 设备创建成功后可以当作普通的网卡一样使用，因此我们也可以通过&lt;code>ip link&lt;/code>命令来操作它。&lt;/p></description></item></channel></rss>