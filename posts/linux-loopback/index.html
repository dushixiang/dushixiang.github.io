<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动nginx之后，在浏览器输入lcoalhost或者127.0.0.1就可以访问到本机上面的http服务。
Linux是如何访问本机IP的？
大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过TCP/IP与同一台主机上的其他服务进行通信，以127开头的IPv4地址就是为它保留的，主流Linux操作系统为环回网卡分配的地址都是127.0.0.1，主机名是localhost。
环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。
那环回网络接口是如何判断目的IP是否为本机地址的呢？
答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：
ip route show table local
输出内容如下：
broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 
local 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 
broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 
broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
其中local开头的便是本地IP，dev后面是网卡名称。"><title>Linux 环回网络接口</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css integrity="sha512-UWUjAtOpmL94h67Vws+JFBu+vfRaLI+HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2021-01-28 22:59:00 +0000 UTC">2021-01-28</time></p></div><article><h1>Linux 环回网络接口</h1><p>在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动<code>nginx</code>之后，在浏览器输入<code>lcoalhost</code>或者<code>127.0.0.1</code>就可以访问到本机上面的<code>http</code>服务。</p><h2 id=linux是如何访问本机ip的>Linux是如何访问本机IP的？</h2><p>大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过<code>TCP/IP</code>与同一台主机上的其他服务进行通信，以<code>127</code>开头的<code>IPv4</code>地址就是为它保留的，主流<code>Linux</code>操作系统为环回网卡分配的地址都是<code>127.0.0.1</code>，主机名是<code>localhost</code>。</p><p>环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。</p><p>那环回网络接口是如何判断目的IP是否为本机地址的呢？</p><p>答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ip route show table local
</span></span></code></pre></div><p>输出内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 
</span></span><span style=display:flex><span>local 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 
</span></span><span style=display:flex><span>broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 
</span></span><span style=display:flex><span>broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
</span></span><span style=display:flex><span>local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
</span></span><span style=display:flex><span>local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
</span></span></code></pre></div><p>其中<code>local</code>开头的便是本地IP，<code>dev</code>后面是网卡名称。</p><p>查完了本地路由表之后会再查主路由表，也就是我们经常操作的路由表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ip route show table main
</span></span></code></pre></div><p>输出内容如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>default via 10.141.128.1 dev eth0 proto static metric <span style=color:#ae81ff>100</span> 
</span></span><span style=display:flex><span>10.141.128.0/18 dev eth0 proto kernel scope link src 10.141.155.131 metric <span style=color:#ae81ff>100</span>
</span></span></code></pre></div><h2 id=环回网络接口>环回网络接口</h2><p>现在我们再来看下环回网络接口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ifconfig lo
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>lo: flags<span style=color:#f92672>=</span>73&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span style=color:#ae81ff>65536</span>
</span></span><span style=display:flex><span>        inet 127.0.0.1  netmask 255.0.0.0
</span></span><span style=display:flex><span>        inet6 ::1  prefixlen <span style=color:#ae81ff>128</span>  scopeid 0x10&lt;host&gt;
</span></span><span style=display:flex><span>        loop  txqueuelen <span style=color:#ae81ff>1000</span>  <span style=color:#f92672>(</span>Local Loopback<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        RX packets <span style=color:#ae81ff>1554227</span>  bytes <span style=color:#ae81ff>123327716</span> <span style=color:#f92672>(</span>117.6 MiB<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        RX errors <span style=color:#ae81ff>0</span>  dropped <span style=color:#ae81ff>0</span>  overruns <span style=color:#ae81ff>0</span>  frame <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        TX packets <span style=color:#ae81ff>1554227</span>  bytes <span style=color:#ae81ff>123327716</span> <span style=color:#f92672>(</span>117.6 MiB<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        TX errors <span style=color:#ae81ff>0</span>  dropped <span style=color:#ae81ff>0</span> overruns <span style=color:#ae81ff>0</span>  carrier <span style=color:#ae81ff>0</span>  collisions <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>可以看到本地环回接口的<code>IPv4</code>地址是<code>127.0.0.1</code>，子网掩码是<code>255.0.0.0</code>，对应A类网络号<code>127</code>，有趣的是当我们访问 <code>127.0.0.1-127.255.255.254</code>之间的任意一个地址都会访问到本机。</p><p><code>IPv6</code>地址<code>::1</code>，前缀是<code>128</code>位，表示只有一个地址。</p><p>环回网络接口的当前<code>MTU</code>是<code>64KB</code>，不过最高可以设置到<code>2GB</code>，真是恐怖如斯。</p><p>下面几条<code>RX</code>,<code>TX</code>开头的分别代表收发到的数据报文个数和大小以及错包、丢包、溢出次数和无效帧。</p><h2 id=faq>FAQ</h2><h4 id=虚拟网卡的ip属于本机ip吗>虚拟网卡的IP属于本机IP吗？</h4><p>属于，因为与宿主机器共用同一个网络协议栈。</p><h4 id=宿主机器上创建netnsnetns内部的ip属于本机ip吗>宿主机器上创建netns，netns内部的IP属于本机IP吗？</h4><p>不属于，因为netns拥有独立的网络协议栈，在netns内部也可以看到它本身的环回网络接口。</p></article></div></main></body></html>