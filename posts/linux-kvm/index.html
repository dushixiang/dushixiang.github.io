<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在Windows平台上我们习惯于使用VmWare或者virtual box来实现虚拟化，虽然它们拥有Linux版本，但大多数企业都选择了使用KVM来做Linux平台的虚拟化，因此学习掌握KVM是一项必不可少的技能。
安装KVM
以centos为例，下面是安装KVM虚拟化的命令。
yum install -y qemu-kvm libvirt virt-install bridge-utils
这么多软件都是什么作用？

  
      
          软件
          作用
      
  
  
      
          qemu-kvm
          整合了QEMU 和 KVM 的一个软件。
      
      
          libvirt
          封装了QEMU的接口，可以更加方便的操作虚拟机，并且提供了很多种编程语言的SDK。
      
      
          virt-install
          用来创建虚拟机的命令行工具。
      
      
          bridge-utils
          Linux网桥，用来配置虚拟机的桥接网络。
      
  

kvm、qemu、qemu-kvm和libvirt到底有什么关系？
KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它需要CPU的支持，采用硬件辅助虚拟化技术Intel-VT、AMD-V；内存相关如Intel的EPT和AMD的RVI技术，使得它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。
QEMU是一个纯软件实现的虚拟机，它可以模拟CPU、内存、磁盘等其他硬件，让虚拟机认为自己底层就是硬件，其实这些都是QEMU模拟的，虚拟机的所有操作都要经过QEMU转译一层，也就导致了QEMU本身的性能较差。
qemu-kvm是QEMU整合了KVM，把CPU虚拟化和内存虚拟化交给了KVM来做，自己来模拟IO设备，例如网卡和磁盘。这一套组合拳打下来，性能损失大大降低，相较于直接使用硬件，带来的损耗大概在1%-2%之间。
libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和API。Libvirtd是一个daemon进程，可以被本地的virsh调用，也可以被远程的virsh调用，Libvirtd调用qemu-kvm操作虚拟机。
启动libvirt
systemctl start libvirtd
systemctl enable libvirtd
如果你不想使用命令行工具来管理虚拟机，可以安装 virt-manager 。
yum install -y virt-manager
在支持x11转发的ssh客户端（例如：MobaXterm）上可以直接输入 virt-manager 来启动。
虚拟网络类型
和vmware类型，kvm也支持多种类型的网络，主要分为三种。


NAT模式 虚拟机需要把流量发送到宿主机，宿主机器转换网络信息后再发出，外部机器无法感知到虚拟机的存在。此种方式宿主机器相当于一个路由器，因此宿主机上会有一个和虚拟机同网段的IP，并且虚拟机的网关地址是宿主机的这个IP。


主机模式 虚拟机只能互相访问，不能访问宿主机。此种方式与NAT模式类似，但它没有与虚拟机同网段的IP，因此虚拟机也不能借助于宿主机来访问外部网络。


桥接模式 虚拟机和宿主机都关联在一个网桥上，因此虚拟机可以与宿主机在同一个网段，并且外部机器可以直接访问到虚拟机，虚拟机也可以借助网桥来访问外部网络。

还有一种模式在openstack等云平台上使用较为广泛，网桥上绑定的物理网卡没有IP，对应交换机配置端口为trunk模式，虚拟机 端口连接到网桥上，并配置端口不同的VLAN tag以达到隔离和互联的目的。


NAT模式和主机模式都无需单独配置，接下来我们看下如何配置桥接网络。
配置桥接网络
物理网卡绑定到网桥上之后就会导致网络断开，因此我们需要把原IP配置到网桥上。
# 进入网卡配置文件夹
cd /etc/sysconfig/network-scripts/
# 拷贝原网卡配置文件作为桥接网卡
cp ifcfg-enp134s0f0 ifcfg-br0
修改 ifcfg-br0 中的 TYPE=Ethernet  为  TYPE=Bridge，最终效果如下："><title>Linux虚拟化技术KVM</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.0568d3f70e9896300444ff10565468b82c2dace6b1b82bc72fba6ae51bfb0849887e0eb4ccb3cdb1c915fbe68c7000fbea631be9322fd5d0bcab56732ce7293f.css integrity="sha512-BWjT9w6YljAERP8QVlRouCwtrOaxuCvHL7pq5Rv7CEmIfg60zLPNsckV++aMcAD76mMb6TIv1dC8q1ZzLOcpPw=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2021-05-29 17:07:00 +0800 +0800">2021-05-29</time></p></div><article><h1>Linux虚拟化技术KVM</h1><p>在Windows平台上我们习惯于使用VmWare或者virtual box来实现虚拟化，虽然它们拥有Linux版本，但大多数企业都选择了使用KVM来做Linux平台的虚拟化，因此学习掌握KVM是一项必不可少的技能。</p><h3 id=安装kvm>安装KVM</h3><p>以centos为例，下面是安装KVM虚拟化的命令。</p><pre tabindex=0><code>yum install -y qemu-kvm libvirt virt-install bridge-utils
</code></pre><p><strong>这么多软件都是什么作用？</strong></p><table><thead><tr><th>软件</th><th>作用</th></tr></thead><tbody><tr><td>qemu-kvm</td><td>整合了QEMU 和 KVM 的一个软件。</td></tr><tr><td>libvirt</td><td>封装了QEMU的接口，可以更加方便的操作虚拟机，并且提供了很多种编程语言的SDK。</td></tr><tr><td>virt-install</td><td>用来创建虚拟机的命令行工具。</td></tr><tr><td>bridge-utils</td><td>Linux网桥，用来配置虚拟机的桥接网络。</td></tr></tbody></table><p><strong>kvm、qemu、qemu-kvm和libvirt到底有什么关系？</strong></p><p>KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它需要CPU的支持，采用硬件辅助虚拟化技术Intel-VT、AMD-V；内存相关如Intel的EPT和AMD的RVI技术，使得它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。</p><p>QEMU是一个纯软件实现的虚拟机，它可以模拟CPU、内存、磁盘等其他硬件，让虚拟机认为自己底层就是硬件，其实这些都是QEMU模拟的，虚拟机的所有操作都要经过QEMU转译一层，也就导致了QEMU本身的性能较差。</p><p>qemu-kvm是QEMU整合了KVM，把CPU虚拟化和内存虚拟化交给了KVM来做，自己来模拟IO设备，例如网卡和磁盘。这一套组合拳打下来，性能损失大大降低，相较于直接使用硬件，带来的损耗大概在1%-2%之间。</p><p>libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和API。Libvirtd是一个daemon进程，可以被本地的virsh调用，也可以被远程的virsh调用，Libvirtd调用qemu-kvm操作虚拟机。</p><p><strong>启动libvirt</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl start libvirtd
</span></span><span style=display:flex><span>systemctl <span style=color:#8be9fd;font-style:italic>enable</span> libvirtd
</span></span></code></pre></div><p>如果你不想使用命令行工具来管理虚拟机，可以安装 virt-manager 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>yum install -y virt-manager
</span></span></code></pre></div><p>在支持x11转发的ssh客户端（例如：<a href=https://mobaxterm.mobatek.net/>MobaXterm</a>）上可以直接输入 virt-manager 来启动。</p><h3 id=虚拟网络类型>虚拟网络类型</h3><p>和vmware类型，kvm也支持多种类型的网络，主要分为三种。</p><ol><li><p><strong>NAT模式</strong> 虚拟机需要把流量发送到宿主机，宿主机器转换网络信息后再发出，外部机器无法感知到虚拟机的存在。此种方式宿主机器相当于一个路由器，因此宿主机上会有一个和虚拟机同网段的IP，并且虚拟机的网关地址是宿主机的这个IP。</p></li><li><p><strong>主机模式</strong> 虚拟机只能互相访问，不能访问宿主机。此种方式与NAT模式类似，但它没有与虚拟机同网段的IP，因此虚拟机也不能借助于宿主机来访问外部网络。</p></li><li><p><strong>桥接模式</strong> 虚拟机和宿主机都关联在一个网桥上，因此虚拟机可以与宿主机在同一个网段，并且外部机器可以直接访问到虚拟机，虚拟机也可以借助网桥来访问外部网络。</p><blockquote><p>还有一种模式在openstack等云平台上使用较为广泛，网桥上绑定的物理网卡没有IP，对应交换机配置端口为trunk模式，虚拟机 端口连接到网桥上，并配置端口不同的VLAN tag以达到隔离和互联的目的。</p></blockquote></li></ol><p>NAT模式和主机模式都无需单独配置，接下来我们看下如何配置桥接网络。</p><h3 id=配置桥接网络>配置桥接网络</h3><p>物理网卡绑定到网桥上之后就会导致网络断开，因此我们需要把原IP配置到网桥上。</p><pre tabindex=0><code># 进入网卡配置文件夹
cd /etc/sysconfig/network-scripts/
# 拷贝原网卡配置文件作为桥接网卡
cp ifcfg-enp134s0f0 ifcfg-br0
</code></pre><p>修改 <code>ifcfg-br0</code> 中的 <code>TYPE=Ethernet</code> 为 <code>TYPE=Bridge</code>，最终效果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>DEVICE</span><span style=color:#ff79c6>=</span>br0
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>ONBOOT</span><span style=color:#ff79c6>=</span>yes
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>BOOTPROTO</span><span style=color:#ff79c6>=</span>none
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>TYPE</span><span style=color:#ff79c6>=</span>Bridge
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>IPADDR</span><span style=color:#ff79c6>=</span>172.16.0.52
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>PREFIX</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>16</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>GATEWAY</span><span style=color:#ff79c6>=</span>172.16.0.1
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>DNS1</span><span style=color:#ff79c6>=</span>114.114.114.114
</span></span></code></pre></div><p>修改<code>ifcfg-enp134s0f0</code> 文件删除其中的 <code>IPADDR=</code> <code>NETMASK=</code> <code>GATEWAY=</code> 行，并在最后添加上<code>BRIDGE=br0</code>，最终效果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>DEVICE</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;enp134s0f0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>ONBOOT</span><span style=color:#ff79c6>=</span>yes
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>BOOTPROTO</span><span style=color:#ff79c6>=</span>none
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>TYPE</span><span style=color:#ff79c6>=</span>Ethernet
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>BRIDGE</span><span style=color:#ff79c6>=</span>br0
</span></span></code></pre></div><p>最后重启网络。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl restart network
</span></span></code></pre></div><p>查看网络信息也可以看到IP配置到了网桥上，网桥上又关联了物理网卡。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff79c6>[</span>root@localhost network-scripts<span style=color:#ff79c6>]</span><span style=color:#6272a4># ip a</span>
</span></span><span style=display:flex><span>8: enp134s0f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#bd93f9>1500</span> qdisc mq master br0 state UP group default qlen <span style=color:#bd93f9>1000</span>
</span></span><span style=display:flex><span>    link/ether 74:a4:b5:01:04:22 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>    inet6 fe80::76a4:b5ff:fe01:422/64 scope link 
</span></span><span style=display:flex><span>       valid_lft forever preferred_lft forever
</span></span><span style=display:flex><span>17: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#bd93f9>1500</span> qdisc noqueue state UP group default qlen <span style=color:#bd93f9>1000</span>
</span></span><span style=display:flex><span>    link/ether 74:a4:b5:01:04:22 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>    inet 172.16.0.52/16 brd 172.16.255.255 scope global br0
</span></span><span style=display:flex><span>       valid_lft forever preferred_lft forever
</span></span><span style=display:flex><span>    inet6 fe80::76a4:b5ff:fe01:422/64 scope link 
</span></span><span style=display:flex><span>       valid_lft forever preferred_lft forever
</span></span><span style=display:flex><span><span style=color:#ff79c6>[</span>root@localhost network-scripts<span style=color:#ff79c6>]</span><span style=color:#6272a4># brctl show</span>
</span></span><span style=display:flex><span>bridge name     bridge id               STP enabled     interfaces
</span></span><span style=display:flex><span>br0             8000.74a4b5010422       no              enp134s0f0
</span></span></code></pre></div><h3 id=创建虚拟机>创建虚拟机</h3><p>创建虚拟机有三种选择</p><ol><li><strong>virt-install</strong> 使用命令创建虚拟机较为方便快捷，但对新手不友好，很多参数不知道如何设置。</li><li><strong>Libvirt</strong> 使用libvirt提供的api接口进行创建，此种方式开发虚拟化平台会用到。</li><li><strong>virt-manager</strong> 使用图形化界面创建虚拟机，此种方式较为简单，只要会用vmware，就会用virt-manager。</li></ol><p>因此我比较推荐使用<strong>virt-manager</strong>来创建虚拟机，过程很简单，我就不发截图了。</p><h3 id=管理虚拟机>管理虚拟机</h3><p>操作虚拟机的一些常用命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 列出正在运行的虚拟机</span>
</span></span><span style=display:flex><span>virsh list
</span></span><span style=display:flex><span><span style=color:#6272a4># 列出全部的虚拟机</span>
</span></span><span style=display:flex><span>virsh list --all
</span></span><span style=display:flex><span><span style=color:#6272a4># 启动虚拟机</span>
</span></span><span style=display:flex><span>virsh start <span style=color:#8be9fd;font-style:italic>test</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 关闭虚拟机</span>
</span></span><span style=display:flex><span>virsh shutdown <span style=color:#8be9fd;font-style:italic>test</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 强制停止虚拟机</span>
</span></span><span style=display:flex><span>virsh destroy <span style=color:#8be9fd;font-style:italic>test</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 彻底销毁虚拟机，会删除虚拟机配置文件，但不会删除虚拟磁盘</span>
</span></span><span style=display:flex><span>virsh undefine <span style=color:#8be9fd;font-style:italic>test</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 设置宿主机开机时该虚拟机也开机</span>
</span></span><span style=display:flex><span>virsh autostart <span style=color:#8be9fd;font-style:italic>test</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 解除开机启动</span>
</span></span><span style=display:flex><span>virsh autostart --disable <span style=color:#8be9fd;font-style:italic>test</span> 
</span></span><span style=display:flex><span><span style=color:#6272a4># 挂起虚拟机</span>
</span></span><span style=display:flex><span>virsh <span style=color:#8be9fd;font-style:italic>suspend</span> <span style=color:#8be9fd;font-style:italic>test</span> 
</span></span><span style=display:flex><span><span style=color:#6272a4># 恢复挂起的虚拟机</span>
</span></span><span style=display:flex><span>virsh resume <span style=color:#8be9fd;font-style:italic>test</span> 
</span></span><span style=display:flex><span><span style=color:#6272a4># 查看虚拟机的VNC端口，得到vnc端口之后可以使用vncviewer等工具访问虚拟机</span>
</span></span><span style=display:flex><span>virsh vncdisplay <span style=color:#8be9fd;font-style:italic>test</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 导出虚拟机xml配置文件</span>
</span></span><span style=display:flex><span>virsh dumpxml <span style=color:#8be9fd;font-style:italic>test</span> &gt;/root/test.xml
</span></span><span style=display:flex><span><span style=color:#6272a4># 修改虚拟机配置文件</span>
</span></span><span style=display:flex><span>virsh edit <span style=color:#8be9fd;font-style:italic>test</span>
</span></span></code></pre></div><h3 id=参考>参考</h3><p><a href=https://blog.51cto.com/changfei/1672147>https://blog.51cto.com/changfei/1672147</a></p></article></div></main></body></html>