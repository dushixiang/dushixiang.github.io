<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Linux veth pair 详解
veth pair是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。如下图所示：

由于它的这个特性，常常被用于构建虚拟网络拓扑。例如连接两个不同的网络命名空间(netns)，连接docker容器，连接网桥(Bridge)等，其中一个很常见的案例就是OpenStack Neutron底层用它来构建非常复杂的网络拓扑。
如何使用？
创建一对veth
ip link add <veth name> type veth peer name <peer name>
实验
我们改造上一节完成的netns实验，使用veth pair将两个的隔离netns连接起来。如下图所示：

我们首先创建一对veth设备，将veth设备分别移动到两个netns中并启动。
# 创建一对veth
ip link add veth0 type veth peer name veth1
# 将veth移动到netns中
ip link set veth0 netns ns0
ip link set veth1 netns ns1
# 启动
ip netns exec ns0 ip link set veth0 up
ip netns exec ns1 ip link set veth1 up
接下来我们测试一下。"><title>Linux veth pair 详解</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css integrity="sha512-UWUjAtOpmL94h67Vws+JFBu+vfRaLI+HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2020-11-09 22:45:00 +0000 UTC">2020-11-09</time></p></div><article><h1>Linux veth pair 详解</h1><h1 id=linux-veth-pair-详解>Linux veth pair 详解</h1><p>veth pair是成对出现的一种虚拟网络设备接口，一端连着网络协议栈，一端彼此相连。如下图所示：</p><p><img src=https://oss.typesafe.cn/virtual-device-veth-1.png alt=virtual-device-veth-1></p><p>由于它的这个特性，常常被用于构建虚拟网络拓扑。例如连接两个不同的网络命名空间(netns)，连接docker容器，连接网桥(Bridge)等，其中一个很常见的案例就是OpenStack Neutron底层用它来构建非常复杂的网络拓扑。</p><h2 id=如何使用>如何使用？</h2><p>创建一对veth</p><pre tabindex=0><code>ip link add &lt;veth name&gt; type veth peer name &lt;peer name&gt;
</code></pre><h2 id=实验>实验</h2><p>我们改造上一节完成的netns实验，使用veth pair将两个的隔离netns连接起来。如下图所示：</p><p><img src=https://oss.typesafe.cn/vethpair.png alt=https://oss.typesafe.cn/vethpair.png></p><p>我们首先创建一对veth设备，将veth设备分别移动到两个netns中并启动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 创建一对veth</span>
</span></span><span style=display:flex><span>ip link add veth0 type veth peer name veth1
</span></span><span style=display:flex><span><span style=color:#75715e># 将veth移动到netns中</span>
</span></span><span style=display:flex><span>ip link set veth0 netns ns0
</span></span><span style=display:flex><span>ip link set veth1 netns ns1
</span></span><span style=display:flex><span><span style=color:#75715e># 启动</span>
</span></span><span style=display:flex><span>ip netns exec ns0 ip link set veth0 up
</span></span><span style=display:flex><span>ip netns exec ns1 ip link set veth1 up
</span></span></code></pre></div><p>接下来我们测试一下。</p><p>使用<code>ip netns exec ns0 ping 10.0.0.2</code>在命名空间ns0中测试与tap1的网络连通性。</p><pre tabindex=0><code>PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
From 10.0.0.1 icmp_seq=1 Destination Host Unreachable
From 10.0.0.1 icmp_seq=2 Destination Host Unreachable
From 10.0.0.1 icmp_seq=3 Destination Host Unreachable
^C
--- 10.0.0.2 ping statistics ---
5 packets transmitted, 0 received, +3 errors, 100% packet loss, time 77ms
pipe 4
</code></pre><p>使用<code>ip netns exec ns1 ping 10.0.0.1</code>在命名空间ns1中测试与tap0的网络连通性。</p><pre tabindex=0><code>PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
From 10.0.0.2 icmp_seq=1 Destination Host Unreachable
From 10.0.0.2 icmp_seq=2 Destination Host Unreachable
From 10.0.0.2 icmp_seq=3 Destination Host Unreachable
^C
--- 10.0.0.1 ping statistics ---
4 packets transmitted, 0 received, +3 errors, 100% packet loss, time 108ms
pipe 4
</code></pre><p>什么情况？为什么网络还是不通呢？答案就是路由配置有问题。</p><p>使用<code>ip netns exec ns0 route -n</code>查看ns0的路由表。</p><pre tabindex=0><code>Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 tap0
</code></pre><p>使用<code>ip netns exec ns1 route -n</code>查看ns1的路由表。</p><pre tabindex=0><code>Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 tap1
</code></pre><p>原来访问10.0.0.0/24的流量都从tap设备发出去了，又因为tap设备没有和其他设备相连，发出去的数据报文不会被处理，因此还是访问不到目标IP，我们来修改一下路由，让访问10.0.0.0/24的流量从veth设备发出。</p><pre tabindex=0><code>#修改路由出口为veth
ip netns exec ns0 ip route change 10.0.0.0/24 via 0.0.0.0 dev veth0
ip netns exec ns1 ip route change 10.0.0.0/24 via 0.0.0.0 dev veth1
</code></pre><p>我们再来看一下路由</p><p>使用<code>ip netns exec ns0 route -n</code>查看ns0的路由表。</p><pre tabindex=0><code>Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 veth0
</code></pre><p>使用<code>ip netns exec ns1 route -n</code>查看ns1的路由表。</p><pre tabindex=0><code>Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 veth1
</code></pre><p>最后我们再来测试一下。</p><p>使用<code>ip netns exec ns0 ping 10.0.0.2</code>在命名空间ns0中测试与tap1的网络连通性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PING 10.0.0.2 <span style=color:#f92672>(</span>10.0.0.2<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.031 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.035 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.037 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.2: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.043 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 10.0.0.2 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> packets transmitted, <span style=color:#ae81ff>4</span> received, 0% packet loss, time 103ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.031/0.036/0.043/0.007 ms
</span></span></code></pre></div><p>使用<code>ip netns exec ns1 ping 10.0.0.1</code>在命名空间ns1中测试与tap0的网络连通性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PING 10.0.0.1 <span style=color:#f92672>(</span>10.0.0.1<span style=color:#f92672>)</span> 56<span style=color:#f92672>(</span>84<span style=color:#f92672>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.027 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.047 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.051 ms
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span> bytes from 10.0.0.1: icmp_seq<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> ttl<span style=color:#f92672>=</span><span style=color:#ae81ff>64</span> time<span style=color:#f92672>=</span>0.042 ms
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>--- 10.0.0.1 ping statistics ---
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> packets transmitted, <span style=color:#ae81ff>4</span> received, 0% packet loss, time 66ms
</span></span><span style=display:flex><span>rtt min/avg/max/mdev <span style=color:#f92672>=</span> 0.027/0.041/0.051/0.012 ms
</span></span></code></pre></div><p>可以看到我们使用veth pair将两个隔离的netns成功的连接到了一起。</p><p>但是这样的网络拓扑存在一个弊端，随着网络设备的增多，网络连线的复杂度将成倍增长。
如果连接三个netns时，网络连线就成了下图的样子</p><p><img src=https://oss.typesafe.cn/veth-pair1.png alt=veth1></p><p>而如果连接四个netns时，网络连线就成了下图的样子</p><p><img src=https://oss.typesafe.cn/veth-pair2.png alt=veth2></p><p>如果有五台设备。。。</p><p>有没有什么技术可以解决这个问题呢？答案是有的，Linux Bridge（网桥）。下一节我们将使用网桥来将多个隔离的netns连接起来，这样网络连线就非常清爽了。</p></article></div></main></body></html>