<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="什么是VXLAN？
VXLAN是一种隧道封装协议，在三层网络上封装二层网络数据报文。简单来说就是可以在已经规划好网络拓扑的设备上封装出一个新的二层网络，因此VXLAN这类网络又被称之为overylay网络，底下承载VXLAN网络的就被称之为underlay网络。
VXLAN解决了什么问题？
最近几年，阿里云，腾讯云，京东云，华为云等等厂商每到节日都会打折出售大量云服务器，1核1G内存50G磁盘的服务器几十块就能买到一年的使用权，作为一个专业的羊毛党，哪个手里没有几台小破水管机器？但是这么多的云服务器是厂商如何做隔离的呢？了解过网络的同学或许会说VLAN。但是VLAN这种只能隔离4094个虚拟网络的技术别说满足不了羊毛党了，就连正常的用户估计都撑不住。那不隔离能行吗，厂商规划一个特别大的网段，让大家都在这里面耍，正常用户还好，万一这个时候进来一个大黑客，估计就会全部GG。
因此，隔离是必不可少的，其中关键的技术就是overlay网络。
那VXLAN具体解决了哪些问题呢？

突破了VLAN技术4094个隔离网络的限制，在一个管理域中创建多达1600万个VXLAN网络。
VXLAN提供了云服务厂商所需的规模的网络分段，以支持大量租户。
突破了物理网络边界的限制，传统虚拟二层网络（VLAN）是需要和物理网络做大量适配工作才能保证环境的迁移不会导致虚拟网络异常，overlay网络则不必关心底层物理网络是如何搭建的，只要能保证VXLAN端点相互之间可以联通即可。

VXLAN网络如何工作？
VXLAN隧道协议将二层以太网帧封装在三层UDP数据包中，使用户能够创建跨物理三层网络的虚拟化二层子网或网段。每个二层子网使用VXLAN网络标识符（VNI）作为唯一标识。报文格式如下图：

执行数据包封装和解封装的实体称为VXLAN隧道终结点（VTEP）。VTEP主要分为两类：硬件VTEP和软件VTEP。硬件VTEP我接触较少，这里就不再介绍了。
软件VTEP如下图所示：VTEP在数据包到达虚拟机之前进行了封装和解封装，使得虚拟机完全不需要知道VXLAN隧道以及它们之间的三层网络。

简单VXLAN实验
我们参照下图完成实验。

主机A
# 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.232 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.1/24 dev vnet0
主机B
# 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.231 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.2/24 dev vnet0
测试
在主机A上测试网络连通性 ip netns exec ns0 ping 192.168.0.2"><title>Open vSwitch 入门实践（6）VXLAN实验</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.0568d3f70e9896300444ff10565468b82c2dace6b1b82bc72fba6ae51bfb0849887e0eb4ccb3cdb1c915fbe68c7000fbea631be9322fd5d0bcab56732ce7293f.css integrity="sha512-BWjT9w6YljAERP8QVlRouCwtrOaxuCvHL7pq5Rv7CEmIfg60zLPNsckV++aMcAD76mMb6TIv1dC8q1ZzLOcpPw=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2020-12-30 19:14:00 +0000 UTC">2020-12-30</time></p></div><article><h1>Open vSwitch 入门实践（6）VXLAN实验</h1><h1 id=什么是vxlan>什么是VXLAN？</h1><p>VXLAN是一种隧道封装协议，在三层网络上封装二层网络数据报文。简单来说就是可以在已经规划好网络拓扑的设备上封装出一个新的二层网络，因此VXLAN这类网络又被称之为overylay网络，底下承载VXLAN网络的就被称之为underlay网络。</p><h1 id=vxlan解决了什么问题>VXLAN解决了什么问题？</h1><p>最近几年，阿里云，腾讯云，京东云，华为云等等厂商每到节日都会打折出售大量云服务器，1核1G内存50G磁盘的服务器几十块就能买到一年的使用权，作为一个专业的羊毛党，哪个手里没有几台小破水管机器？但是这么多的云服务器是厂商如何做隔离的呢？了解过网络的同学或许会说VLAN。但是VLAN这种只能隔离4094个虚拟网络的技术别说满足不了羊毛党了，就连正常的用户估计都撑不住。那不隔离能行吗，厂商规划一个特别大的网段，让大家都在这里面耍，正常用户还好，万一这个时候进来一个大黑客，估计就会全部GG。</p><p>因此，隔离是必不可少的，其中关键的技术就是overlay网络。</p><p>那VXLAN具体解决了哪些问题呢？</p><ul><li>突破了VLAN技术4094个隔离网络的限制，在一个管理域中创建多达1600万个VXLAN网络。</li><li>VXLAN提供了云服务厂商所需的规模的网络分段，以支持大量租户。</li><li>突破了物理网络边界的限制，传统虚拟二层网络（VLAN）是需要和物理网络做大量适配工作才能保证环境的迁移不会导致虚拟网络异常，overlay网络则不必关心底层物理网络是如何搭建的，只要能保证VXLAN端点相互之间可以联通即可。</li></ul><h1 id=vxlan网络如何工作>VXLAN网络如何工作？</h1><p>VXLAN隧道协议将二层以太网帧封装在三层UDP数据包中，使用户能够创建跨物理三层网络的虚拟化二层子网或网段。每个二层子网使用VXLAN网络标识符（VNI）作为唯一标识。报文格式如下图：</p><p><img src=https://oss.typesafe.cn/vxlan_packet_header.png alt=VXLAN报文格式></p><p>执行数据包封装和解封装的实体称为VXLAN隧道终结点（VTEP）。VTEP主要分为两类：硬件VTEP和软件VTEP。硬件VTEP我接触较少，这里就不再介绍了。</p><p>软件VTEP如下图所示：VTEP在数据包到达虚拟机之前进行了封装和解封装，使得虚拟机完全不需要知道VXLAN隧道以及它们之间的三层网络。</p><p><img src=https://oss.typesafe.cn/vxlan01.png alt=vxlan网络></p><h1 id=简单vxlan实验>简单VXLAN实验</h1><p>我们参照下图完成实验。</p><p><img src=https://oss.typesafe.cn/vxlan_topo.png alt=VXLAN实验></p><h3 id=主机a>主机A</h3><pre tabindex=0><code># 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.232 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.1/24 dev vnet0
</code></pre><h3 id=主机b>主机B</h3><pre tabindex=0><code># 创建隧道网桥
ovs-vsctl add-br br-tun
# 创建隧道端口并指定远端IP和VXLAN ID
ovs-vsctl add-port br-tun vx01 -- set Interface vx01 type=vxlan options:remote_ip=192.168.123.231 options:key=1111
# 创建内部端口
ovs-vsctl add-port br-tun vnet0 -- set Interface vnet0 type=internal
# 创建netns用于模拟虚拟网络设备
ip netns add ns0
# 将内部端口移动到netns中
ip link set vnet0 netns ns0
# 启动网卡
ip netns exec ns0 ip link set lo up
ip netns exec ns0 ip link set vnet0 up
# 配置IP
ip netns exec ns0 ip addr add 192.168.0.2/24 dev vnet0
</code></pre><h2 id=测试>测试</h2><p>在<code>主机A</code>上测试网络连通性 <code>ip netns exec ns0 ping 192.168.0.2</code></p><pre tabindex=0><code>PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.
64 bytes from 192.168.0.2: icmp_seq=1 ttl=64 time=0.715 ms
64 bytes from 192.168.0.2: icmp_seq=2 ttl=64 time=0.372 ms
64 bytes from 192.168.0.2: icmp_seq=3 ttl=64 time=0.205 ms
64 bytes from 192.168.0.2: icmp_seq=4 ttl=64 time=0.230 ms
^C
--- 192.168.0.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 111ms
rtt min/avg/max/mdev = 0.205/0.380/0.715/0.204 ms
</code></pre><p>可以看到我们只使用一张网卡就成功的在已有的物理网络上建立了一个新的分布式二层网络。</p><blockquote><p>在这个实验中我使用了固定的VXLAN ID 1111，只是为了简化实验，无其他含义。</p></blockquote><p>当我们此时在主机B上对物理网卡<code>eth0</code>使用<code>tcpdump</code>抓包时。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpdump -l -n -vv -i eth0 <span style=color:#f1fa8c>&#39;port 4789 and udp[8:2] = 0x0800 &amp; 0x0800 and udp[11:4] = 1111 &amp; 0x00FFFFFF&#39;</span>
</span></span></code></pre></div><p>可以看到类似我下面截取的数据包。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>09:09:59.080604 IP <span style=color:#ff79c6>(</span>tos 0x0, ttl 64, id 12981, offset 0, flags <span style=color:#ff79c6>[</span>DF<span style=color:#ff79c6>]</span>, proto UDP <span style=color:#ff79c6>(</span>17<span style=color:#ff79c6>)</span>, length 134<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    192.168.123.231.59648 &gt; 192.168.123.232.vxlan: <span style=color:#ff79c6>[</span>no cksum<span style=color:#ff79c6>]</span> VXLAN, flags <span style=color:#ff79c6>[</span>I<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>(</span>0x08<span style=color:#ff79c6>)</span>, vni <span style=color:#bd93f9>1111</span>
</span></span><span style=display:flex><span>IP <span style=color:#ff79c6>(</span>tos 0x0, ttl 64, id 29815, offset 0, flags <span style=color:#ff79c6>[</span>DF<span style=color:#ff79c6>]</span>, proto ICMP <span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>)</span>, length 84<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>    192.168.0.1 &gt; 192.168.0.2: ICMP <span style=color:#8be9fd;font-style:italic>echo</span> request, id 1928, seq 1, length <span style=color:#bd93f9>64</span>
</span></span></code></pre></div><p>这是一条完整的数据报文，只是格式化成了4行。</p><p>前两行是<code>underlay</code>网络的报文，也就是底层承载网络。分别是：</p><ul><li>底层协议 <code>proto UDP (17)</code></li><li>包长度 <code>length 134</code></li><li>源和目的地址 <code>192.168.123.231.59648 > 192.168.123.232.vxlan</code></li><li>VXLAN ID：<code>vni 1111</code></li></ul><p>后两行是<code>overlay</code>网络的报文，也就是我们的虚拟网络。分别是：</p><ul><li>承载的协议是 <code>proto ICMP (1)</code></li><li>包长度 <code>length 84</code></li><li>源和目的地址 <code>192.168.0.1 > 192.168.0.2</code></li></ul><p>可以看出这些信息和我们的实验环境非常匹配，只有包大小不太一致，这是因为<code>underlay</code>网络的基础信息刚好占有了50个字节，不信你可以加一下上面的报文格式中的数字。</p><p>最后也不要忘记清理实验环境。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># 在主机A和B上都需要执行</span>
</span></span><span style=display:flex><span>ovs-vsctl del-br br-tun
</span></span><span style=display:flex><span>ip netns del ns0
</span></span></code></pre></div></article></div></main></body></html>