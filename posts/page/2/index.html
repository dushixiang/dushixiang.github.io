<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | 整点Bug</title><meta name=keywords content><meta name=description content="Posts - 整点Bug"><meta name=author content="dushixiang"><link rel=canonical href=https://www.typesafe.cn/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://www.typesafe.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.typesafe.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.typesafe.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://www.typesafe.cn/apple-touch-icon.png><link rel=mask-icon href=https://www.typesafe.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://www.typesafe.cn/posts/index.xml><link rel=alternate hreflang=zh href=https://www.typesafe.cn/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.typesafe.cn/posts/"><meta property="og:site_name" content="整点Bug"><meta property="og:title" content="Posts"><meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://www.typesafe.cn/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.typesafe.cn/papermod-cover.png"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.typesafe.cn/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.typesafe.cn/ accesskey=h title="整点Bug (Alt + H)">整点Bug</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.typesafe.cn/archives title=文章><span>文章</span></a></li><li><a href=https://www.typesafe.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://www.typesafe.cn/search/ title=搜索><span>搜索</span></a></li><li><a href=https://www.typesafe.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://www.typesafe.cn/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://www.typesafe.cn/>主页</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Java 反序列化漏洞原理（一）Serializable</h2></header><div class=entry-content><p>声明 本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
序列化的定义 序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。
Java 中的序列化 Java 自身提供了序列化的功能，需要实现 java.io.Serializable 接口，标明该对象是可序列化的。 java.io.Serializable 是一个空接口，不需要对象实现方法。
以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。
import java.io.*; import java.nio.charset.StandardCharsets; import java.util.Base64; public class Eval0 { public static class Command implements Serializable { private String cmd; public String getCmd() { return cmd; } public void setCmd(String cmd) { this.cmd = cmd; } } public static void main(String[] args) throws Exception { // 定义一个对象 Command command = new Command(); command.setCmd("calc"); System.out.println("序列化前: " + command.getCmd()); // 将用户序列化为字节数组 ByteArrayOutputStream buffer = new ByteArrayOutputStream(); try (ObjectOutputStream outputStream = new ObjectOutputStream(buffer)) { outputStream.writeObject(command); } // 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化 final String data = Base64.getEncoder().encodeToString(buffer.toByteArray()); System.out.println("序列化后: " + data); // 将base64编码的数据再解码为字节数组 final byte[] bytes = Base64.getDecoder().decode(data.getBytes(StandardCharsets.UTF_8)); // 将字节数组反序列化为对象 ByteArrayInputStream b = new ByteArrayInputStream(bytes); try (ObjectInputStream input = new ObjectInputStream(b)) { final Command obj = (Command) input.readObject(); System.out.println("反序列化: " + obj.getCmd()); } } } 运行后输出：
...</p></div><footer class=entry-footer><span title='2021-10-14 23:00:00 +0800 +0800'>十月 14, 2021</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to Java 反序列化漏洞原理（一）Serializable" href=https://www.typesafe.cn/posts/java-serialization-vulnerability-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>分享一款非常好用的kafka可视化web管理工具</h2></header><div class=entry-content><p>使用过kafka的小伙伴应该都知道kafka本身是没有管理界面的，所有操作都需要手动执行命令来完成。但有些命令又多又长，如果没有做笔记，别说是新手，就连老手也不一定能记得住，每次想要使用的时候都要上网搜索一下。有些崇尚geek精神的人或许觉得命令行才是真爱，但使用一款好用的可视化管理工具真的可以极大的提升效率。
今天给大家介绍的这款工具叫做kafka-map，是我针对日常工作中高频使用的场景开发的，使用了这款工具之后就不必费心费力的去查资料某个命令要怎么写，就像是：“给编程插上翅膀，给kafka装上导航”。
kafka-map 介绍 kafka map是使用Java11和React开发的一款kafka可视化工具。
目前支持的功能有：
多集群管理 集群状态监控（分区数量、副本数量、存储大小、offset） 主题创建、删除、扩容（删除需配置delete.topic.enable = true） broker状态监控 消费者组查看、删除 重置offset 消息查询（支持String和json方式展示） 发送消息（支持向指定的topic和partition发送字符串消息） 功能截图 添加集群 集群管理 broker 主题管理 消费组 查看消费组已订阅主题 topic详情——分区 topic详情——broker topic详情——消费组 topic详情——消费组重置offset topic详情——配置信息 生产消息 消费消息 docker 方式安装 一行命令即可完成安装
docker run -d \ -p 8080:8080 \ -v /opt/kafka-map/data:/usr/local/kafka-map/data \ -e DEFAULT_USERNAME=admin -e DEFAULT_PASSWORD=admin --name kafka-map \ --restart always dushixiang/kafka-map:latest 更多安装方式以及相信信息可查看: https://github.com/dushixiang/kafka-map
...</p></div><footer class=entry-footer><span title='2021-06-13 00:00:00 +0800 +0800'>六月 13, 2021</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to 分享一款非常好用的kafka可视化web管理工具" href=https://www.typesafe.cn/posts/share-a-kafka-web-manager/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>openstack victoria版安装</h2></header><div class=entry-content><p>近期公司业务需求，需要安装一套Openstack环境学习，看了一下现在已经出了wallaby版了，我果断选择了上一个版本victoria。因为没有足够多的物理服务器了，只好找了一台64核256G内存6T硬盘的机器来创建几台虚拟机来搭环境了。
实验环境 此次实验使用到了三台虚拟机，都是使用centos8系统，一台机器当作控制和网络节点，另外两台当作计算节点，使用OVS+VLAN的网络模式，eth0作为管理网络，eth1互相连接到OVS网桥上模拟trunk网卡，controller多增加一个eth2用于访问外部网络。
节点 作用 eth0 eth1 eth2 controller 控制节点、网络节点 172.16.10.100 无IP 桥接，无IP compute-101 计算节点 172.16.10.101 无IP ❌ compute-102 计算节点 172.16.10.102 无IP ❌ 安装虚拟机 安装依赖 安装KVM和Linux网桥
yum install -y qemu-kvm libvirt virt-install bridge-utils virt-manager dejavu-lgc-sans-fonts dejavu-lgc-sans-fonts用于解决 virt-manaer 乱码
启动
systemctl enable libvirtd && systemctl start libvirtd 安装OVS
yum install openvswitch 启动OVS
systemctl enable openvswitch && systemctl start openvswitch 创建虚拟机 使用 virt-manager 创建三台虚拟机
配置网络 配置管理网卡 给虚拟机配置桥接网络，参考Linux虚拟化技术KVM，效果如图
配置trunk网卡 使用ovs创建一个虚拟网桥。
ovs-vsctl add-br br-vlan 此时网桥br-vlan上是没有任何虚拟网卡的，然后关闭虚拟机，在virt-manager上添加一个网络设备
...</p></div><footer class=entry-footer><span title='2021-06-12 00:00:00 +0800 +0800'>六月 12, 2021</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to openstack victoria版安装" href=https://www.typesafe.cn/posts/install-openstack-victoria/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KVM 虚拟机磁盘扩容</h2></header><div class=entry-content><p>一、镜像扩容 注意：需要先关闭虚拟机才能操作，+号前面有空格，后面没有空格。
qemu-img resize test.qcow2 +80G 原镜像磁盘大小20GB，扩容完成后可使用以下命令查看
qemu-img info test.qcow2 输出
image: test.qcow2 file format: qcow2 virtual size: 100G (107374182400 bytes) disk size: 885M cluster_size: 65536 Format specific information: compat: 1.1 lazy refcounts: false refcount bits: 16 corrupt: false 二、Windows磁盘扩容 Windows磁盘扩容比较方便，进入 计算机管理>磁盘管理 找到新增的分区把它添加到需要的分区即可。
三、Linux磁盘扩容 启动虚拟机后，进入虚拟机控制台，使用fdisk -l命令查看磁盘信息。
Disk /dev/vda: 100 GiB, 107374182400 bytes, 209715200 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0xe11f7f01 Device Boot Start End Sectors Size Id Type /dev/vda1 * 2048 2099199 2097152 1G 83 Linux /dev/vda2 2099200 41943039 39843840 19G 8e Linux LVM Disk /dev/mapper/cl-root: 17 GiB, 18249416704 bytes, 35643392 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/mapper/cl-swap: 2 GiB, 2147483648 bytes, 4194304 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 可以看到这台虚拟机的磁盘大小已经有100GB了，但分区大小还是没有变化，只有初始大小20GB。
...</p></div><footer class=entry-footer><span title='2021-05-31 19:20:00 +0800 +0800'>五月 31, 2021</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to KVM 虚拟机磁盘扩容" href=https://www.typesafe.cn/posts/kvm-disk-resize/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux虚拟化技术KVM</h2></header><div class=entry-content><p>在Windows平台上我们习惯于使用VmWare或者virtual box来实现虚拟化，虽然它们拥有Linux版本，但大多数企业都选择了使用KVM来做Linux平台的虚拟化，因此学习掌握KVM是一项必不可少的技能。
安装KVM 以centos为例，下面是安装KVM虚拟化的命令。
yum install -y qemu-kvm libvirt virt-install bridge-utils 这么多软件都是什么作用？
软件 作用 qemu-kvm 整合了QEMU 和 KVM 的一个软件。 libvirt 封装了QEMU的接口，可以更加方便的操作虚拟机，并且提供了很多种编程语言的SDK。 virt-install 用来创建虚拟机的命令行工具。 bridge-utils Linux网桥，用来配置虚拟机的桥接网络。 kvm、qemu、qemu-kvm和libvirt到底有什么关系？
KVM（Kernel Virtual Machine）是Linux的一个内核驱动模块，它需要CPU的支持，采用硬件辅助虚拟化技术Intel-VT、AMD-V；内存相关如Intel的EPT和AMD的RVI技术，使得它能够让Linux主机成为一个Hypervisor（虚拟机监控器）。
QEMU是一个纯软件实现的虚拟机，它可以模拟CPU、内存、磁盘等其他硬件，让虚拟机认为自己底层就是硬件，其实这些都是QEMU模拟的，虚拟机的所有操作都要经过QEMU转译一层，也就导致了QEMU本身的性能较差。
qemu-kvm是QEMU整合了KVM，把CPU虚拟化和内存虚拟化交给了KVM来做，自己来模拟IO设备，例如网卡和磁盘。这一套组合拳打下来，性能损失大大降低，相较于直接使用硬件，带来的损耗大概在1%-2%之间。
libvirt是目前使用最为广泛的对KVM虚拟机进行管理的工具和API。Libvirtd是一个daemon进程，可以被本地的virsh调用，也可以被远程的virsh调用，Libvirtd调用qemu-kvm操作虚拟机。
启动libvirt
systemctl start libvirtd systemctl enable libvirtd 如果你不想使用命令行工具来管理虚拟机，可以安装 virt-manager 。
yum install -y virt-manager 在支持x11转发的ssh客户端（例如：MobaXterm）上可以直接输入 virt-manager 来启动。
虚拟网络类型 和vmware类型，kvm也支持多种类型的网络，主要分为三种。
NAT模式 虚拟机需要把流量发送到宿主机，宿主机器转换网络信息后再发出，外部机器无法感知到虚拟机的存在。此种方式宿主机器相当于一个路由器，因此宿主机上会有一个和虚拟机同网段的IP，并且虚拟机的网关地址是宿主机的这个IP。
主机模式 虚拟机只能互相访问，不能访问宿主机。此种方式与NAT模式类似，但它没有与虚拟机同网段的IP，因此虚拟机也不能借助于宿主机来访问外部网络。
桥接模式 虚拟机和宿主机都关联在一个网桥上，因此虚拟机可以与宿主机在同一个网段，并且外部机器可以直接访问到虚拟机，虚拟机也可以借助网桥来访问外部网络。
还有一种模式在openstack等云平台上使用较为广泛，网桥上绑定的物理网卡没有IP，对应交换机配置端口为trunk模式，虚拟机 端口连接到网桥上，并配置端口不同的VLAN tag以达到隔离和互联的目的。
NAT模式和主机模式都无需单独配置，接下来我们看下如何配置桥接网络。
配置桥接网络 物理网卡绑定到网桥上之后就会导致网络断开，因此我们需要把原IP配置到网桥上。
# 进入网卡配置文件夹 cd /etc/sysconfig/network-scripts/ # 拷贝原网卡配置文件作为桥接网卡 cp ifcfg-enp134s0f0 ifcfg-br0 修改 ifcfg-br0 中的 TYPE=Ethernet 为 TYPE=Bridge，最终效果如下：
...</p></div><footer class=entry-footer><span title='2021-05-29 17:07:00 +0800 +0800'>五月 29, 2021</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to Linux虚拟化技术KVM" href=https://www.typesafe.cn/posts/linux-kvm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>容器网络——如何为docker添加网卡？</h2></header><div class=entry-content><p>之前我们介绍Network Namespace（以下简称netns）和veth pair时说过docker是使用这些技术来实现的网络隔离，今天我们就来一探究竟，看下docker到底是如何做到的。
启动一个无网络的容器 首先我们使用 --net=none 参数启动一个无网络的容器，为了方便调试，这里我们使用了centos镜像。
docker run -itd --name centos-test --net=none centos 启动成功之后我们进入容器内部确认一下是否无网卡。
[root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 28dc2e8853df centos "/bin/bash" 24 seconds ago Up 23 seconds centos-test [root@localhost ~]# docker exec -it 28dc2e8853df bash [root@28dc2e8853df /]# ip a 1: lo: &lt;LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 可以看到确实只有一个本地环回网卡。
...</p></div><footer class=entry-footer><span title='2021-05-23 13:37:00 +0800 +0800'>五月 23, 2021</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to 容器网络——如何为docker添加网卡？" href=https://www.typesafe.cn/posts/how-to-add-port-for-docker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用libvirt-java采集KVM虚拟机状态信息</h2></header><div class=entry-content><p>虚拟化开发相较于普通开发是一个冷门的方向，大多数是使用Python开发，其中使用Java来做虚拟化的少之又少，资料更是少的可怜，为了实现需求我也是踩了不少坑，今天就为大家分享一下如何使用 libvirt-java 来采集KVM虚拟机的资源使用信息。
CPU使用率 libvirt并没有直接提供获取虚拟机CPU使用率的接口，需要我们自己来计算，网上分享的代码或者公式五花八门，大部分都是错误的，经过我的测试，找到了一个相对准确的计算公式。
cpu_usage = (cpu_time_now - cpu_time_t_second_ago) * 100 / (t * vCpus * 10^9) Java代码如下
// t秒前的CPU时间 long c1 = domain.getInfo().cpuTime; Thread.sleep(1000); // 当前CPU时间 long c2 = domain.getInfo().cpuTime; // 虚拟CPU数量 int vCpus = domain.getMaxVcpus(); // t 为1秒 Double cpuUsage = 100 * (c2 - c1) / (1 * vCpus * Math.pow(10, 9)); log.debug("虚拟机[{}]CPU使用率为: {}", uuid, cpuUsage); 内存使用率 不要使用domain.getInfo()返回的 memory字段，虽然它注释写的是the memory in KBytes used by the domain，但它的意思真的不是虚拟机内部进程已使用的内存大小，而是从宿主机器的角度来看分配给这个虚拟机的内存它使用了多少，如果没有特殊配置，它会和maxMem字段的值是相同的。
正确做法是使用domain.memoryStats(10)来获取，那为什么参数要输入一个10呢？这是因为10代表的是要返回的信息数量，经过我手动执行virsh dommemstat uuid 测试发现有10个参数返回，所以需要填入10。另外命令返回的unused 字段值与数组中tag=8的数据一致，最终我们获取到了未使用的内存大小，计算内存使用率更是轻轻松松。
Java代码如下
MemoryStatistic[] memoryStatistics = domain.memoryStats(10); Optional&lt;MemoryStatistic> first = Arrays.stream(memoryStatistics).filter(x -> x.getTag() == 8).findFirst(); if (first.isPresent()) { MemoryStatistic memoryStatistic = first.get(); long unusedMemory = memoryStatistic.getValue(); long maxMemory = domain.getMaxMemory(); double memoryUsage = (maxMemory - unusedMemory) * 100.0 / maxMemory; log.debug("虚拟机[{}]内存使用率为: {}", uuid, memoryUsage); } 网卡数据包信息 同样libvirt并没有提供获取虚拟机网卡的接口，因此需要获取虚拟机的xml文件来查询。
...</p></div><footer class=entry-footer><span title='2021-05-19 20:18:20 +0800 +0800'>五月 19, 2021</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to 使用libvirt-java采集KVM虚拟机状态信息" href=https://www.typesafe.cn/posts/collect-vm-stats-by-libvirt-java/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基于kafka实现延迟队列</h2></header><div class=entry-content><p>基于kafka实现延迟队列 kafka作为一个使用广泛的消息队列，很多人都不会陌生，但当你在网上搜索“kafka 延迟队列”，出现的都是一些讲解时间轮或者只是提供了一些思路，并没有一份真实可用的代码实现，今天我们就来打破这个现象，提供一份可运行的代码，抛砖引玉，吸引更多的大神来分享。
基于kafka如何实现延迟队列？ 想要解决一个问题，我们需要先分解问题。kafka作为一个高性能的消息队列，只要消费能力足够，发出的消息都是会立刻收到的，因此我们需要想一个办法，让消息延迟发送出去。
网上已经有大神给出了如下方案：
在发送延迟消息时不直接发送到目标topic，而是发送到一个用于处理延迟消息的topic，例如delay-minutes-1 写一段代码拉取delay-minutes-1中的消息，将满足条件的消息发送到真正的目标主题里。 就像画一匹马一样简单。
方案是好的，但是我们还需要更多细节。
完善细节 问题出在哪里？
问题出在延迟消息发出去之后，代码程序就会立刻收到延迟消息，要如何处理才能让延迟消息等待一段时间才发送到真正的topic里面。
可能有同学会觉得很简单嘛，在代码程序收到消息之后判断条件不满足，就调用sleep方法，过了一段时间我再进行下一个循环拉取消息。
真的可行吗?
一切好像都很美好，但这是不可行的。
这是因为在轮询kafka拉取消息的时候，它会返回由max.poll.records配置指定的一批消息，但是当程序代码不能在max.poll.interval.ms配置的期望时间内处理这些消息的话，kafka就会认为这个消费者已经挂了，会进行rebalance，同时你这个消费者就无法再拉取到任何消息了。
举个例子：当你需要一个24小时的延迟消息队列，在代码里面写下了Thread.sleep(1000*60*60*24);，为了不发生rebalance，你把max.poll.interval.ms 也改成了1000*60*60*24，这个时候你或许会感觉到一丝丝的怪异，我是谁？我在哪？我为什么要写出来这样的代码？
其实我们可以更优雅的处理这个问题。
KafkaConsumer 提供了暂停和恢复的API函数，调用消费者的暂停方法后就无法再拉取到新的消息，同时长时间不消费kafka也不会认为这个消费者已经挂掉了。另外为了能够更加优雅，我们会启动一个定时器来替换sleep。，完整流程如下图，当消费者发现消息不满足条件时，我们就暂停消费者，并把偏移量seek到上一次消费的位置以便等待下一个周期再次消费这条消息。
Java代码实现 import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import org.apache.kafka.clients.consumer.*; import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.ProducerConfig; import org.apache.kafka.clients.producer.ProducerRecord; import org.apache.kafka.common.TopicPartition; import org.apache.kafka.common.serialization.StringDeserializer; import org.apache.kafka.common.serialization.StringSerializer; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import java.time.Duration; import java.util.*; import java.util.concurrent.ExecutionException; @SpringBootTest public class DelayQueueTest { private KafkaConsumer&lt;String, String> consumer; private KafkaProducer&lt;String, String> producer; private volatile Boolean exit = false; private final Object lock = new Object(); private final String servers = ""; @BeforeEach void initConsumer() { Properties props = new Properties(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, servers); props.put(ConsumerConfig.GROUP_ID_CONFIG, "d"); props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "false"); props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest"); props.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed"); props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, "5000"); consumer = new KafkaConsumer&lt;>(props, new StringDeserializer(), new StringDeserializer()); } @BeforeEach void initProducer() { Properties props = new Properties(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, servers); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName()); producer = new KafkaProducer&lt;>(props); } @Test void testDelayQueue() throws JsonProcessingException, InterruptedException { String topic = "delay-minutes-1"; List&lt;String> topics = Collections.singletonList(topic); consumer.subscribe(topics); Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { synchronized (lock) { consumer.resume(consumer.paused()); lock.notify(); } } }, 0, 1000); do { synchronized (lock) { ConsumerRecords&lt;String, String> consumerRecords = consumer.poll(Duration.ofMillis(200)); if (consumerRecords.isEmpty()) { lock.wait(); continue; } boolean timed = false; for (ConsumerRecord&lt;String, String> consumerRecord : consumerRecords) { long timestamp = consumerRecord.timestamp(); TopicPartition topicPartition = new TopicPartition(consumerRecord.topic(), consumerRecord.partition()); if (timestamp + 60 * 1000 &lt; System.currentTimeMillis()) { String value = consumerRecord.value(); ObjectMapper objectMapper = new ObjectMapper(); JsonNode jsonNode = objectMapper.readTree(value); JsonNode jsonNodeTopic = jsonNode.get("topic"); String appTopic = null, appKey = null, appValue = null; if (jsonNodeTopic != null) { appTopic = jsonNodeTopic.asText(); } if (appTopic == null) { continue; } JsonNode jsonNodeKey = jsonNode.get("key"); if (jsonNodeKey != null) { appKey = jsonNode.asText(); } JsonNode jsonNodeValue = jsonNode.get("value"); if (jsonNodeValue != null) { appValue = jsonNodeValue.asText(); } // send to application topic ProducerRecord&lt;String, String> producerRecord = new ProducerRecord&lt;>(appTopic, appKey, appValue); try { producer.send(producerRecord).get(); // success. commit message OffsetAndMetadata offsetAndMetadata = new OffsetAndMetadata(consumerRecord.offset() + 1); HashMap&lt;TopicPartition, OffsetAndMetadata> metadataHashMap = new HashMap&lt;>(); metadataHashMap.put(topicPartition, offsetAndMetadata); consumer.commitSync(metadataHashMap); } catch (ExecutionException e) { consumer.pause(Collections.singletonList(topicPartition)); consumer.seek(topicPartition, consumerRecord.offset()); timed = true; break; } } else { consumer.pause(Collections.singletonList(topicPartition)); consumer.seek(topicPartition, consumerRecord.offset()); timed = true; break; } } if (timed) { lock.wait(); } } } while (!exit); } } 这段程序是基于SpringBoot 2.4.4版本和 kafka-client 2.7.0版本编写的一个单元测试，需要修改私有变量servers为kafka broker的地址。
...</p></div><footer class=entry-footer><span title='2021-04-18 00:08:38 +0800 +0800'>四月 18, 2021</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to 基于kafka实现延迟队列" href=https://www.typesafe.cn/posts/kafka-delay-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Java的奇技淫巧</h2></header><div class=entry-content><p>Java是一种广泛使用的计算机编程语言、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。
1995年3月23日Sun公司发布了Java，至今已有近26年，可以说是一门十分成熟的开发语言了，但在某些不为人知的地方存在着一些意料之外的特性。
Java的保留关键字 goto和const 在Java里面没有goto这个功能，但它作为保留字是无法当做变量来使用的，const也是同样。
int goto = 0; int const = 0; 上面这两行代码的写法存在问题，无法正常编译通过。
Java标签Label 上面说了在Java里面没有goto这个功能，但为了处理多重循环引入了Label，目的是为了在多重循环中方便的使用 break 和coutinue ，但好像在其他地方也可以用。
outerLoop: while (true) { System.out.println("I'm the outer loop"); int i = 0; while (true) { System.out.println("I am the inner loop"); i++; if (i >= 3) { break outerLoop; } } } System.out.println("Complete the loop"); // 输出 I'm the outer loop I am the inner loop I am the inner loop I am the inner loop Complete the loop test: { System.out.println("hello"); if (true) { break test; // works } System.out.println("world"); } // 输出 hello test: if (true) { System.out.println("hello"); if (true) { break test; // works } System.out.println("world"); } // 输出 hello test: try { System.out.println("hello"); if (true) { break test; // works } System.out.println("world"); } finally { } // 输出 hello Integer的是否相等问题 日常开发使用到Java基本数据类型是不可避免的一件事，但它却包含了一些很容易犯错的点，踩过一些坑的同学可能了解Java基本包装类型的常量池技术，例如Integer就具有数值[-128，127] 的相应类型的缓存数据，但下面定义的4个变量是否相等你是否能说的出来呢？
...</p></div><footer class=entry-footer><span title='2021-03-13 13:49:38 +0800 +0800'>三月 13, 2021</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to Java的奇技淫巧" href=https://www.typesafe.cn/posts/java-unexpected-features/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux 环回网络接口</h2></header><div class=entry-content><p>在开发或者调试时，我们经常需要和本地的服务器进行通信，例如启动nginx之后，在浏览器输入lcoalhost或者127.0.0.1就可以访问到本机上面的http服务。
Linux是如何访问本机IP的？ 大多数操作系统都在网络层实现了环回能力，通常是使用一个虚拟的环回网络接口来实现。这个虚拟的环回网络接口看着像是一个真实的网卡，实际上是操作系统用软件模拟的，它可以通过TCP/IP与同一台主机上的其他服务进行通信，以127开头的IPv4地址就是为它保留的，主流Linux操作系统为环回网卡分配的地址都是127.0.0.1，主机名是localhost。
环回网络接口之所以被称之为环回网络接口，是因为从本机发送到本机任意一个IP的数据报文都会在网络层交给环回网络接口，不再下发到数据链路层进行处理，环回网络接口直接发送回网络层，最终交由应用层软件程序进行处理。这种方式对于性能测试非常有用，因为省去了硬件的开销，可以直接测试协议栈软件所需要的时间。
那环回网络接口是如何判断目的IP是否为本机地址的呢？
答案就是网络层在进行路由转发的时候会先查本地的路由表，发现是本机IP后交给环回网络接口。查看本地路由表的命令如下：
ip route show table local 输出内容如下：
broadcast 10.141.128.0 dev eth0 proto kernel scope link src 10.141.155.131 local 10.141.155.131 dev eth0 proto kernel scope host src 10.141.155.131 broadcast 10.141.191.255 dev eth0 proto kernel scope link src 10.141.155.131 broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1 其中local开头的便是本地IP，dev后面是网卡名称。
...</p></div><footer class=entry-footer><span title='2021-01-28 22:59:00 +0000 UTC'>一月 28, 2021</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;dushixiang</footer><a class=entry-link aria-label="post link to Linux 环回网络接口" href=https://www.typesafe.cn/posts/linux-loopback/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://www.typesafe.cn/posts/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://www.typesafe.cn/posts/page/3/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://www.typesafe.cn/>整点Bug</a></span> ·
<span>& <a href=https://beian.miit.gov.cn rel=noopener target=_blank>豫ICP备16012145号-3</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>