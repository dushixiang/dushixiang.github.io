<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="tcpwall
当我们想要阻止某些TCP连接的建立，在Linux平台上有一个很好的解决方案iptables，但是对那些已经建立的tcp连接，iptables就不能做到随心所欲的阻断了。
我在互联网上检索的时候发现了tcpkill这个工具，tcpkill是一个网络分析工具集dsniff中的一个小工具。在Linux上可以直接通过dsniff包安装，使用方式也非常简单。
通过测试我发现tcpkill在执行命令之后并不会立刻阻断tcp连接，而是等待有数据传输时，才会阻断，因此在执行完命令之后程序并不会主动退出，而是需要通过Ctrl+C来退出，这对于某些想要通过程序来调用的脚本小子（例如我）来说简直是个灾难。
如何阻断一个已经建立的tcp连接？
阻断一个已经建立的tcp连接通常有这几种方案：

服务端主动断开
客户端主动断开
拔掉网线（时间要超过tcp超时时间）
伪造RST数据包发送给服务端和客户端让它们主动断开（tcpkill就是这么做的）

前三种局限性太大，只能用第4种了。
如何实现伪造RST数据报文包？
GoPacket 是go基于libpcap构建的一个库，可以通过旁路的方式接收一份数据包的拷贝。因此我们可以很方便捕获到正在通信的tcp数据报文。通过数据报文，我们可以获取到通信双方的MAC地址，IP和端口号，以及ACK号等，这些都是伪造数据包必不可少的。
在学习了tcpkill的源码之后，我使用go开发了一个增强版的tcpwall，tcpwall不仅可以实现和tcpkill同样的基于ip或端口监听到指定数据报文之后伪造RST数据报文来阻断tcp连接，也可以通过源ip源端口，目的ip目的端口来主动发送SYN数据报文包来诱导那些没有数据的tcp连接发送ACK数据报文包以获取源MAC、目的MAC和ACK号，并且可以通过指定参数让程序等待一段时间后主动退出。
如何使用
阻断指定IP和端口的TCP连接（不关心是源或者目的）
tcpwall -i {interface} -host {host} -port {port}
阻断指定源IP和源端口的TCP连接
tcpwall -i {interface} -shost {src_host} -sport {src_port}
阻断指定目的IP和目的端口的TCP连接
tcpwall -i {interface} -dhost {dst_host} -dport {dst_port}
阻断指定源IP、源端口、目的IP、目的端口的TCP连接（会主动向双方发送SYN数据报文包）
tcpwall -i {interface} -shost {src_host} -sport {src_port} -dhost {dst_host} -dport {dst_port}
其他

-timeout 时间（秒）指定等待多久之后退出程序

项目地址 https://github.com/dushixiang/tcpwall"><title>tcpkill在go语言下的实现和增强</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.0568d3f70e9896300444ff10565468b82c2dace6b1b82bc72fba6ae51bfb0849887e0eb4ccb3cdb1c915fbe68c7000fbea631be9322fd5d0bcab56732ce7293f.css integrity="sha512-BWjT9w6YljAERP8QVlRouCwtrOaxuCvHL7pq5Rv7CEmIfg60zLPNsckV++aMcAD76mMb6TIv1dC8q1ZzLOcpPw=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2020-10-31 00:00:00 +0000 UTC">2020-10-31</time></p></div><article><h1>tcpkill在go语言下的实现和增强</h1><h2 id=tcpwall>tcpwall</h2><p>当我们想要阻止某些TCP连接的建立，在Linux平台上有一个很好的解决方案<strong>iptables</strong>，但是对那些已经建立的tcp连接，iptables就不能做到随心所欲的阻断了。</p><p>我在互联网上检索的时候发现了<strong>tcpkill</strong>这个工具，tcpkill是一个网络分析工具集<strong>dsniff</strong>中的一个小工具。在Linux上可以直接通过dsniff包安装，使用方式也非常简单。</p><p>通过测试我发现tcpkill在执行命令之后并不会立刻阻断tcp连接，而是等待有数据传输时，才会阻断，因此在执行完命令之后程序并不会主动退出，而是需要通过<em><strong>Ctrl+C</strong></em>来退出，这对于某些想要通过程序来调用的脚本小子（例如我）来说简直是个灾难。</p><h2 id=如何阻断一个已经建立的tcp连接>如何阻断一个已经建立的tcp连接？</h2><p>阻断一个已经建立的tcp连接通常有这几种方案：</p><ol><li>服务端主动断开</li><li>客户端主动断开</li><li>拔掉网线（时间要超过tcp超时时间）</li><li>伪造RST数据包发送给服务端和客户端让它们主动断开（tcpkill就是这么做的）</li></ol><p>前三种局限性太大，只能用第4种了。</p><h2 id=如何实现伪造rst数据报文包>如何实现伪造RST数据报文包？</h2><p><a href=https://github.com/google/gopacket>GoPacket</a> 是go基于<strong>libpcap</strong>构建的一个库，可以通过旁路的方式接收一份数据包的拷贝。因此我们可以很方便捕获到正在通信的tcp数据报文。通过数据报文，我们可以获取到通信双方的MAC地址，IP和端口号，以及ACK号等，这些都是伪造数据包必不可少的。</p><p>在学习了<strong>tcpkill</strong>的源码之后，我使用go开发了一个增强版的<strong>tcpwall</strong>，<strong>tcpwall</strong>不仅可以实现和<strong>tcpkill</strong>同样的基于ip或端口监听到指定数据报文之后伪造RST数据报文来阻断tcp连接，也可以通过源ip源端口，目的ip目的端口来主动发送SYN数据报文包来诱导那些没有数据的tcp连接发送ACK数据报文包以获取源MAC、目的MAC和ACK号，并且可以通过指定参数让程序等待一段时间后主动退出。</p><h2 id=如何使用>如何使用</h2><p>阻断指定IP和端口的TCP连接（不关心是源或者目的）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpwall -i <span style=color:#ff79c6>{</span>interface<span style=color:#ff79c6>}</span> -host <span style=color:#ff79c6>{</span>host<span style=color:#ff79c6>}</span> -port <span style=color:#ff79c6>{</span>port<span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>阻断指定源IP和源端口的TCP连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpwall -i <span style=color:#ff79c6>{</span>interface<span style=color:#ff79c6>}</span> -shost <span style=color:#ff79c6>{</span>src_host<span style=color:#ff79c6>}</span> -sport <span style=color:#ff79c6>{</span>src_port<span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>阻断指定目的IP和目的端口的TCP连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpwall -i <span style=color:#ff79c6>{</span>interface<span style=color:#ff79c6>}</span> -dhost <span style=color:#ff79c6>{</span>dst_host<span style=color:#ff79c6>}</span> -dport <span style=color:#ff79c6>{</span>dst_port<span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>阻断指定源IP、源端口、目的IP、目的端口的TCP连接（会主动向双方发送SYN数据报文包）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tcpwall -i <span style=color:#ff79c6>{</span>interface<span style=color:#ff79c6>}</span> -shost <span style=color:#ff79c6>{</span>src_host<span style=color:#ff79c6>}</span> -sport <span style=color:#ff79c6>{</span>src_port<span style=color:#ff79c6>}</span> -dhost <span style=color:#ff79c6>{</span>dst_host<span style=color:#ff79c6>}</span> -dport <span style=color:#ff79c6>{</span>dst_port<span style=color:#ff79c6>}</span>
</span></span></code></pre></div><h2 id=其他>其他</h2><ul><li>-timeout 时间（秒）指定等待多久之后退出程序</li></ul><p>项目地址 <a href=https://github.com/dushixiang/tcpwall>https://github.com/dushixiang/tcpwall</a></p></article></div></main></body></html>